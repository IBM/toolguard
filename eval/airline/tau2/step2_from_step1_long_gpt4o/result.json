{
  "domain": {
    "app_name": "airline",
    "toolguard_common": {
      "file_name": "rt_toolguard/data_types.py",
      "content": "from abc import ABC, abstractmethod\nimport os\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import Any, List, Optional\n\nDEBUG_DIR = \"debug\"\nTESTS_DIR = \"tests\"\nRESULTS_FILENAME = \"result.json\"\nHISTORY_PARAM = \"history\"\nHISTORY_PARAM_TYPE = \"ChatHistory\"\nAPI_PARAM = \"api\"\n\nclass FileTwin(BaseModel):\n    file_name: str\n    content: str\n\n    def save(self, folder:str)->'FileTwin':\n        full_path = os.path.join(folder, self.file_name)\n        parent = Path(full_path).parent\n        os.makedirs(parent, exist_ok=True)\n        with open(full_path, \"w\") as file:\n            file.write(self.content)\n        return self\n\n    def save_as(self, folder:str, file_name:str)->'FileTwin':\n        file_path = os.path.join(folder, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(self.content)\n        return FileTwin(file_name=file_name, content=self.content)\n\n    @staticmethod\n    def load_from(folder:str, file_path:str)->'FileTwin':\n        with open(os.path.join(folder, file_path), \"r\") as file:\n            data = file.read()\n            return FileTwin(\n                file_name=file_path, \n                content=data\n            )\n\nclass ToolPolicyItem(BaseModel):\n    name: str = Field(..., description=\"Policy item name\")\n    description: str = Field(..., description=\"Policy item description\")\n    references: List[str] = Field(..., description=\"original texts\")\n    compliance_examples: Optional[List[str]] = Field(..., description=\"Example of cases that comply with the policy\")\n    violation_examples: Optional[List[str]] = Field(..., description=\"Example of cases that violate the policy\")\n\n    def to_md_bulltets(self, items: List[str])->str:\n        s = \"\"\n        for item in items:\n            s+=f\"* {item}\\n\"\n        return s\n    \n    def __str__(self) -> str:\n        s = f\"#### Policy item \" + self.name + \"\\n\"\n        s += f\"{self.description}\\n\"\n        if self.compliance_examples:\n            s += f\"##### Positive examples\\n{self.to_md_bulltets(self.compliance_examples)}\"\n        if self.violation_examples:\n            s += f\"##### Negative examples\\n{self.to_md_bulltets(self.violation_examples)}\"\n        return s\n\nclass ToolPolicy(BaseModel):\n    tool_name: str = Field(..., description=\"Name of the tool\")\n    policy_items: List[ToolPolicyItem] = Field(..., description=\"Policy items. All (And logic) policy items must hold whehn invoking the tool.\")\n\nclass Domain(BaseModel):\n    app_name: str = Field(..., description=\"Application name\")\n    toolguard_common: FileTwin = Field(..., description=\"Pydantic data types used by toolguard framework.\")\n    app_types: FileTwin = Field(..., description=\"Data types defined used in the application API as payloads.\")\n    app_api_class_name: str = Field(..., description=\"Name of the API class name.\")\n    app_api: FileTwin = Field(..., description=\"Python class (abstract) containing all the API signatures.\")\n    app_api_size: int = Field(..., description=\"Number of functions in the API\")\n\nclass RuntimeDomain(Domain):\n    app_api_impl_class_name: str = Field(..., description=\"Python class (implementaton) class name.\")\n    app_api_impl: FileTwin = Field(..., description=\"Python class containing all the API method implementations.\")\n\nclass ChatHistory(ABC):\n    \"\"\"Represents a history of chat messages and provides methods check if specific events already happened.\"\"\"\n\n    @abstractmethod\n    def ask_bool(self, question:str)->bool:\n        \"\"\"\n        Asks a yes/no question and returns the response as a boolean.\n\n        Args:\n            question (str): The yes/no question to be asked. Example: \"Did the user accepted the agent's proposal?\"\n\n        Returns:\n            bool: The interpreted boolean response from the language model.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def did_tool_return_value(self, tool_name:str, expected_value:Any)->bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history and validates if the expected value was returned\n            Example: \"did_tool_return_value(\"book_hotel\",True) checks if the history shows calling the function book_hotel and if the returned value was true did_tool_return_value will return true else false\n        \n        Args:\n            tool_name (str): The name of the tool to check for in the message history.\n            expected_value: The expected value of the tool call.\n        \n        Returns:\n            bool: True if the tool was called returning expected_value, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def was_tool_called(self, tool_name: str) -> bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history.\n\t\tArgs:\n\t\t\ttool_name (str): The name of the tool to check for in the message history.\n\t\tReturns:\n\t\t\tbool: True if the tool was called, False otherwise.\n\t\t\"\"\"\n        pass\n\n\nclass PolicyViolationException(Exception):\n    _msg: str\n    def __init__(self, message:str):\n        super().__init__(message)\n        self._msg = message\n\n    @property\n    def message(self):\n        return self._msg\n"
    },
    "app_types": {
      "file_name": "airline/airline_types.py",
      "content": "# Auto-generated type definitions\nfrom enum import Enum\nfrom abc import ABC\nfrom typing import *\nfrom pydantic import BaseModel, Field\n\nclass FlightDateStatusCancelled(BaseModel):\n    status: Literal['cancelled']  # Indicates flight was cancelled\n\nclass FlightInfo(BaseModel):\n    flight_number: str  # Flight number, such as 'HAT001'.\n    date: str  # The date for the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\nclass Passenger(BaseModel):\n    first_name: str  # Passenger's first name\n    last_name: str  # Passenger's last name\n    dob: str  # Date of birth in YYYY-MM-DD format\n\nclass PaymentMethodBase(BaseModel):\n    source: str  # Type of payment method\n    id: str  # Unique identifier for the payment method\n\nclass FlightDateStatusDelayed(BaseModel):\n    status: Literal['delayed']  # Indicates flight was delayed\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDataStatusFlying(BaseModel):\n    status: Literal['flying']  # Indicates flight is in flight\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass AirportCode(BaseModel):\n    iata: str  # IATA code\n    city: str  # City name\n\nclass FlightDateStatusAvailable(BaseModel):\n    status: Literal['available']  # Indicates flight is available for booking\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass FlightBase(BaseModel):\n    flight_number: str  # Unique flight identifier\n    origin: str  # IATA code for origin airport\n    destination: str  # IATA code for destination airport\n\nclass Name(BaseModel):\n    first_name: str  # The person's first name\n    last_name: str  # The person's last name\n\nclass FlightDateStatusLanded(BaseModel):\n    status: Literal['landed']  # Indicates flight has landed\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    actual_arrival_time_est: str  # Actual arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDataStatusOnTime(BaseModel):\n    status: Literal['on time']  # Indicates flight is on time\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass Payment(BaseModel):\n    payment_id: str  # Unique identifier for the payment\n    amount: int  # Payment amount in dollars\n\nclass Address(BaseModel):\n    address1: str  # Primary address line\n    address2: Optional[str]  # Secondary address line (optional)\n    city: str  # City name\n    country: str  # Country name\n    state: str  # State or province name\n    zip: str  # Postal code\n\nclass Certificate(PaymentMethodBase):\n    source: Literal['certificate']  # Indicates this is a certificate payment method\n    amount: float  # Certificate value amount\n\nclass CreditCard(PaymentMethodBase):\n    source: Literal['credit_card']  # Indicates this is a credit card payment method\n    brand: str  # Credit card brand (e.g., visa, mastercard)\n    last_four: str  # Last four digits of the credit card\n\nclass GiftCard(PaymentMethodBase):\n    source: Literal['gift_card']  # Indicates this is a gift card payment method\n    amount: float  # Gift card value amount\n    id: str  # Unique identifier for the gift card\n\nclass DirectFlight(FlightBase):\n    status: Literal['available']  # Indicates flight is available for booking\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    date: Optional[str]  # Flight date in YYYY-MM-DD format\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass ReservationFlight(FlightBase):\n    date: str  # Flight date in YYYY-MM-DD format\n    price: int  # Flight price in dollars.\n\nclass Flight(FlightBase):\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    dates: dict[str, Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]]  # Flight status by date (YYYY-MM-DD)\n\nclass User(BaseModel):\n    user_id: str  # Unique identifier for the user\n    name: Name  # User's full name\n    address: Address  # User's address information\n    email: str  # User's email address\n    dob: str  # User's date of birth in the format YYYY-MM-DD, e.g 1990-04-05\n    payment_methods: dict[str, Union[CreditCard, GiftCard, Certificate]]  # User's saved payment methods\n    saved_passengers: list[Passenger]  # User's saved passenger information\n    membership: Literal['gold', 'silver', 'regular']  # User's membership level\n    reservations: list[str]  # List of user's reservation IDs\n\nclass Reservation(BaseModel):\n    reservation_id: str  # Unique identifier for the reservation\n    user_id: str  # ID of the user who made the reservation\n    origin: str  # IATA code for trip origin\n    destination: str  # IATA code for trip destination\n    flight_type: Literal['round_trip', 'one_way']  # Type of trip\n    cabin: Literal['business', 'economy', 'basic_economy']  # Selected cabin class\n    flights: list[ReservationFlight]  # List of flights in the reservation\n    passengers: list[Passenger]  # List of passengers on the reservation\n    payment_history: list[Payment]  # History of payments for this reservation\n    created_at: str  # Timestamp when reservation was created in the format YYYY-MM-DDTHH:MM:SS\n    total_baggages: int  # Total number of bags in reservation\n    nonfree_baggages: int  # Number of paid bags in reservation\n    insurance: Literal['yes', 'no']  # Whether travel insurance was purchased\n    status: Optional[Literal['cancelled']]  # Status of the reservation\n"
    },
    "app_api_class_name": "I_Airline",
    "app_api": {
      "file_name": "airline/i_airline.py",
      "content": "# Auto-generated class interface\nfrom typing import * # type: ignore\nfrom abc import ABC, abstractmethod\nfrom airline.airline_types import *\n\nclass I_Airline(ABC):\n\n    @abstractmethod\n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n        ...\n"
    },
    "app_api_size": 16,
    "app_api_impl_class_name": "Airlineimpl",
    "app_api_impl": {
      "file_name": "airline/airline_impl.py",
      "content": "# Auto-generated class\nfrom typing import *\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass Airlineimpl(I_Airline):\n\n    def __init__(self, delegate: I_Airline):\n        self._delegate = delegate\n    \n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n\n        return self._delegate.book_reservation(user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n\n\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n\n        return self._delegate.calculate(expression)\n\n\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.cancel_reservation(reservation_id)\n\n\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_instance(flight_number, date)\n\n\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_status(flight_number, date)\n\n\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.get_reservation_details(reservation_id)\n\n\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_scheduled_flight(flight_number)\n\n\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.get_user_details(user_id)\n\n\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n\n        return self._delegate.list_all_airports()\n\n\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n\n        return self._delegate.search_direct_flight(origin, destination, date)\n\n\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n\n        return self._delegate.search_onestop_flight(origin, destination, date)\n\n\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.send_certificate(user_id, amount)\n\n\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n\n        return self._delegate.transfer_to_human_agents(summary)\n\n\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_baggages(reservation_id, total_baggages, nonfree_baggages, payment_id)\n\n\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_flights(reservation_id, cabin, flights, payment_id)\n\n\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n\n        return self._delegate.update_reservation_passengers(reservation_id, passengers)\n\n"
    }
  },
  "tools": {
    "book_reservation": {
      "tool": {
        "tool_name": "book_reservation",
        "policy_items": [
          {
            "name": "User Confirmation Before Database Update",
            "description": "Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before finalizing a new reservation for Emily, including flight details, passenger names, and baggage information, the system displays all changes to Emily and obtains her explicit 'yes' confirmation to proceed with the booking.",
              "Jane wants to change her seat to economy class and add an additional baggage item to her reservation. The system provides a detailed summary of these changes and asks Jane to confirm with a 'yes' before proceeding.",
              "While updating passenger details and flight preference for Michael's trip, the system presents all updates to him clearly and requests a 'yes' confirmation to ensure understanding and agreement before making any database changes.",
              "George received a notice about his frequent flyer miles being used for an upgrade to business class; the system displays the upgrade details and asks George for an explicit 'yes' confirmation before applying the change.",
              "Anna reviews the summary of her amended flight itinerary and cabin upgrade. The system awaits her verbal confirmation of 'yes' before making any updates to her reservation in the database.",
              "Before executing a booking for Tom's round-trip flight and adding travel insurance, the system presents all reservation details and secures a 'yes' confirmation from Tom before proceeding.",
              "Lisa wants to adjust her travel itinerary by changing the flight type to one-way and removing insurance coverage. The system displays these proposed updates and requires Lisa to confirm with a 'yes' before finalizing the changes.",
              "During the reservation process for Kevin's flight, which includes preferences for basic economy cabin and payment method adjustments, the system details all intended changes and obtains Kevin's affirmative 'yes' to proceed."
            ],
            "violation_examples": [
              "The system attempts to book a reservation and update the flight details without displaying them to the user first. John does not get the chance to review or confirm these changes before they are applied. It proceeds without obtaining an affirmative 'yes' from John.",
              "The system updates the number of non-free baggage items directly based on the user's preferences without explicitly asking for a 'yes' confirmation. This violates the policy by not requesting confirmation before making database changes.",
              "After Sarah requests an upgrade to business class for her flight reservation, the system processes the upgrade without sending her a summary of the changes and obtaining her confirmation. This fails to meet the user confirmation requirement.",
              "Tom modifies passenger information for his upcoming flight, yet the system saves these updates without showing Tom the new passenger details and without an affirmative 'yes' from him. This action violates user confirmation policy.",
              "The computer applies changes to Mark's reservation for round-trip flights and edits to baggage allowance based on a prior conversation but fails to explicitly ask for confirmation from Mark before updating the database. This contradicts the policy's confirmation mandate.",
              "Rachel wants to book a flight from LAX to JFK with a cabin upgrade, but the system updates her reservation without displaying changes and fails to obtain explicit 'yes' confirmation. This violates policy requirements on user confirmation.",
              "The system processes a reservation update for David's flight details after he selects new departure times but does not display these changes or ask for David's approval before applying them. Lacking explicit confirmation is a violation.",
              "After Nancy requests additional baggage and a change in passenger details, the system performs these updates without listing them for her and without requesting a 'yes' confirmation. This breaches the user confirmation policy."
            ]
          },
          {
            "name": "Flight Passenger Limit for Booking",
            "description": "A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.",
            "references": [
              "Passengers: Each reservation can have at most five passengers. The agent needs to collect the first name, last name, and date of birth for each passenger. All passengers must fly the same flights in the same cabin."
            ],
            "compliance_examples": [
              "Booking for three passengers: John Doe, Jane Smith, and Alex Murphy, all flying economy class from JFK to SFO with identical flight segments, fits the maximum passenger limit and same flight itinerary requirement.",
              "A reservation for five passengers, all flying from SFO to JFK in basic economy, with collected details including first name, last name, and date of birth for each passenger, adheres to the policy's constraints.",
              "Booking for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown from JFK to LAX in business class, all having the exact flight itinerary and cabin. This meets the policy requirements for passenger limits and identical flight itineraries.",
              "Two passengers, John Doe and Jane Smith, fly together on a round_trip from SFO to MIA in economy class, maintaining identical flight itineraries and cabin, complying with the policy.",
              "One reservation for four passengers all flying from SFO to JFK in basic economy class, with first name, last name, and date of birth collected for each. The reservation complies with passenger limits and identical flight requirements."
            ],
            "violation_examples": [
              "A reservation is attempted for six passengers: John Doe, Jane Smith, Alex Murphy, Ella Brown, Chris Davis, and Emily White, which exceeds the maximum allowed five passengers per reservation.",
              "A reservation is made for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown, with John flying business class and the others flying economy. Cabin classes must be the same for all passengers within a reservation.",
              "Three passengers, John Doe, Jane Smith, and Alex Murphy, have different flight itineraries: John and Jane are flying from JFK to SFO, and Alex is flying from LAX to SFO. All passengers must share the same flight itinerary.",
              "Booking for two passengers, John Doe and Jane Smith, with different flight types: John on a 'one_way' ticket and Jane on a 'round_trip' ticket. Flight types must be identical among passengers in the reservation.",
              "A reservation for five passengers includes one passenger flying only part of the shared flight itinerary. All passengers are required to fly all shared flights together."
            ]
          },
          {
            "name": "Payment Method Limits in Booking",
            "description": "Each reservation can use at most one travel certificate, one credit card, and three gift cards.",
            "references": [
              "<p>Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons.</p>"
            ],
            "compliance_examples": [
              "A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.",
              "Booking a trip with one credit card and one gift card, complying perfectly with the policy by using no travel certificates.",
              "A booking that utilizes one travel certificate and three gift cards but no credit card, fitting within the acceptable boundaries.",
              "A reservation uses exactly one credit card and no other forms of payment, showing compliance with guidelines.",
              "A reservation is booked using one travel certificate, two gift cards, and no credit card. This adheres to the policy's restrictions on payment use by staying within the boundaries for each method."
            ],
            "violation_examples": [
              "A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.",
              "A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.",
              "Attempting to book a flight using one travel certificate and four gift cards, which breaches the limit on gift cards.",
              "A user uses two credit cards, exceeding the number allowed per reservation.",
              "An attempt is made to book a reservation using zero travel certificates, three credit cards, and four gift cards, violating the restriction on both credit card and gift card quantities."
            ]
          },
          {
            "name": "User ID Requirement for Flight Booking",
            "description": "The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.",
            "references": [
              "The agent must first obtain the user id, then ask for the trip type, origin, destination."
            ],
            "compliance_examples": [
              "The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.",
              "User ID is obtained and validated first, followed by inquiries about flight type, cabin class, and insurance coverage, maintaining the correct sequence as per policy.",
              "Upon confirming the user's ID, such as 'sara_doe_496', the agent systematically handles inquiries about flight specifics, ensuring compliance through verification of user ID first."
            ],
            "violation_examples": [
              "The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.",
              "Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.",
              "The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy."
            ]
          },
          {
            "name": "Prohibition on Modifying User's Passenger Count",
            "description": "The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.",
            "references": [
              "<p>The",
              "user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "An agent updates passengers' details such as name spelling, date of birth, or contact information without changing the established number of passengers in the reservation.",
              "Agent makes changes to existing passenger preferences like seat, dietary needs, or passport details while keeping the passenger count unchanged, demonstrating compliance with the policy.",
              "The agent modifies information such as language preference or special assistance needs for existing reservation passengers, maintaining the originally specified number of passengers."
            ],
            "violation_examples": [
              "An agent attempts to alter the number of passengers in a reservation by changing the count, such as from 2 to 3, violating the policy of immutability on passenger count.",
              "The reservation system allows an agent to add or remove passengers, such as reducing the passenger count established from 5 to 4, thereby violating the no-alteration policy.",
              "Without user consent, the agent modifies the passenger count from the initially scheduled 3 passengers to 2, which goes against the policy of maintaining a fixed passenger count."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_book_reservation",
      "guard_file": {
        "file_name": "airline/book_reservation/guard_book_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.book_reservation.guard_user_confirmation_before_database_update import guard_user_confirmation_before_database_update\nfrom airline.book_reservation.guard_flight_passenger_limit_for_booking import guard_flight_passenger_limit_for_booking\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.book_reservation.guard_prohibition_on_modifying_user_s_passenger_count import guard_prohibition_on_modifying_user_s_passenger_count\n\n\ndef guard_book_reservation(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance. \n    \"\"\"\n    \n    guard_user_confirmation_before_database_update(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_flight_passenger_limit_for_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_payment_method_limits_in_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_user_id_requirement_for_flight_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_prohibition_on_modifying_user_s_passenger_count(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/book_reservation/guard_user_confirmation_before_database_update.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_confirmation_before_database_update(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Check if user confirmation is present in the chat history\n    confirmation_question = \"Did the user confirm the reservation details with a 'yes'?\"\n    user_confirmed = history.ask_bool(confirmation_question)\n\n    if not user_confirmed:\n        raise PolicyViolationException(\"User did not provide a 'yes' confirmation for the reservation details.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_flight_passenger_limit_for_booking.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_passenger_limit_for_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_payment_method_limits_in_booking.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_limits_in_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Count the number of each type of payment method\n    certificate_count = sum(1 for payment in payment_methods if isinstance(payment, Certificate))\n    credit_card_count = sum(1 for payment in payment_methods if isinstance(payment, CreditCard))\n    gift_card_count = sum(1 for payment in payment_methods if isinstance(payment, GiftCard))\n\n    # Check policy limits\n    if certificate_count > 1:\n        raise PolicyViolationException(\"More than one travel certificate is not allowed.\")\n    if credit_card_count > 1:\n        raise PolicyViolationException(\"More than one credit card is not allowed.\")\n    if gift_card_count > 3:\n        raise PolicyViolationException(\"More than three gift cards are not allowed.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_user_id_requirement_for_flight_booking.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_id_requirement_for_flight_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Check if user_id is provided\n    if not user_id:\n        raise PolicyViolationException(\"User ID must be obtained before proceeding with flight booking.\")\n\n    # Validate user_id by checking if user details can be retrieved\n    try:\n        user_details = api.get_user_details(user_id)\n    except ValueError:\n        raise PolicyViolationException(\"Invalid user ID. User details could not be retrieved.\")\n\n    # Ensure user_id is obtained before any other inquiries\n    if not history.was_tool_called('get_user_details'):\n        raise PolicyViolationException(\"User ID must be obtained before any inquiries on trip type, origin, and destination.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_prohibition_on_modifying_user_s_passenger_count.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_prohibition_on_modifying_user_s_passenger_count(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/book_reservation/test_guard_user_confirmation_before_database_update.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_user_confirmation_before_database_update import guard_user_confirmation_before_database_update\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardUserConfirmationBeforeDatabaseUpdate:\n\n    def test_compliance_example_emily_reservation_confirmation(self):\n        \"\"\"\n        Policy: \"Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.\"\n        Example: \"Before finalizing a new reservation for Emily, including flight details, passenger names, and baggage information, the system displays all changes to Emily and obtains her explicit 'yes' confirmation to proceed with the booking.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"emily_123\", name=Name(first_name=\"Emily\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"New York\", country=\"USA\", state=\"NY\", zip=\"10001\"), email=\"emily@example.com\", dob=\"1990-01-01\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"emily_123\" else None\n\n        flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"Emily\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=200)]\n\n        guard_user_confirmation_before_database_update(history, api, \"emily_123\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_example_john_no_confirmation(self):\n        \"\"\"\n        Policy: \"Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.\"\n        Example: \"The system attempts to book a reservation and update the flight details without displaying them to the user first. John does not get the chance to review or confirm these changes before they are applied. It proceeds without obtaining an affirmative 'yes' from John.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        user = User(user_id=\"john_456\", name=Name(first_name=\"John\", last_name=\"Smith\"), address=Address(address1=\"456 Elm St\", address2=None, city=\"Los Angeles\", country=\"USA\", state=\"CA\", zip=\"90001\"), email=\"john@example.com\", dob=\"1985-05-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"john_456\" else None\n\n        flights = [FlightInfo(flight_number=\"FL456\", date=\"2024-06-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-05-05\")]\n        payment_methods = [Payment(payment_id=\"pay_002\", amount=300)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_user_confirmation_before_database_update(history, api, \"john_456\", \"LAX\", \"JFK\", \"one_way\", \"business\", flights, passengers, payment_methods, 3, 2, \"no\")\n"
        },
        null,
        {
          "file_name": "tests/book_reservation/test_guard_payment_method_limits_in_booking.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardPaymentMethodLimitsInBooking:\n\n    def test_compliance_one_certificate_one_credit_two_gifts(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"gift_card_5678\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5678\"), \"certificate_91011\": Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0)}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0), CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), GiftCard(source=\"gift_card\", id=\"gift_card_5678\", amount=50.0)]\n\n        guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_two_certificates_four_gifts(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"gift_card_5678\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5678\"), \"certificate_91011\": Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0)}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0), Certificate(source=\"certificate\", id=\"certificate_91012\", amount=100.0), GiftCard(source=\"gift_card\", id=\"gift_card_5678\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5679\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5680\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5681\", amount=50.0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_three_credit_cards(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"credit_card_5678\": CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\"), \"credit_card_91011\": CreditCard(source=\"credit_card\", id=\"credit_card_91011\", brand=\"amex\", last_four=\"9101\")}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\"), CreditCard(source=\"credit_card\", id=\"credit_card_91011\", brand=\"amex\", last_four=\"9101\")]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_one_certificate_four_gifts(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"Attempting to book a flight using one travel certificate and four gift cards, which breaches the limit on gift cards.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"gift_card_5678\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5678\"), \"certificate_91011\": Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0)}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [Certificate(source=\"certificate\", id=\"certificate_91011\", amount=100.0), GiftCard(source=\"gift_card\", id=\"gift_card_5678\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5679\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5680\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5681\", amount=50.0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_two_credit_cards(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"A user uses two credit cards, exceeding the number allowed per reservation.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"credit_card_5678\": CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\")}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\")]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\n    def test_violation_zero_certificates_three_credit_cards_four_gifts(self):\n        \"\"\"\n        Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n        Example: \"An attempt is made to book a reservation using zero travel certificates, three credit cards, and four gift cards, violating the restriction on both credit card and gift card quantities.\"\n        \"\"\"\n        \n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara@example.com\", dob=\"1990-04-05\", payment_methods={\"credit_card_1234\": CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), \"credit_card_5678\": CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\"), \"credit_card_91011\": CreditCard(source=\"credit_card\", id=\"credit_card_91011\", brand=\"amex\", last_four=\"9101\"), \"gift_card_5678\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5678\"), \"gift_card_5679\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5679\"), \"gift_card_5680\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5680\"), \"gift_card_5681\": GiftCard(source=\"gift_card\", amount=50.0, id=\"5681\")}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\")]\n        payment_methods = [CreditCard(source=\"credit_card\", id=\"credit_card_1234\", brand=\"visa\", last_four=\"1234\"), CreditCard(source=\"credit_card\", id=\"credit_card_5678\", brand=\"mastercard\", last_four=\"5678\"), CreditCard(source=\"credit_card\", id=\"credit_card_91011\", brand=\"amex\", last_four=\"9101\"), GiftCard(source=\"gift_card\", id=\"gift_card_5678\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5679\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5680\", amount=50.0), GiftCard(source=\"gift_card\", id=\"gift_card_5681\", amount=50.0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(history, api, \"sara_doe_496\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_user_id_requirement_for_flight_booking.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardUserIdRequirementForFlightBooking:\n\n    def test_user_id_obtained_before_inquiries(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        # Invoke function under test\n        guard_user_id_requirement_for_flight_booking(\n            history=history,\n            api=api,\n            user_id=\"sara_doe_496\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-06-15\")],\n            payment_methods=[Payment(payment_id=\"credit_card_1234\", amount=500)],\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\n    def test_proceed_without_user_id(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history=history,\n                api=api,\n                user_id=\"\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=[FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")],\n                passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-06-15\")],\n                payment_methods=[Payment(payment_id=\"credit_card_1234\", amount=500)],\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_inquiries_without_user_id_confirmation(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history=history,\n                api=api,\n                user_id=\"\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=[FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")],\n                passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-06-15\")],\n                payment_methods=[Payment(payment_id=\"credit_card_1234\", amount=500)],\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_direct_inquiries_without_user_id(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history=history,\n                api=api,\n                user_id=\"\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=[FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")],\n                passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-06-15\")],\n                payment_methods=[Payment(payment_id=\"credit_card_1234\", amount=500)],\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n"
        },
        null
      ]
    },
    "cancel_reservation": {
      "tool": {
        "tool_name": "cancel_reservation",
        "policy_items": [
          {
            "name": "Strict Cancellation Rules Enforcement",
            "description": "The policy requires ensuring compliance with the cancellation rules before using 'cancel_reservation'. Agents must check if reservations meet these conditions: cancelled by the airline, within 24 hours of booking, or if travel insurance applies due to health or weather. Partial cancellations are prohibited. Transfer to human agents if these rules cannot facilitate cancellation.",
            "references": [
              "All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled.",
              "The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!",
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.",
              "An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.",
              "The agent ensures a business flight reservation is entirely unused and then cancels it, complying with policy stipulations.",
              "An agent confirms health-related travel insurance applies to a reservation due to illness and proceeds to cancel, following policy guidelines.",
              "The agent checks and confirms all conditions are met for whole reservation cancellation since no flights have been used.",
              "An agent validates that a scheduled flight has been cancelled due to inclement weather and proceeds in line with policy requirements.",
              "The agent carefully checks the booking timestamp and confirms it is within the 24-hour cut-off before executing cancellation.",
              "The agent verifies that none of the reservation segments have been flown and checks travel insurance details before proceeding, ensuring adherence."
            ],
            "violation_examples": [
              "An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.",
              "An agent cancels a reservation for a basic economy flight without verifying if travel insurance applies due to health or weather conditions.",
              "The agent proceeds to cancel part of a reservation even when some segments have already been flown, which breaches the rule against partial cancellations.",
              "An agent attempts to cancel a reservation without validating reservation status, leading to cancellation of flown flight segments.",
              "An agent mistakenly cancels a reservation, ignoring policy specifics that business flights require insurance validation post 24 hours.",
              "An agent cancels a reservation based solely on the passenger's request without verifying if airline or insurance cancellation conditions apply."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_cancel_reservation",
      "guard_file": {
        "file_name": "airline/cancel_reservation/guard_cancel_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\n\n\ndef guard_cancel_reservation(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n         \n    \"\"\"\n    \n    guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/cancel_reservation/guard_strict_cancellation_rules_enforcement.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_strict_cancellation_rules_enforcement(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Policy to check: The policy requires ensuring compliance with the cancellation rules before using 'cancel_reservation'. Agents must check if reservations meet these conditions: cancelled by the airline, within 24 hours of booking, or if travel insurance applies due to health or weather. Partial cancellations are prohibited. Transfer to human agents if these rules cannot facilitate cancellation.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n    \"\"\"\n    # Fetch reservation details\n    try:\n        reservation = api.get_reservation_details(reservation_id)\n    except ValueError:\n        raise PolicyViolationException(\"Reservation not found.\")\n\n    # Check if reservation is cancelled by the airline\n    for flight in reservation.flights:\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n        if flight_status == 'cancelled':\n            return  # Airline cancelled, allow cancellation\n\n    # Check if reservation is within 24 hours of booking\n    from datetime import datetime, timedelta\n    booking_time = datetime.strptime(reservation.created_at, \"%Y-%m-%dT%H:%M:%S\")\n    if datetime.now() - booking_time <= timedelta(hours=24):\n        return  # Within 24 hours, allow cancellation\n\n    # Check if travel insurance applies\n    if reservation.insurance == 'yes':\n        # Assuming health or weather conditions are checked externally\n        return  # Insurance applies, allow cancellation\n\n    # Check if any flight segments have been flown\n    for flight in reservation.flights:\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n        if flight_status in ['flying', 'landed']:\n            raise PolicyViolationException(\"Partial cancellations are prohibited.\")\n\n    # If none of the conditions are met, transfer to human agents\n    raise PolicyViolationException(\"Cannot facilitate cancellation under current policy conditions.\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/cancel_reservation/test_guard_strict_cancellation_rules_enforcement.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardStrictCancellationRulesEnforcement:\n\n    def test_cancel_within_24_hours_of_booking(self):\n        \"\"\"\n        Policy: \"An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(hours=23)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        guard_strict_cancellation_rules_enforcement(history, api, \"ZFA04Y\")\n\n    def test_cancelled_by_airline(self):\n        \"\"\"\n        Policy: \"An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"cancelled\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"available\"\n\n        guard_strict_cancellation_rules_enforcement(history, api, \"ZFA04Y\")\n\n    def test_violation_no_check_on_airline_cancellation(self):\n        \"\"\"\n        Policy: \"An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"available\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"cancelled\"\n\n        with pytest.raises(PolicyViolationException):\n            guard_strict_cancellation_rules_enforcement(history, api, \"ZFA04Y\")\n\n    def test_violation_partial_cancellation_attempt(self):\n        \"\"\"\n        Policy: \"The agent proceeds to cancel part of a reservation even when some segments have already been flown, which breaches the rule against partial cancellations.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"flying\" if flight_number == \"HAT001\" and date == \"2024-05-01\" else \"available\"\n\n        with pytest.raises(PolicyViolationException):\n            guard_strict_cancellation_rules_enforcement(history, api, \"ZFA04Y\")\n"
        }
      ]
    },
    "update_reservation_passengers": {
      "tool": {
        "tool_name": "update_reservation_passengers",
        "policy_items": [
          {
            "name": "Ensure User Confirmation",
            "description": "Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.",
              "The agent calls the user, reads out the proposed updates on passenger details, and hears a verbal 'yes' confirming agreement to proceed.",
              "Prior to modification, the agent sends the updated passenger list via chat and waits for the user to type 'yes', confirming the changes.",
              "During a video call, the agent shares the screen showing the new passenger details and verbally confirms with the user by receiving a 'yes'.",
              "The airline agent displays updated passenger information and receives explicit 'yes' confirmation through the user's account portal.",
              "The agent uses a secure messaging platform to send a PDF summary of updates, and upon receiving a recorded voice message with 'yes', proceeds.",
              "During a conference call, the airline agent explains passenger information changes; upon receiving 'yes' in the chat, updates the database.",
              "Before using ToolX, the agent provides changes as downloadable content, waits for an email reply marked with 'yes', then proceeds with the update.",
              "The agent showcases updates through a mobile app notification, allowing the user to press 'Confirm' with 'yes' before executing the update."
            ],
            "violation_examples": [
              "An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.",
              "Without any prior communication or explicit confirmation, an airline agent updates John Doe's reservation details, assuming agreement."
            ]
          },
          {
            "name": "Validate Passenger Number Consistency",
            "description": "When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same. You can change details like name or date of birth, but the total number must not be altered. This rule is critical and an exception cannot be made, even by human agents.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged, adhering to the passenger number consistency policy.",
              "An update is requested for reservation 'ZFA04Y' to correct spelling errors in passengers' names, ensuring the list retains its original size of 2 passengers, thus complying with the policy.",
              "User modifies passenger ages in the reservation with ID 'ZFA04Y', containing 4 passengers, ensuring no passenger is added or removed, thus correctly validating the number consistency as per the policy requirements."
            ],
            "violation_examples": [
              "A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers, violating the rule that the number of passengers must remain unchanged.",
              "A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers, which incorrectly alters the total count of passengers.",
              "User requests an update on reservation 'ZFA04Y' by submitting a list of 5 passengers, while the original reservation only contained 4, thus conflicting with the passenger count policy."
            ]
          },
          {
            "name": "Transfer Requirement for Human Assistance",
            "description": "Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.",
            "references": [
              "<p>You should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions.</p>",
              "<p>Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged, and the agent successfully uses 'update_reservation_passengers', complying with the tool's capabilities and policy requirements.",
              "An agent receives a request to alter details such as contact or passport information for passengers, ensuring no change in the passenger count, and efficiently addresses it using 'update_reservation_passengers', maintaining policy compliance."
            ],
            "violation_examples": [
              "While updating a reservation, the agent attempts to change the number of passengers, such as adding an extra passenger or reducing it, without transferring the request to a human agent for assistance, thereby violating the policy.",
              "An agent handles a reservation update request to modify passenger numbers, such as from 3 to 6 or 6 to 8, without initiating a transfer to a human agent, which is required by the Transfer Requirement for Human Assistance policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_passengers",
      "guard_file": {
        "file_name": "airline/update_reservation_passengers/guard_update_reservation_passengers.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\n\n\ndef guard_update_reservation_passengers(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n         \n    \"\"\"\n    \n    guard_ensure_user_confirmation(history, api, reservation_id, passengers)\n    guard_validate_passenger_number_consistency(history, api, reservation_id, passengers)\n    guard_transfer_requirement_for_human_assistance(history, api, reservation_id, passengers)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_passengers/guard_ensure_user_confirmation.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_ensure_user_confirmation(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Retrieve reservation details\n    reservation_details = api.get_reservation_details(reservation_id)\n    \n    # Check if the user has confirmed the changes\n    confirmation_question = f\"Did the user confirm the changes to the passenger information for reservation {reservation_id}?\"\n    user_confirmed = history.ask_bool(confirmation_question)\n    \n    if not user_confirmed:\n        raise PolicyViolationException(\"User did not provide explicit 'yes' confirmation for updating passenger information.\")"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_validate_passenger_number_consistency.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_validate_passenger_number_consistency(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same. You can change details like name or date of birth, but the total number must not be altered. This rule is critical and an exception cannot be made, even by human agents.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Fetch the current reservation details using the API\n    reservation_details = api.get_reservation_details(reservation_id)\n    \n    # Check if the number of passengers in the reservation matches the number of passengers provided\n    if len(reservation_details.passengers) != len(passengers):\n        raise PolicyViolationException(\"The number of passengers cannot be changed.\")"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_transfer_requirement_for_human_assistance.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_transfer_requirement_for_human_assistance(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    try:\n        # Get the current reservation details\n        reservation = api.get_reservation_details(reservation_id)\n        \n        # Check if the number of passengers has changed\n        if len(passengers) != len(reservation.passengers):\n            raise PolicyViolationException(\"Passenger count change detected. Transfer to human agent required.\")\n        \n        # Attempt to update reservation passengers\n        api.update_reservation_passengers(reservation_id, passengers)\n    except ValueError as e:\n        # If update fails due to passenger count mismatch, transfer to human agent\n        if \"number of passengers does not match\" in str(e):\n            raise PolicyViolationException(\"Passenger count change detected. Transfer to human agent required.\")\n        else:\n            raise e"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_passengers/test_guard_ensure_user_confirmation.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.i_airline import *\nfrom airline.airline_types import *\n\nclass TestGuardEnsureUserConfirmation:\n    \n    def test_compliance_email_confirmation(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True  # Mock that 'yes' is the answer to the confirmation question\n\n        # Mock other tools function return values\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[], payment_history=[], created_at=\"2023-10-01T12:00:00\", total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        user = User(user_id=\"user123\", name=Name(first_name=\"John\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"Anytown\", country=\"USA\", state=\"CA\", zip=\"12345\"), email=\"john.doe@example.com\", dob=\"1990-01-01\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[\"ZFA04Y\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user123\" else None\n        \n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")]\n\n        # Invoke function under test.\n        guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n\n    def test_violation_no_confirmation(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = False  # Mock that 'no' is the answer to the confirmation question\n\n        # Mock other tools function return values\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[], payment_history=[], created_at=\"2023-10-01T12:00:00\", total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        user = User(user_id=\"user123\", name=Name(first_name=\"John\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"Anytown\", country=\"USA\", state=\"CA\", zip=\"12345\"), email=\"john.doe@example.com\", dob=\"1990-01-01\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[\"ZFA04Y\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user123\" else None\n        \n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")]\n\n        # Invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_validate_passenger_number_consistency.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.i_airline import *\nfrom airline.airline_types import *\n\nclass TestGuardValidatePassengerNumberConsistency:\n\n    def test_update_passenger_details_maintain_count(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API and its return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\")\n            ],\n            payment_history=[],\n            created_at=\"2023-10-01T12:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        guard_validate_passenger_number_consistency(\n            history=history,\n            api=api,\n            reservation_id=\"ZFA04Y\",\n            passengers=[\n                Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\")\n            ]\n        )\n\n    def test_violate_passenger_number_by_removal(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API and its return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\")\n            ],\n            payment_history=[],\n            created_at=\"2023-10-01T12:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[\n                    Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                    Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")\n                ]\n            )\n\n    def test_violate_passenger_number_by_addition(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API and its return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\")\n            ],\n            payment_history=[],\n            created_at=\"2023-10-01T12:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[\n                    Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                    Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                    Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\"),\n                    Passenger(first_name=\"Jack\", last_name=\"Daniels\", dob=\"1980-04-04\")\n                ]\n            )\n\n    def test_violate_passenger_number_by_excess(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"User requests an update on reservation 'ZFA04Y' by submitting a list of 5 passengers, while the original reservation only contained 4.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API and its return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\"),\n                Passenger(first_name=\"Jack\", last_name=\"Daniels\", dob=\"1980-04-04\")\n            ],\n            payment_history=[],\n            created_at=\"2023-10-01T12:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                passengers=[\n                    Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n                    Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\"),\n                    Passenger(first_name=\"Jim\", last_name=\"Beam\", dob=\"1985-03-03\"),\n                    Passenger(first_name=\"Jack\", last_name=\"Daniels\", dob=\"1980-04-04\"),\n                    Passenger(first_name=\"Johnny\", last_name=\"Walker\", dob=\"1975-05-05\")\n                ]\n            )\n"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_transfer_requirement_for_human_assistance.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardTransferRequirementForHumanAssistance:\n\n    def test_update_passenger_information_compliance(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool.\"\n        Example: \"A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged, and the agent successfully uses 'update_reservation_passengers', complying with the tool's capabilities and policy requirements.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        api.get_reservation_details.return_value = reservation\n\n        # Invoke function under test\n        guard_transfer_requirement_for_human_assistance(history, api, \"ZFA04Y\", [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")])\n\n    def test_change_passenger_count_violation(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool.\"\n        Example: \"While updating a reservation, the agent attempts to change the number of passengers, such as adding an extra passenger or reducing it, without transferring the request to a human agent for assistance, thereby violating the policy.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        api.get_reservation_details.return_value = reservation\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_transfer_requirement_for_human_assistance(history, api, \"ZFA04Y\", [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"), Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")])\n\n    def test_modify_passenger_numbers_violation(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool.\"\n        Example: \"An agent handles a reservation update request to modify passenger numbers, such as from 3 to 6 or 6 to 8, without initiating a transfer to a human agent, which is required by the Transfer Requirement for Human Assistance policy.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"user123\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[], passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"), Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        api.get_reservation_details.return_value = reservation\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_transfer_requirement_for_human_assistance(history, api, \"ZFA04Y\", [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")])\n"
        }
      ]
    },
    "update_reservation_baggages": {
      "tool": {
        "tool_name": "update_reservation_baggages",
        "policy_items": [
          {
            "name": "Explicit Confirmation for Baggage Update",
            "description": "Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "A user asks to update reservation 'ZFA04Y' baggages. The system lists changes: increasing total baggages from 2 to 3, nonfree from 0 to 2, using payment method 'certificate_7815826'. User explicitly confirms 'yes' and the operation proceeds.",
              "Before updating the reservation 'XJ43MS', the agent presents a summary of requested changes: altering total baggages to 5 and nonfree baggages to 3. The user confirms with a 'yes', allowing the update to take place using 'gift_card_987654'.",
              "User intends to change baggage data for reservation 'LMN456'. All update details are neatly listed: decrementing total baggages to 1, charging nonfree baggages as 1 via 'credit_card_394820'. After receiving a clear 'yes' from the user, the tool proceeds.",
              "To update baggage details for reservation ID 'FGH789', system meticulously lists: changing total to 3 baggages, nonfree are zero, paid by 'certificate_112233'. Awaiting explicit confirmation 'yes' from the agent before proceeding ensures rule compliance."
            ],
            "violation_examples": [
              "A user provides a reservation ID 'ZFA04Y' to update baggage details without explicitly confirming the changes. The system proceeds to update the total baggages to 3 and nonfree baggages to 1 using the payment method 'credit_card_7815826' without asking for explicit confirmation.",
              "An agent wishes to update the baggage count by reducing total baggages from 5 to 3 using reservation ID 'T125HG' and payment method 'gift_card_123456', but does not list the changes beforehand or seek affirmation from the user.",
              "User requests to change reservation 'XJ43MS' baggage details and the agent immediately proceeds with modifying nonfree baggages to 2, without listing these adjustments or waiting for a user to say 'yes' for confirmation.",
              "The reservation update tool is utilized to change baggage information on reservation 'ABCD123' from a total of 2 baggages to 4 without outlining all changes and obtaining user approval."
            ]
          },
          {
            "name": "Baggage Addition Policy",
            "description": "When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.",
            "references": [
              "Change baggage and insurance: The user can add but not remove checked bags.",
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. Each extra baggage is 50 dollars.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "Increasing checked bags from 2 to 4 on reservation 'ZFA04Y': A gold member in business class adds 2 additional nonfree bags using a stored credit card, correctly applying fees according to policy.",
              "For reservation 'ZFA04Y', updating with a silver member traveling in economy by adding 2 checked bags, correctly adjusting total_baggages to 4 and nonfree_baggages to 2, using a stored gift card for payment as per policy.",
              "Updating reservation 'ZFA04Y' with a regular member in economy class, adding 1 nonfree bag, correctly setting total_baggages to 2 and nonfree_baggages to 1, using a stored payment method, adhering to the free checked bag allowance.",
              "Adding 2 checked bags to existing reservation 'ZFA04Y' for a silver member in business class: Ensuring total_baggages is 4 and nonfree_baggages is 1 due to the free allocation rule, with fees charged to a stored certificate according to policy.",
              "A regular member in business class updates reservation 'ZFA04Y' by adding 2 nonfree bags, ensuring total_baggages is 4 and nonfree_baggages is 2 based on their allowance, processing payment via an existing credit card according to policy.",
              "For reservation 'ZFA04Y', a regular member in business class correctly updates total_baggages to 5 and nonfree_baggages to 3, using a stored payment method and adhering to the policy for recognizing free bags.",
              "A gold member in business class updates reservation 'ZFA04Y' to include 5 total checked bags, correctly increasing nonfree_baggages to 2 with stored gift card payment, adhering to policy requirements.",
              "A silver member in basic economy adds 2 checked bags to reservation 'ZFA04Y', updating total_baggages to 3 and nonfree_baggages to 2, considering 1 free checked bag according to the policy, with fees covered using a stored payment method."
            ],
            "violation_examples": [
              "Updating reservation with ID 'ZFA04Y' to reduce the total checked bags from 3 to 2, violating the policy that prevents removing checked bags.",
              "Attempting to use a new payment method not stored in user profile for baggage fees when updating reservation 'ZFA04Y', violating the policy requiring existing payment methods.",
              "Setting total_baggages to 4 but nonfree_baggages to 1 for a regular member in basic economy, violating the policy as regular members get 0 free checked bags in basic economy, so nonfree_baggages should match total_baggages.",
              "For a silver member in business class, updating the baggage on reservation 'ZFA04Y' with total_baggages set to 5 checked bags but incorrectly setting nonfree_baggages to 1. The policy grants 3 free checked bags; thus, 2 should be non-free.",
              "Adding 3 checked bags to reservation 'ZFA04Y' without calculating and applying a fee for each additional nonfree bag, violating the baggage policy.",
              "Updating reservation ID 'ZFA04Y' by setting total_baggages to 6 while nonfree_baggages are only set to 2 for a gold member in economy class, violating the policy as a gold member in economy has 3 free checked bags, meaning nonfree_baggages should be 3.",
              "A regular member in economy class updates reservation 'ZFA04Y' by setting total_baggages to 3 and nonfree_baggages to 1, violating the policy because regular members in economy receive 1 free bag and thus nonfree_baggages should be 2.",
              "An attempt to update reservation 'ZFA04Y' using a payment method labeled as 'debit_card_123456', not stored in the user's profile, violating the policy requirement for existing payment methods.",
              "For reservation 'ZFA04Y', a gold member in basic economy attempts to set total_baggages at 3 and nonfree_baggages at 0, violating the policy that requires nonfree_baggages to be 1 as gold members receive 2 free bags."
            ]
          },
          {
            "name": "Payment Method Validation for Baggage Update",
            "description": "Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "A user successfully updates their reservation baggages using a credit card stored in their profile, ensuring secure payment.",
              "The reservation baggages are updated using gift cards stored within the user's profile, complying with the gift card limit.",
              "A stored travel certificate from the user's profile is utilized to update non-free baggages, aligning with policy requirements.",
              "Updating the baggage information using a combination of payment methods from the user's profile, adhering to policy limits."
            ],
            "violation_examples": [
              "A user attempts to update their reservation baggages using a certificate or credit card that is not stored in their profile, which leads to transaction insecurity.",
              "A user tries to update their reservation baggages using multiple gift cards, exceeding the allowed limit and thus violating payment method constraints.",
              "A user attempts to use a combination of certificates for paying the baggage update, exceeding the allowed limit per reservation."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_baggages",
      "guard_file": {
        "file_name": "airline/update_reservation_baggages/guard_update_reservation_baggages.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_baggages.guard_explicit_confirmation_for_baggage_update import guard_explicit_confirmation_for_baggage_update\nfrom airline.update_reservation_baggages.guard_baggage_addition_policy import guard_baggage_addition_policy\nfrom airline.update_reservation_baggages.guard_payment_method_validation_for_baggage_update import guard_payment_method_validation_for_baggage_update\n\n\ndef guard_update_reservation_baggages(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_explicit_confirmation_for_baggage_update(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_baggage_addition_policy(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_payment_method_validation_for_baggage_update(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_baggages/guard_explicit_confirmation_for_baggage_update.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_confirmation_for_baggage_update(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Retrieve current reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    \n    # List all changes\n    changes = f\"Updating reservation '{reservation_id}' baggages: \"\n    changes += f\"Total baggages from {reservation.total_baggages} to {total_baggages}, \"\n    changes += f\"Non-free baggages from {reservation.nonfree_baggages} to {nonfree_baggages}, \"\n    changes += f\"using payment method '{payment_id}'.\"\n    \n    # Ask for explicit user confirmation\n    confirmation_question = f\"Do you confirm the following changes? {changes}\"\n    user_confirmed = history.ask_bool(confirmation_question)\n    \n    if not user_confirmed:\n        raise PolicyViolationException(\"Explicit user confirmation not received for baggage update.\")"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_baggage_addition_policy.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_baggage_addition_policy(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_payment_method_validation_for_baggage_update.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_validation_for_baggage_update(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_baggages/test_guard_explicit_confirmation_for_baggage_update.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_baggages.guard_explicit_confirmation_for_baggage_update import guard_explicit_confirmation_for_baggage_update\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardExplicitConfirmationForBaggageUpdate:\n\n    def test_compliance_example_user_confirms_yes(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"A user asks to update reservation 'ZFA04Y' baggages. The system lists changes: increasing total baggages from 2 to 3, nonfree from 0 to 2, using payment method 'certificate_7815826'. User explicitly confirms 'yes' and the operation proceeds.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True  # Mock that user confirms 'yes'\n\n        # Mock the API tool function return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        guard_explicit_confirmation_for_baggage_update(\n            history=history,\n            api=api,\n            reservation_id=\"ZFA04Y\",\n            total_baggages=3,\n            nonfree_baggages=2,\n            payment_id=\"certificate_7815826\"\n        )\n\n    def test_violation_example_no_explicit_confirmation(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"A user provides a reservation ID 'ZFA04Y' to update baggage details without explicitly confirming the changes. The system proceeds to update the total baggages to 3 and nonfree baggages to 1 using the payment method 'credit_card_7815826' without asking for explicit confirmation.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = False  # Mock that user does not confirm 'yes'\n\n        # Mock the API tool function return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test and expect PolicyViolationException\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_confirmation_for_baggage_update(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                total_baggages=3,\n                nonfree_baggages=1,\n                payment_id=\"credit_card_7815826\"\n            )\n"
        },
        null,
        null
      ]
    },
    "update_reservation_flights": {
      "tool": {
        "tool_name": "update_reservation_flights",
        "policy_items": [
          {
            "name": "Explicit User Confirmation Required",
            "description": "Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "The agent presents the updated flight itinerary, cabin class changes, and passenger adjustments in detail and waits for the user to reply 'yes' before proceeding, ensuring compliance with the required user confirmation.",
              "User interaction history reveals explicit verbal confirmation ('yes') after presenting action details via email, allowing the update_reservation_flights tool to proceed in accordance with policy.",
              "Before confirming flight changes, the system shows a summary detailing new flight segments and asks, 'Do you confirm?' The user responds with 'yes', thereby validating the action and meeting the explicit consent requirement.",
              "Flight changes are sent to the user's registered email address with clear action details, and the system waits until the user replies 'yes' before executing any update, ensuring compliance with the policy.",
              "A detailed list of updates, including flight, baggage, and cabin class changes, is shown to the user during a live chat, and the agent proceeds only after a clear 'yes' from the user, validating adherence to the explicit confirmation policy."
            ],
            "violation_examples": [
              "An agent updates the flight details of a reservation without asking the user for confirmation, proceeding with changes based on assumed preferences, which violates the requirement for explicit user consent.",
              "The system automatically applies updates to the reservation based on recent user activity without presenting details or receiving explicit confirmation, failing to adhere to the explicit confirmation policy.",
              "Updates to the cabin class and passenger information are executed without the user explicitly saying 'yes', after merely highlighting them, leading to non-compliance with the explicit consent requirement.",
              "A reservation update is initiated after receiving implicit consent from phrases like 'okay' or 'sounds good', rather than a clear 'yes', which does not meet the policy's explicit confirmation standard.",
              "The system pre-fills all updates regarding flights and baggage but does not prompt the user for confirmation before finalizing, violating the policy's demand for explicit consent."
            ]
          },
          {
            "name": "Cannot Modify Basic Economy Flights",
            "description": "Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified.</p>",
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type.</p>"
            ],
            "compliance_examples": [
              "An agent successfully updates a 'business' reservation by changing the flight times, keeping the same origin 'SFO' and destination 'JFK' without altering the trip type from 'round_trip', ensuring compliance with the policy.",
              "A user with a 'business' class reservation updates the cabin class and flight numbers, ensuring the original origin and destination IATA codes 'ORD' and 'LAX' remain unchanged, thus complying with reservation policies.",
              "A user successfully modifies their 'economy' reservation by adding a special meal preference, while preserving all other flight details including origin and trip type, adhering to policy guidelines.",
              "An agent updates a 'business' class reservation, adding another layover in the flight segments but maintaining the original itinerary's origin 'ATL', destination 'HNL', and 'round_trip' type, in line with the policy.",
              "An agent processes an update for an economy reservation by adding extra baggage allowance, ensuring the flight itinerary remains intact with the original destination 'BOS' and trip type 'round_trip', fulfilling the policy requirements.",
              "A user successfully modifies an economy reservation by adding a preferred seating option, while ensuring the origin, destination, and trip type 'one_way' remain unchanged, complying with the policy."
            ],
            "violation_examples": [
              "A user attempts to change a reservation with basic economy flights by providing a new itinerary with updated origin and destination details, violating the restriction on modifying basic economy flights.",
              "An agent tries to update a basic economy flight reservation by changing the cabin class from 'basic_economy' to 'economy', which violates the policy against altering basic economy reservations.",
              "A user requests modifying a reservation classified as basic economy by supplying an edited flight array containing different departure times, going against the policy of non-modification for basic economy.",
              "A user tries to adjust the basic economy flight itinerary by requesting a new connecting flight option instead of their direct flight, contravening the reservation policy.",
              "An agent attempts to update a reservation classified as 'economy' by changing the trip type from 'round_trip' to 'one_way', which violates the policy of maintaining trip type for non-basic reservations.",
              "A user submits a request to change the flights in a business class reservation by altering the destination from 'SFO' to 'NYC', breaking the rule against changing destinations in non-basic reservations."
            ]
          },
          {
            "name": "Cabin Change Payment Requirement",
            "description": "ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user changes the entire reservation's cabin class from economy to business, ensuring all flight segments are included in the updated reservation request and provides payment details to cover the fare difference, fully complying with the policy.",
              "A user updates all flight segments of their reservation from basic economy to economy class, ensuring the cabin class is uniformly changed across the entire reservation and pays the required fare difference, adhering to policy requirements.",
              "The user modifies their reservation to change all flight segments from economy to first class and provides necessary payment methods to cover the new cabin class fare difference, ensuring full compliance.",
              "A user updates all flight segments from first class to business class, providing their credit card details that have sufficient funds to cover the fare reduction difference for all segments in their reservation.",
              "A user requests a cabin change for their reservation, ensuring all flight segments are updated from premium economy to economy class and provides a payment method with a sufficient balance to cover the reduced fare difference, meeting policy standards."
            ],
            "violation_examples": [
              "A user attempts to change only one segment of their reservation from economy to business class without updating the cabin class for the entire reservation, violating the required uniform cabin change.",
              "A user updates their reservation to have mixed cabin classes, changing one flight to economy and another to business class within the same reservation, which breaks the policy mandating uniform cabin class across all flights.",
              "A user changes their entire reservation from basic economy to business class but only provides payment that covers the difference for a single flight segment, not fulfilling the policy requirement for covering the fare difference for the entire reservation.",
              "A user attempts to change their reservation's cabin class from economy to premium economy for all flights but incorrectly inputs payment that covers a partial fare difference, resulting in insufficient payment for the full reservation change.",
              "A user tries to change the cabin class for certain flight segments without updating all flights in the reservation, resulting in an inconsistent cabin class within the reservation.",
              "A user tries to change the entire reservation to business class but their payment method is actually a gift card with a balance insufficient to cover the necessary fare difference, violating payment requirement policies.",
              "A user updates their reservation's cabin class across multiple flights but improperly inputs payment details, leading to a request that lacks coverage for every part of the cabin fare change."
            ]
          },
          {
            "name": "Cabin Uniformity Requirement",
            "description": "Cabin class must be the same across all flights in a reservation.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user updates a reservation so all flights are reassigned to economy class, ensuring uniform cabin class and complying with the policy.",
              "The reservation is modified to have all flights in business class, maintaining a consistent cabin class across the entire reservation as per the policy.",
              "Both flight segments in a round-trip reservation are changed to the same cabin class, such as economy, meeting the Cabin Uniformity Requirement."
            ],
            "violation_examples": [
              "A reservation is updated with mixed cabin classes, such as economy and business, across different flights within the same reservation. This violates the policy requiring uniform cabin class.",
              "A user changes one flight to economy and another to basic economy within a reservation, failing the Cabin Uniformity Requirement that mandates the same cabin class for all flights."
            ]
          },
          {
            "name": "Payment Method Requirement for Flight Changes",
            "description": "Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.",
            "references": [
              "<p>Payment: If the flights are changed, the user needs to provide one gift card or credit card for payment or refund method. The agent should ask for the payment or refund method instead.</p>"
            ],
            "compliance_examples": [
              "The user requests a flight change and provides a valid credit card from their profile, satisfying the policy requirement for payment method.",
              "Flight changes are applied after the user selects a valid gift card from their profile for payment, in line with the policy.",
              "Users update their flight details and use a valid credit card linked to their profile for payment, fully complying with the policy guidelines."
            ],
            "violation_examples": [
              "A user attempts to change flights in a reservation without providing any valid payment information such as a gift card or credit card linked to their profile, which contravenes the policy.",
              "A flight update process begins with the user providing only a certificate as payment, despite the requirement for a gift card or credit card.",
              "Whilst trying to modify their flight itinerary, the user neglects to choose any valid payment method from their profile, which violates the mandatory payment method requirement.",
              "A user insists on using a payment method not linked to their profile, such as a friend's credit card, defying the policy's requirement for payment methods to be from the user's profile."
            ]
          },
          {
            "name": "Flight Modification API Limitation Check",
            "description": "Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.",
            "references": [
              "Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!"
            ],
            "compliance_examples": [
              "An agent updates a reservation by changing the flight times while preserving the original cabin class, origin, destination, and trip type, complying with the policy requirements.",
              "Update reservation flights with the same 'origin' and 'destination', ensuring no changes in basic structure, and manually verify segment prices, complying with the policy.",
              "The agent modifies a reservation by adding additional flight segments while original flight details, including trip type and destination, remain unchanged, adhering to the policy.",
              "Keeping the flight segments unchanged and manually verifying that the prices remain the same while modifying flights in a business cabin reservation complies with the policy.",
              "The agent updates a reservation to change seat preference while ensuring the origin, destination, and trip type are consistent with the initial booking, meeting policy criteria."
            ],
            "violation_examples": [
              "An agent attempts to use the Flight Modification API to change the cabin class of a reservation booked under 'basic_economy'. This violates the policy since 'basic_economy' flights are unmodifiable.",
              "The agent changes the origin from 'SFO' to 'LAX' in a reservation update, violating the policy as the origin must remain unchanged.",
              "Changing the destination from 'JFK' to 'BOS' during a reservation update violates the policy because the destination must remain unchanged.",
              "An agent updates a flight reservation from a 'round_trip' to a 'one_way' trip, violating the policy since the trip type cannot be altered.",
              "An agent uses the API to modify a flight reservation without manually verifying the prices of retained flight segments, violating the policy that requires agents to confirm original rates manually."
            ]
          },
          {
            "name": "Consistency Across Flight Segments",
            "description": "When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!</p>"
            ],
            "compliance_examples": [
              "A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.",
              "When modifying an itinerary, the agent ensures the flights array contains every flight segment from the original reservation, even those that were not changed, complying fully with the policy.",
              "A reservation update for altering the cabin class is processed correctly with all segments kept in the flights array to maintain consistency as per policy rules."
            ],
            "violation_examples": [
              "A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.",
              "An agent updates the reservation for a flight change but mistakenly excludes connecting segments that were part of the same trip, leading to an incomplete submission.",
              "During a reservation update involving a cabin class upgrade, the flights array only lists flights under the new cabin class, excluding previously booked ancillary services segments, violating the policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_flights",
      "guard_file": {
        "file_name": "airline/update_reservation_flights/guard_update_reservation_flights.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_flights.guard_explicit_user_confirmation_required import guard_explicit_user_confirmation_required\nfrom airline.update_reservation_flights.guard_cannot_modify_basic_economy_flights import guard_cannot_modify_basic_economy_flights\nfrom airline.update_reservation_flights.guard_cabin_change_payment_requirement import guard_cabin_change_payment_requirement\nfrom airline.update_reservation_flights.guard_cabin_uniformity_requirement import guard_cabin_uniformity_requirement\nfrom airline.update_reservation_flights.guard_payment_method_requirement_for_flight_changes import guard_payment_method_requirement_for_flight_changes\nfrom airline.update_reservation_flights.guard_flight_modification_api_limitation_check import guard_flight_modification_api_limitation_check\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\n\n\ndef guard_update_reservation_flights(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_explicit_user_confirmation_required(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cannot_modify_basic_economy_flights(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_change_payment_requirement(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_uniformity_requirement(history, api, reservation_id, cabin, flights, payment_id)\n    guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n    guard_flight_modification_api_limitation_check(history, api, reservation_id, cabin, flights, payment_id)\n    guard_consistency_across_flight_segments(history, api, reservation_id, cabin, flights, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_flights/guard_explicit_user_confirmation_required.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_user_confirmation_required(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Check if explicit user confirmation was received\n    user_confirmed = history.ask_bool(\"Did the user explicitly confirm the reservation updates with a 'yes'?\")\n    if not user_confirmed:\n        raise PolicyViolationException(\"Explicit user confirmation is required before proceeding with reservation updates.\")"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cannot_modify_basic_economy_flights.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cannot_modify_basic_economy_flights(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_change_payment_requirement.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_change_payment_requirement(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_uniformity_requirement.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_uniformity_requirement(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Cabin class must be the same across all flights in a reservation.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_payment_method_requirement_for_flight_changes.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_requirement_for_flight_changes(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_flight_modification_api_limitation_check.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_modification_api_limitation_check(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_consistency_across_flight_segments.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_consistency_across_flight_segments(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Retrieve the current reservation details\n    reservation_details = api.get_reservation_details(reservation_id)\n    \n    # Extract flight numbers from the current reservation\n    current_flight_numbers = {flight.flight_number for flight in reservation_details.flights}\n    \n    # Extract flight numbers from the provided flights\n    provided_flight_numbers = {flight['flight_number'] if isinstance(flight, dict) else flight.flight_number for flight in flights}\n    \n    # Check if all current flight segments are included in the provided flights\n    if not current_flight_numbers.issubset(provided_flight_numbers):\n        raise PolicyViolationException(\"All flight segments must be included in the list of flights provided.\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_flights/test_guard_explicit_user_confirmation_required.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_explicit_user_confirmation_required import guard_explicit_user_confirmation_required\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardExplicitUserConfirmationRequired:\n\n    def test_compliance_user_confirmation_received(self):\n        \"\"\"\n        Policy: \"Explicit User Confirmation Required\"\n        Example: \"The agent presents the updated flight itinerary, cabin class changes, and passenger adjustments in detail and waits for the user to reply 'yes' before proceeding, ensuring compliance with the required user confirmation.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True  # Mock that user confirmed with 'yes'\n\n        # Mock other tools function return values\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"sara_doe_496\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-05-01\", price=300)], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"gold\", reservations=[\"ZFA04Y\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        # Invoke function under test.\n        guard_explicit_user_confirmation_required(history, api, reservation_id=\"ZFA04Y\", cabin=\"economy\", flights=[{\"flight_number\": \"HAT001\", \"date\": \"2024-05-01\"}], payment_id=\"credit_card_7815826\")\n\n    def test_violation_no_user_confirmation(self):\n        \"\"\"\n        Policy: \"Explicit User Confirmation Required\"\n        Example: \"An agent updates the flight details of a reservation without asking the user for confirmation, proceeding with changes based on assumed preferences, which violates the requirement for explicit user consent.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = False  # Mock that user did not confirm with 'yes'\n\n        # Mock other tools function return values\n        reservation = Reservation(reservation_id=\"ZFA04Y\", user_id=\"sara_doe_496\", origin=\"SFO\", destination=\"JFK\", flight_type=\"round_trip\", cabin=\"economy\", flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-05-01\", price=300)], passengers=[], payment_history=[], created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"), total_baggages=2, nonfree_baggages=1, insurance=\"yes\", status=None)\n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"gold\", reservations=[\"ZFA04Y\"])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        # Invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(history, api, reservation_id=\"ZFA04Y\", cabin=\"economy\", flights=[{\"flight_number\": \"HAT001\", \"date\": \"2024-05-01\"}], payment_id=\"credit_card_7815826\")"
        },
        {
          "file_name": "tests/update_reservation_flights/test_guard_cannot_modify_basic_economy_flights.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_cannot_modify_basic_economy_flights import guard_cannot_modify_basic_economy_flights\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardCannotModifyBasicEconomyFlights:\n\n    def test_modify_basic_economy_flight(self):\n        \"\"\"\n        Policy: \"Basic economy flights in a reservation cannot be modified at all.\"\n        Example: \"A user attempts to change a reservation with basic economy flights by providing a new itinerary with updated origin and destination details, violating the restriction on modifying basic economy flights.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API tool function return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test.\n        with pytest.raises(PolicyViolationException):\n            guard_cannot_modify_basic_economy_flights(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                cabin=\"basic_economy\",\n                flights=[{\"flight_number\": \"HAT002\", \"date\": \"2024-05-02\", \"origin\": \"SFO\", \"destination\": \"JFK\"}],\n                payment_id=\"credit_card_7815826\"\n            )\n\n    def test_modify_business_reservation_compliance(self):\n        \"\"\"\n        Policy: \"Modifications are allowed for non-basic economy reservations but must not change the origin, destination, or trip type.\"\n        Example: \"An agent successfully updates a 'business' reservation by changing the flight times, keeping the same origin 'SFO' and destination 'JFK' without altering the trip type from 'round_trip', ensuring compliance with the policy.\"\n        \"\"\"\n        \n        # Mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API tool function return values\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\")],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test.\n        try:\n            guard_cannot_modify_basic_economy_flights(\n                history=history,\n                api=api,\n                reservation_id=\"ZFA04Y\",\n                cabin=\"business\",\n                flights=[{\"flight_number\": \"HAT001\", \"date\": \"2024-05-01\", \"origin\": \"SFO\", \"destination\": \"JFK\"}],\n                payment_id=\"credit_card_7815826\"\n            )\n        except PolicyViolationException:\n            pytest.fail(\"Business reservation modification failed unexpectedly.\")\n\n    # Additional tests for other compliance and violation examples can be added similarly.\n"
        },
        null,
        null,
        null,
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_consistency_across_flight_segments.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardConsistencyAcrossFlightSegments:\n\n    def test_successful_update_with_all_flights_included(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\"),\n                ReservationFlight(flight_number=\"HAT002\", date=\"2024-05-08\", price=300, origin=\"JFK\", destination=\"SFO\")\n            ],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=600)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        flights = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\"),\n            FlightInfo(flight_number=\"HAT002\", date=\"2024-05-08\")\n        ]\n        guard_consistency_across_flight_segments(history, api, \"ZFA04Y\", \"economy\", flights, \"credit_card_7815826\")\n\n    def test_update_with_missing_flight_segments(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT001\", date=\"2024-05-01\", price=300, origin=\"SFO\", destination=\"JFK\"),\n                ReservationFlight(flight_number=\"HAT002\", date=\"2024-05-08\", price=300, origin=\"JFK\", destination=\"SFO\")\n            ],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=600)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n        # Invoke function under test\n        flights = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(history, api, \"ZFA04Y\", \"economy\", flights, \"credit_card_7815826\")\n"
        }
      ]
    }
  }
}