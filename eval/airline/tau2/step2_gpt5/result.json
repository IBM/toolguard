{
  "domain": {
    "app_name": "airline",
    "toolguard_common": {
      "file_name": "rt_toolguard/data_types.py",
      "content": "from abc import ABC, abstractmethod\nimport os\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import Any, List, Optional\n\nDEBUG_DIR = \"debug\"\nTESTS_DIR = \"tests\"\nRESULTS_FILENAME = \"result.json\"\nAPI_PARAM = \"api\"\n\nclass FileTwin(BaseModel):\n    file_name: str\n    content: str\n\n    def save(self, folder:str)->'FileTwin':\n        full_path = os.path.join(folder, self.file_name)\n        parent = Path(full_path).parent\n        os.makedirs(parent, exist_ok=True)\n        with open(full_path, \"w\") as file:\n            file.write(self.content)\n        return self\n\n    def save_as(self, folder:str, file_name:str)->'FileTwin':\n        file_path = os.path.join(folder, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(self.content)\n        return FileTwin(file_name=file_name, content=self.content)\n\n    @staticmethod\n    def load_from(folder:str, file_path:str)->'FileTwin':\n        with open(os.path.join(folder, file_path), \"r\") as file:\n            data = file.read()\n            return FileTwin(\n                file_name=file_path, \n                content=data\n            )\n\nclass ToolPolicyItem(BaseModel):\n    name: str = Field(..., description=\"Policy item name\")\n    description: str = Field(..., description=\"Policy item description\")\n    references: List[str] = Field(..., description=\"original texts\")\n    compliance_examples: Optional[List[str]] = Field(..., description=\"Example of cases that comply with the policy\")\n    violation_examples: Optional[List[str]] = Field(..., description=\"Example of cases that violate the policy\")\n\n    def to_md_bulltets(self, items: List[str])->str:\n        s = \"\"\n        for item in items:\n            s+=f\"* {item}\\n\"\n        return s\n    \n    def __str__(self) -> str:\n        s = f\"#### Policy item \" + self.name + \"\\n\"\n        s += f\"{self.description}\\n\"\n        if self.compliance_examples:\n            s += f\"##### Positive examples\\n{self.to_md_bulltets(self.compliance_examples)}\"\n        if self.violation_examples:\n            s += f\"##### Negative examples\\n{self.to_md_bulltets(self.violation_examples)}\"\n        return s\n\nclass ToolPolicy(BaseModel):\n    tool_name: str = Field(..., description=\"Name of the tool\")\n    policy_items: List[ToolPolicyItem] = Field(..., description=\"Policy items. All (And logic) policy items must hold whehn invoking the tool.\")\n\nclass Domain(BaseModel):\n    app_name: str = Field(..., description=\"Application name\")\n    toolguard_common: FileTwin = Field(..., description=\"Pydantic data types used by toolguard framework.\")\n    app_types: FileTwin = Field(..., description=\"Data types defined used in the application API as payloads.\")\n    app_api_class_name: str = Field(..., description=\"Name of the API class name.\")\n    app_api: FileTwin = Field(..., description=\"Python class (abstract) containing all the API signatures.\")\n    app_api_size: int = Field(..., description=\"Number of functions in the API\")\n\nclass RuntimeDomain(Domain):\n    app_api_impl_class_name: str = Field(..., description=\"Python class (implementaton) class name.\")\n    app_api_impl: FileTwin = Field(..., description=\"Python class containing all the API method implementations.\")\n\nclass PolicyViolationException(Exception):\n    _msg: str\n    def __init__(self, message:str):\n        super().__init__(message)\n        self._msg = message\n\n    @property\n    def message(self):\n        return self._msg\n"
    },
    "app_types": {
      "file_name": "airline/airline_types.py",
      "content": "# Auto-generated type definitions\nfrom datetime import date, datetime\nfrom enum import Enum\nfrom typing import *\nfrom pydantic import BaseModel, Field\nfrom dataclasses import dataclass\n\nclass FlightDataStatusFlying(BaseModel):\n    status: Literal['flying']  # Indicates flight is in flight\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass PaymentMethodBase(BaseModel):\n    source: str  # Type of payment method\n    id: str  # Unique identifier for the payment method\n\nclass Payment(BaseModel):\n    payment_id: str  # Unique identifier for the payment\n    amount: int  # Payment amount in dollars\n\nclass Passenger(BaseModel):\n    first_name: str  # Passenger's first name\n    last_name: str  # Passenger's last name\n    dob: str  # Date of birth in YYYY-MM-DD format\n\nclass FlightDataStatusOnTime(BaseModel):\n    status: Literal['on time']  # Indicates flight is on time\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusCancelled(BaseModel):\n    status: Literal['cancelled']  # Indicates flight was cancelled\n\nclass FlightDateStatusDelayed(BaseModel):\n    status: Literal['delayed']  # Indicates flight was delayed\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass Address(BaseModel):\n    address1: str  # Primary address line\n    address2: Optional[str]  # Secondary address line (optional)\n    city: str  # City name\n    country: str  # Country name\n    state: str  # State or province name\n    zip: str  # Postal code\n\nclass AirportCode(BaseModel):\n    iata: str  # IATA code\n    city: str  # City name\n\nclass FlightDateStatusLanded(BaseModel):\n    status: Literal['landed']  # Indicates flight has landed\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    actual_arrival_time_est: str  # Actual arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass Name(BaseModel):\n    first_name: str  # The person's first name\n    last_name: str  # The person's last name\n\nclass FlightInfo(BaseModel):\n    flight_number: str  # Flight number, such as 'HAT001'.\n    date: str  # The date for the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\nclass FlightDateStatusAvailable(BaseModel):\n    status: Literal['available']  # Indicates flight is available for booking\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass FlightBase(BaseModel):\n    flight_number: str  # Unique flight identifier\n    origin: str  # IATA code for origin airport\n    destination: str  # IATA code for destination airport\n\nclass GiftCard(PaymentMethodBase):\n    source: Literal['gift_card']  # Indicates this is a gift card payment method\n    amount: float  # Gift card value amount\n    id: str  # Unique identifier for the gift card\n\nclass CreditCard(PaymentMethodBase):\n    source: Literal['credit_card']  # Indicates this is a credit card payment method\n    brand: str  # Credit card brand (e.g., visa, mastercard)\n    last_four: str  # Last four digits of the credit card\n\nclass Certificate(PaymentMethodBase):\n    source: Literal['certificate']  # Indicates this is a certificate payment method\n    amount: float  # Certificate value amount\n\nclass Flight(FlightBase):\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    dates: dict[str, Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]]  # Flight status by date (YYYY-MM-DD)\n\nclass DirectFlight(FlightBase):\n    status: Literal['available']  # Indicates flight is available for booking\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    date: Optional[str]  # Flight date in YYYY-MM-DD format\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass ReservationFlight(FlightBase):\n    date: str  # Flight date in YYYY-MM-DD format\n    price: int  # Flight price in dollars.\n\nclass User(BaseModel):\n    user_id: str  # Unique identifier for the user\n    name: Name  # User's full name\n    address: Address  # User's address information\n    email: str  # User's email address\n    dob: str  # User's date of birth in the format YYYY-MM-DD, e.g 1990-04-05\n    payment_methods: dict[str, Union[CreditCard, GiftCard, Certificate]]  # User's saved payment methods\n    saved_passengers: list[Passenger]  # User's saved passenger information\n    membership: Literal['gold', 'silver', 'regular']  # User's membership level\n    reservations: list[str]  # List of user's reservation IDs\n\nclass Reservation(BaseModel):\n    reservation_id: str  # Unique identifier for the reservation\n    user_id: str  # ID of the user who made the reservation\n    origin: str  # IATA code for trip origin\n    destination: str  # IATA code for trip destination\n    flight_type: Literal['round_trip', 'one_way']  # Type of trip\n    cabin: Literal['business', 'economy', 'basic_economy']  # Selected cabin class\n    flights: list[ReservationFlight]  # List of flights in the reservation\n    passengers: list[Passenger]  # List of passengers on the reservation\n    payment_history: list[Payment]  # History of payments for this reservation\n    created_at: str  # Timestamp when reservation was created in the format YYYY-MM-DDTHH:MM:SS\n    total_baggages: int  # Total number of bags in reservation\n    nonfree_baggages: int  # Number of paid bags in reservation\n    insurance: Literal['yes', 'no']  # Whether travel insurance was purchased\n    status: Optional[Literal['cancelled']]  # Status of the reservation\n"
    },
    "app_api_class_name": "I_Airline",
    "app_api": {
      "file_name": "airline/i_airline.py",
      "content": "# Auto-generated class interface\nfrom typing import * # type: ignore\nfrom abc import ABC, abstractmethod\nfrom airline.airline_types import *\n\nclass I_Airline(ABC):\n\n    @abstractmethod\n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n\n        Args:\n            user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n            origin: The IATA code for the origin city such as 'SFO'.\n            destination: The IATA code for the destination city such as 'JFK'.\n            flight_type: The type of flight such as 'one_way' or 'round_trip'.\n            cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n            flights: An array of objects containing details about each piece of flight.\n            passengers: An array of objects containing details about each passenger.\n            payment_methods: An array of objects containing details about each payment method.\n            total_baggages: The total number of baggage items to book the reservation.\n            nonfree_baggages: The number of non-free baggage items to book the reservation.\n            insurance: Whether the reservation has insurance.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n\n        Args:\n            expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n\n        Returns:\n            The result of the mathematical expression.\n\n        Raises:\n            ValueError: If the expression is invalid.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n\n        Args:\n            flight_number: The flight number.\n            date: The date of the flight.\n\n        Returns:\n            The flight.\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n\n        Args:\n            flight_number: The flight number.\n            date: The date of the flight.\n\n        Returns:\n            The status of the flight.\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as '8JX2WO'.\n\n        Returns:\n            The reservation details.\n\n        Raises:\n            ValueError: If the reservation is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n\n        Args:\n            flight_number: The flight number.\n\n        Returns:\n            The flight schedule\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n\n        Args:\n            user_id: The user ID, such as 'sara_doe_496'.\n\n        Returns:\n            The user details.\n\n        Raises:\n            ValueError: If the user is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\nReturns a list of all available airports.\n\n        Returns:\n            A dictionary mapping IATA codes to AirportInfo objects.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n\n        Args:\n            origin: The origin city airport in three letters, such as 'JFK'.\n            destination: The destination city airport in three letters, such as 'LAX'.\n            date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n\n        Returns:\n            The direct flights between the two cities on the specific date.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n\n        Args:\n            origin: The origin city airport in three letters, such as 'JFK'.\n            destination: The destination city airport in three letters, such as 'LAX'.\n            date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\n        Returns:\n            A list of pairs of DirectFlight objects.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n\n        Args:\n            user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n            amount: The amount of the certificate to send.\n\n        Returns:\n            A message indicating the certificate was sent.\n\n        Raises:\n            ValueError: If the user is not found.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n         -  the user explicitly asks for a human agent\n         -  given the policy and the available tools, you cannot solve the user's issue.\n\n        Args:\n            summary: A summary of the user's issue.\n\n        Returns:\n            A message indicating the user has been transferred to a human agent.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'\n            total_baggages: The updated total number of baggage items included in the reservation.\n            nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n            payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the user is not found.\n            ValueError: If the payment method is not found.\n            ValueError: If the certificate cannot be used to update reservation.\n            ValueError: If the gift card balance is not enough.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n            cabin: The cabin class of the reservation\n            flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n            payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the user is not found.\n            ValueError: If the payment method is not found.\n            ValueError: If the certificate cannot be used to update reservation.\n            ValueError: If the gift card balance is not enough.\n        \n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n            passengers: An array of objects containing details about each passenger.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the number of passengers does not match.\n        \n        \"\"\"\n        ...\n"
    },
    "app_api_size": 16,
    "app_api_impl_class_name": "Airlineimpl",
    "app_api_impl": {
      "file_name": "airline/airline_impl.py",
      "content": "# Auto-generated class\nfrom typing import *\nfrom abc import ABC, abstractmethod\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass ToolInvoker(ABC):\n    @abstractmethod\n    def invoke(self, toolname: str, arguments: Dict[str, Any])->object:\n        ...\n\nclass Airlineimpl(I_Airline):\n\n    def __init__(self, delegate: ToolInvoker):\n        self._delegate = delegate\n    \n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n\n        Args:\n            user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n            origin: The IATA code for the origin city such as 'SFO'.\n            destination: The IATA code for the destination city such as 'JFK'.\n            flight_type: The type of flight such as 'one_way' or 'round_trip'.\n            cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n            flights: An array of objects containing details about each piece of flight.\n            passengers: An array of objects containing details about each passenger.\n            payment_methods: An array of objects containing details about each payment method.\n            total_baggages: The total number of baggage items to book the reservation.\n            nonfree_baggages: The number of non-free baggage items to book the reservation.\n            insurance: Whether the reservation has insurance.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('book_reservation', args)\n\n\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n\n        Args:\n            expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n\n        Returns:\n            The result of the mathematical expression.\n\n        Raises:\n            ValueError: If the expression is invalid.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('calculate', args)\n\n\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('cancel_reservation', args)\n\n\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n\n        Args:\n            flight_number: The flight number.\n            date: The date of the flight.\n\n        Returns:\n            The flight.\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('get_flight_instance', args)\n\n\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n\n        Args:\n            flight_number: The flight number.\n            date: The date of the flight.\n\n        Returns:\n            The status of the flight.\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('get_flight_status', args)\n\n\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as '8JX2WO'.\n\n        Returns:\n            The reservation details.\n\n        Raises:\n            ValueError: If the reservation is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('get_reservation_details', args)\n\n\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n\n        Args:\n            flight_number: The flight number.\n\n        Returns:\n            The flight schedule\n\n        Raises:\n            ValueError: If the flight is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('get_scheduled_flight', args)\n\n\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n\n        Args:\n            user_id: The user ID, such as 'sara_doe_496'.\n\n        Returns:\n            The user details.\n\n        Raises:\n            ValueError: If the user is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('get_user_details', args)\n\n\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\nReturns a list of all available airports.\n\n        Returns:\n            A dictionary mapping IATA codes to AirportInfo objects.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('list_all_airports', args)\n\n\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n\n        Args:\n            origin: The origin city airport in three letters, such as 'JFK'.\n            destination: The destination city airport in three letters, such as 'LAX'.\n            date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n\n        Returns:\n            The direct flights between the two cities on the specific date.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('search_direct_flight', args)\n\n\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n\n        Args:\n            origin: The origin city airport in three letters, such as 'JFK'.\n            destination: The destination city airport in three letters, such as 'LAX'.\n            date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\n        Returns:\n            A list of pairs of DirectFlight objects.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('search_onestop_flight', args)\n\n\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n\n        Args:\n            user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n            amount: The amount of the certificate to send.\n\n        Returns:\n            A message indicating the certificate was sent.\n\n        Raises:\n            ValueError: If the user is not found.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('send_certificate', args)\n\n\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n         -  the user explicitly asks for a human agent\n         -  given the policy and the available tools, you cannot solve the user's issue.\n\n        Args:\n            summary: A summary of the user's issue.\n\n        Returns:\n            A message indicating the user has been transferred to a human agent.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('transfer_to_human_agents', args)\n\n\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'\n            total_baggages: The updated total number of baggage items included in the reservation.\n            nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n            payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the user is not found.\n            ValueError: If the payment method is not found.\n            ValueError: If the certificate cannot be used to update reservation.\n            ValueError: If the gift card balance is not enough.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('update_reservation_baggages', args)\n\n\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n            cabin: The cabin class of the reservation\n            flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n            payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the user is not found.\n            ValueError: If the payment method is not found.\n            ValueError: If the certificate cannot be used to update reservation.\n            ValueError: If the gift card balance is not enough.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('update_reservation_flights', args)\n\n\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n\n        Args:\n            reservation_id: The reservation ID, such as 'ZFA04Y'.\n            passengers: An array of objects containing details about each passenger.\n\n        Returns:\n            The updated reservation.\n\n        Raises:\n            ValueError: If the reservation is not found.\n            ValueError: If the number of passengers does not match.\n        \n        \"\"\"\n\n        args = locals().copy()\n        args.pop(\"self\", None)\n        return self._delegate.invoke('update_reservation_passengers', args)\n\n"
    }
  },
  "tools": {
    "book_reservation": {
      "tool": {
        "tool_name": "book_reservation",
        "policy_items": [
          {
            "name": "User Confirmation Before Database Update",
            "description": "Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before finalizing a new reservation for Emily, including flight details, passenger names, and baggage information, the system displays all changes to Emily and obtains her explicit 'yes' confirmation to proceed with the booking.",
              "Jane wants to change her seat to economy class and add an additional baggage item to her reservation. The system provides a detailed summary of these changes and asks Jane to confirm with a 'yes' before proceeding.",
              "While updating passenger details and flight preference for Michael's trip, the system presents all updates to him clearly and requests a 'yes' confirmation to ensure understanding and agreement before making any database changes.",
              "George received a notice about his frequent flyer miles being used for an upgrade to business class; the system displays the upgrade details and asks George for an explicit 'yes' confirmation before applying the change.",
              "Anna reviews the summary of her amended flight itinerary and cabin upgrade. The system awaits her verbal confirmation of 'yes' before making any updates to her reservation in the database.",
              "Before executing a booking for Tom's round-trip flight and adding travel insurance, the system presents all reservation details and secures a 'yes' confirmation from Tom before proceeding.",
              "Lisa wants to adjust her travel itinerary by changing the flight type to one-way and removing insurance coverage. The system displays these proposed updates and requires Lisa to confirm with a 'yes' before finalizing the changes.",
              "During the reservation process for Kevin's flight, which includes preferences for basic economy cabin and payment method adjustments, the system details all intended changes and obtains Kevin's affirmative 'yes' to proceed."
            ],
            "violation_examples": [
              "The system attempts to book a reservation and update the flight details without displaying them to the user first. John does not get the chance to review or confirm these changes before they are applied. It proceeds without obtaining an affirmative 'yes' from John.",
              "The system updates the number of non-free baggage items directly based on the user's preferences without explicitly asking for a 'yes' confirmation. This violates the policy by not requesting confirmation before making database changes.",
              "After Sarah requests an upgrade to business class for her flight reservation, the system processes the upgrade without sending her a summary of the changes and obtaining her confirmation. This fails to meet the user confirmation requirement.",
              "Tom modifies passenger information for his upcoming flight, yet the system saves these updates without showing Tom the new passenger details and without an affirmative 'yes' from him. This action violates user confirmation policy.",
              "The computer applies changes to Mark's reservation for round-trip flights and edits to baggage allowance based on a prior conversation but fails to explicitly ask for confirmation from Mark before updating the database. This contradicts the policy's confirmation mandate.",
              "Rachel wants to book a flight from LAX to JFK with a cabin upgrade, but the system updates her reservation without displaying changes and fails to obtain explicit 'yes' confirmation. This violates policy requirements on user confirmation.",
              "The system processes a reservation update for David's flight details after he selects new departure times but does not display these changes or ask for David's approval before applying them. Lacking explicit confirmation is a violation.",
              "After Nancy requests additional baggage and a change in passenger details, the system performs these updates without listing them for her and without requesting a 'yes' confirmation. This breaches the user confirmation policy."
            ]
          },
          {
            "name": "Flight Passenger Limit for Booking",
            "description": "A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.",
            "references": [
              "Passengers: Each reservation can have at most five passengers. The agent needs to collect the first name, last name, and date of birth for each passenger. All passengers must fly the same flights in the same cabin."
            ],
            "compliance_examples": [
              "Booking for three passengers: John Doe, Jane Smith, and Alex Murphy, all flying economy class from JFK to SFO with identical flight segments, fits the maximum passenger limit and same flight itinerary requirement.",
              "A reservation for five passengers, all flying from SFO to JFK in basic economy, with collected details including first name, last name, and date of birth for each passenger, adheres to the policy's constraints.",
              "Booking for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown from JFK to LAX in business class, all having the exact flight itinerary and cabin. This meets the policy requirements for passenger limits and identical flight itineraries.",
              "Two passengers, John Doe and Jane Smith, fly together on a round_trip from SFO to MIA in economy class, maintaining identical flight itineraries and cabin, complying with the policy.",
              "One reservation for four passengers all flying from SFO to JFK in basic economy class, with first name, last name, and date of birth collected for each. The reservation complies with passenger limits and identical flight requirements."
            ],
            "violation_examples": [
              "A reservation is attempted for six passengers: John Doe, Jane Smith, Alex Murphy, Ella Brown, Chris Davis, and Emily White, which exceeds the maximum allowed five passengers per reservation.",
              "A reservation is made for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown, with John flying business class and the others flying economy. Cabin classes must be the same for all passengers within a reservation.",
              "Three passengers, John Doe, Jane Smith, and Alex Murphy, have different flight itineraries: John and Jane are flying from JFK to SFO, and Alex is flying from LAX to SFO. All passengers must share the same flight itinerary.",
              "Booking for two passengers, John Doe and Jane Smith, with different flight types: John on a 'one_way' ticket and Jane on a 'round_trip' ticket. Flight types must be identical among passengers in the reservation.",
              "A reservation for five passengers includes one passenger flying only part of the shared flight itinerary. All passengers are required to fly all shared flights together."
            ]
          },
          {
            "name": "Payment Method Limits in Booking",
            "description": "Each reservation can use at most one travel certificate, one credit card, and three gift cards.",
            "references": [
              "<p>Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons.</p>"
            ],
            "compliance_examples": [
              "A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.",
              "Booking a trip with one credit card and one gift card, complying perfectly with the policy by using no travel certificates.",
              "A booking that utilizes one travel certificate and three gift cards but no credit card, fitting within the acceptable boundaries.",
              "A reservation uses exactly one credit card and no other forms of payment, showing compliance with guidelines.",
              "A reservation is booked using one travel certificate, two gift cards, and no credit card. This adheres to the policy's restrictions on payment use by staying within the boundaries for each method."
            ],
            "violation_examples": [
              "A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.",
              "A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.",
              "Attempting to book a flight using one travel certificate and four gift cards, which breaches the limit on gift cards.",
              "A user uses two credit cards, exceeding the number allowed per reservation.",
              "An attempt is made to book a reservation using zero travel certificates, three credit cards, and four gift cards, violating the restriction on both credit card and gift card quantities."
            ]
          },
          {
            "name": "User ID Requirement for Flight Booking",
            "description": "The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.",
            "references": [
              "The agent must first obtain the user id, then ask for the trip type, origin, destination."
            ],
            "compliance_examples": [
              "The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.",
              "User ID is obtained and validated first, followed by inquiries about flight type, cabin class, and insurance coverage, maintaining the correct sequence as per policy.",
              "Upon confirming the user's ID, such as 'sara_doe_496', the agent systematically handles inquiries about flight specifics, ensuring compliance through verification of user ID first."
            ],
            "violation_examples": [
              "The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.",
              "Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.",
              "The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy."
            ]
          },
          {
            "name": "Prohibition on Modifying User's Passenger Count",
            "description": "The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.",
            "references": [
              "<p>The",
              "user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "An agent updates passengers' details such as name spelling, date of birth, or contact information without changing the established number of passengers in the reservation.",
              "Agent makes changes to existing passenger preferences like seat, dietary needs, or passport details while keeping the passenger count unchanged, demonstrating compliance with the policy.",
              "The agent modifies information such as language preference or special assistance needs for existing reservation passengers, maintaining the originally specified number of passengers."
            ],
            "violation_examples": [
              "An agent attempts to alter the number of passengers in a reservation by changing the count, such as from 2 to 3, violating the policy of immutability on passenger count.",
              "The reservation system allows an agent to add or remove passengers, such as reducing the passenger count established from 5 to 4, thereby violating the no-alteration policy.",
              "Without user consent, the agent modifies the passenger count from the initially scheduled 3 passengers to 2, which goes against the policy of maintaining a fixed passenger count."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_book_reservation",
      "guard_file": {
        "file_name": "airline/book_reservation/guard_book_reservation.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.book_reservation.guard_user_confirmation_before_database_update import guard_user_confirmation_before_database_update\nfrom airline.book_reservation.guard_flight_passenger_limit_for_booking import guard_flight_passenger_limit_for_booking\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.book_reservation.guard_prohibition_on_modifying_user_s_passenger_count import guard_prohibition_on_modifying_user_s_passenger_count\n\n\ndef guard_book_reservation(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance. \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_user_confirmation_before_database_update(api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_flight_passenger_limit_for_booking(api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_payment_method_limits_in_booking(api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_user_id_requirement_for_flight_booking(api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_prohibition_on_modifying_user_s_passenger_count(api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/book_reservation/guard_user_confirmation_before_database_update.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_confirmation_before_database_update(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_flight_passenger_limit_for_booking.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_passenger_limit_for_booking(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_payment_method_limits_in_booking.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_limits_in_booking(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Count occurrences of each payment method type\n    certificate_count = 0\n    credit_card_count = 0\n    gift_card_count = 0\n\n    for pm in payment_methods:\n        # Payment may be a dict or Payment object; ensure we can access 'source'\n        if isinstance(pm, dict):\n            source = pm.get('source')\n        else:\n            source = getattr(pm, 'source', None)\n\n        if source == 'certificate':\n            certificate_count += 1\n        elif source == 'credit_card':\n            credit_card_count += 1\n        elif source == 'gift_card':\n            gift_card_count += 1\n\n    # Validate against policy limits\n    if certificate_count > 1:\n        raise PolicyViolationException(\"More than one travel certificate is not allowed per reservation.\")\n    if credit_card_count > 1:\n        raise PolicyViolationException(\"More than one credit card is not allowed per reservation.\")\n    if gift_card_count > 3:\n        raise PolicyViolationException(\"More than three gift cards are not allowed per reservation.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_user_id_requirement_for_flight_booking.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_id_requirement_for_flight_booking(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Validate that user_id is provided and not empty before proceeding with booking details.\n    if not user_id or not isinstance(user_id, str) or not user_id.strip():\n        raise PolicyViolationException(\n            \"User ID must be obtained before proceeding with flight booking and related inquiries.\"\n        )"
        },
        {
          "file_name": "airline/book_reservation/guard_prohibition_on_modifying_user_s_passenger_count.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_prohibition_on_modifying_user_s_passenger_count(api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        null,
        null,
        {
          "file_name": "tests/book_reservation/test_guard_payment_method_limits_in_booking.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.i_airline import *\nfrom airline.airline_types import *\n\ndef test_compliant_one_cert_one_card_two_gift():\n    \"\"\"\n    Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n    Example: \"A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"City\", country=\"Country\", state=\"State\", zip=\"12345\"),\n        email=\"sara@example.com\",\n        dob=\"1990-01-01\",\n        payment_methods={},\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[]\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-01\")]\n    passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-05-05\")]\n    payment_methods = [\n        Certificate(source=\"certificate\", id=\"cert1\", amount=100.0),\n        CreditCard(source=\"credit_card\", id=\"cc1\", brand=\"visa\", last_four=\"1234\"),\n        GiftCard(source=\"gift_card\", id=\"gc1\", amount=50.0),\n        GiftCard(source=\"gift_card\", id=\"gc2\", amount=30.0)\n    ]\n\n    guard_payment_method_limits_in_booking(api, \"user123\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\ndef test_violation_two_cert_four_gift():\n    \"\"\"\n    Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n    Example: \"A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"City\", country=\"Country\", state=\"State\", zip=\"12345\"),\n        email=\"sara@example.com\",\n        dob=\"1990-01-01\",\n        payment_methods={},\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[]\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-01\")]\n    passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-05-05\")]\n    payment_methods = [\n        Certificate(source=\"certificate\", id=\"cert1\", amount=100.0),\n        Certificate(source=\"certificate\", id=\"cert2\", amount=150.0),\n        GiftCard(source=\"gift_card\", id=\"gc1\", amount=50.0),\n        GiftCard(source=\"gift_card\", id=\"gc2\", amount=30.0),\n        GiftCard(source=\"gift_card\", id=\"gc3\", amount=20.0),\n        GiftCard(source=\"gift_card\", id=\"gc4\", amount=10.0)\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_payment_method_limits_in_booking(api, \"user123\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")\n\ndef test_violation_three_credit_cards():\n    \"\"\"\n    Policy: \"Each reservation can use at most one travel certificate, one credit card, and three gift cards.\"\n    Example: \"A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"City\", country=\"Country\", state=\"State\", zip=\"12345\"),\n        email=\"sara@example.com\",\n        dob=\"1990-01-01\",\n        payment_methods={},\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[]\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-01\")]\n    passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-05-05\")]\n    payment_methods = [\n        CreditCard(source=\"credit_card\", id=\"cc1\", brand=\"visa\", last_four=\"1234\"),\n        CreditCard(source=\"credit_card\", id=\"cc2\", brand=\"mastercard\", last_four=\"5678\"),\n        CreditCard(source=\"credit_card\", id=\"cc3\", brand=\"amex\", last_four=\"9012\")\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_payment_method_limits_in_booking(api, \"user123\", \"SFO\", \"JFK\", \"round_trip\", \"economy\", flights, passengers, payment_methods, 2, 1, \"yes\")"
        },
        {
          "file_name": "tests/book_reservation/test_guard_user_id_requirement_for_flight_booking.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_compliance_user_id_first_then_inquiries():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n    passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n    payments = [Payment(payment_id=\"pay123\", amount=500)]\n\n    try:\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=\"sara_doe_496\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n    except PolicyViolationException:\n        pytest.fail(\"Compliance scenario failed: Expected no PolicyViolationException, but one was raised.\")\n\ndef test_compliance_user_id_validated_first():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"User ID is obtained and validated first, followed by inquiries about flight type, cabin class, and insurance coverage, maintaining the correct sequence as per policy.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT002\", date=\"2024-06-01\")]\n    passengers = [Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1985-05-05\")]\n    payments = [Payment(payment_id=\"pay456\", amount=300)]\n\n    try:\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=\"john_smith_123\",\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n    except PolicyViolationException:\n        pytest.fail(\"Compliance scenario failed: Expected no PolicyViolationException, but one was raised.\")\n\ndef test_compliance_confirm_user_id_then_flight_details():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"Upon confirming the user's ID, such as 'sara_doe_496', the agent systematically handles inquiries about flight specifics, ensuring compliance through verification of user ID first.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT003\", date=\"2024-07-01\")]\n    passengers = [Passenger(first_name=\"Bob\", last_name=\"Brown\", dob=\"1970-12-12\")]\n    payments = [Payment(payment_id=\"pay789\", amount=700)]\n\n    try:\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=\"sara_doe_496\",\n            origin=\"SEA\",\n            destination=\"MIA\",\n            flight_type=\"round_trip\",\n            cabin=\"basic_economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=3,\n            nonfree_baggages=2,\n            insurance=\"yes\"\n        )\n    except PolicyViolationException:\n        pytest.fail(\"Compliance scenario failed: Expected no PolicyViolationException, but one was raised.\")\n\ndef test_violation_booking_without_user_id():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT004\", date=\"2024-08-01\")]\n    passengers = [Passenger(first_name=\"Charlie\", last_name=\"Davis\", dob=\"1995-03-03\")]\n    payments = [Payment(payment_id=\"pay101\", amount=400)]\n\n    with pytest.raises(PolicyViolationException):\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=\"\",\n            origin=\"BOS\",\n            destination=\"ATL\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\ndef test_violation_payment_and_flight_without_user_id():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT005\", date=\"2024-09-01\")]\n    passengers = [Passenger(first_name=\"Dana\", last_name=\"Evans\", dob=\"1988-08-08\")]\n    payments = [Payment(payment_id=\"pay202\", amount=600)]\n\n    with pytest.raises(PolicyViolationException):\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=None,\n            origin=\"DFW\",\n            destination=\"LAS\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\ndef test_violation_insurance_and_baggage_without_user_id():\n    \"\"\"\n    Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n    Example: \"The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    flights = [FlightInfo(flight_number=\"HAT006\", date=\"2024-10-01\")]\n    passengers = [Passenger(first_name=\"Eve\", last_name=\"Foster\", dob=\"1992-11-11\")]\n    payments = [Payment(payment_id=\"pay303\", amount=800)]\n\n    with pytest.raises(PolicyViolationException):\n        guard_user_id_requirement_for_flight_booking(\n            api,\n            user_id=\"   \",\n            origin=\"PHX\",\n            destination=\"DEN\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payments,\n            total_baggages=4,\n            nonfree_baggages=3,\n            insurance=\"no\"\n        )"
        },
        null
      ]
    },
    "cancel_reservation": {
      "tool": {
        "tool_name": "cancel_reservation",
        "policy_items": [
          {
            "name": "Strict Cancellation Rules Enforcement",
            "description": "The policy requires ensuring compliance with the cancellation rules before using 'cancel_reservation'. Agents must check if reservations meet these conditions: cancelled by the airline, within 24 hours of booking, or if travel insurance applies due to health or weather. Partial cancellations are prohibited. Transfer to human agents if these rules cannot facilitate cancellation.",
            "references": [
              "All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled.",
              "The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!",
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.",
              "An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.",
              "The agent ensures a business flight reservation is entirely unused and then cancels it, complying with policy stipulations.",
              "An agent confirms health-related travel insurance applies to a reservation due to illness and proceeds to cancel, following policy guidelines.",
              "The agent checks and confirms all conditions are met for whole reservation cancellation since no flights have been used.",
              "An agent validates that a scheduled flight has been cancelled due to inclement weather and proceeds in line with policy requirements.",
              "The agent carefully checks the booking timestamp and confirms it is within the 24-hour cut-off before executing cancellation.",
              "The agent verifies that none of the reservation segments have been flown and checks travel insurance details before proceeding, ensuring adherence."
            ],
            "violation_examples": [
              "An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.",
              "An agent cancels a reservation for a basic economy flight without verifying if travel insurance applies due to health or weather conditions.",
              "The agent proceeds to cancel part of a reservation even when some segments have already been flown, which breaches the rule against partial cancellations.",
              "An agent attempts to cancel a reservation without validating reservation status, leading to cancellation of flown flight segments.",
              "An agent mistakenly cancels a reservation, ignoring policy specifics that business flights require insurance validation post 24 hours.",
              "An agent cancels a reservation based solely on the passenger's request without verifying if airline or insurance cancellation conditions apply."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_cancel_reservation",
      "guard_file": {
        "file_name": "airline/cancel_reservation/guard_cancel_reservation.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\n\n\ndef guard_cancel_reservation(api: I_Airline, reservation_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_strict_cancellation_rules_enforcement(api, reservation_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/cancel_reservation/guard_strict_cancellation_rules_enforcement.py",
          "content": "from typing import *\nfrom datetime import datetime, timedelta\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_strict_cancellation_rules_enforcement(api: I_Airline, reservation_id: str):\n    \"\"\"\n    Enforces strict cancellation rules before allowing 'cancel_reservation'.\n    Conditions for cancellation:\n      - Reservation cancelled by the airline.\n      - Within 24 hours of booking.\n      - Travel insurance applies due to health or weather.\n      - Business flights can always be cancelled if unused.\n    Partial cancellations are prohibited.\n    \"\"\"\n    # Get reservation details\n    reservation = api.get_reservation_details(reservation_id)\n\n    # Check if reservation already cancelled\n    if reservation.status == 'cancelled':\n        raise PolicyViolationException(\"Reservation is already cancelled.\")\n\n    # Ensure no flight segments have been flown\n    for flight in reservation.flights:\n        flight_status = api.get_flight_instance(flight.flight_number, flight.date)\n        if getattr(flight_status, 'status', None) in ['landed', 'flying']:\n            raise PolicyViolationException(\"Partial cancellations are prohibited; some segments already flown.\")\n\n    # Check if any flight was cancelled by the airline\n    airline_cancelled = any(getattr(api.get_flight_instance(f.flight_number, f.date), 'status', None) == 'cancelled' for f in reservation.flights)\n\n    # Check if within 24 hours of booking\n    booking_time = datetime.strptime(reservation.created_at, \"%Y-%m-%dT%H:%M:%S\")\n    within_24_hours = datetime.now() - booking_time <= timedelta(hours=24)\n\n    # Check travel insurance\n    has_insurance = reservation.insurance == 'yes'\n\n    # Determine if cancellation is allowed\n    if airline_cancelled or within_24_hours:\n        return\n    if reservation.cabin == 'business':\n        return\n    if has_insurance:\n        return\n\n    # If none of the conditions met, raise violation\n    raise PolicyViolationException(\"Cancellation not allowed per strict policy rules.\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/cancel_reservation/test_guard_strict_cancellation_rules_enforcement.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\n\ndef test_cancel_within_24_hours():\n    \"\"\" \n    Policy: \"All reservations can be cancelled within 24 hours of booking\"\n    Example: \"An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    created_at = (datetime.now() - timedelta(hours=5)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n    reservation = Reservation(\n        reservation_id=\"ABC123\",\n        user_id=\"user1\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[],\n        payment_history=[],\n        created_at=created_at,\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ABC123\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"business\": 1, \"economy\": 1, \"basic_economy\": 1}, prices={\"business\": 1000, \"economy\": 500, \"basic_economy\": 300})\n\n    guard_strict_cancellation_rules_enforcement(api, reservation_id=\"ABC123\")\n\n\ndef test_cancel_airline_cancelled_flight():\n    \"\"\" \n    Policy: \"All reservations can be cancelled if the airline cancelled the flight\"\n    Example: \"An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    created_at = (datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n    reservation = Reservation(\n        reservation_id=\"DEF456\",\n        user_id=\"user2\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"FL123\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n        passengers=[],\n        payment_history=[],\n        created_at=created_at,\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"DEF456\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusCancelled(status=\"cancelled\") if fn == \"FL123\" else None\n\n    guard_strict_cancellation_rules_enforcement(api, reservation_id=\"DEF456\")\n\n\ndef test_violation_no_policy_check():\n    \"\"\" \n    Policy: Must check airline cancellation or within 24 hours before cancelling\n    Example: \"An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    created_at = (datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n    reservation = Reservation(\n        reservation_id=\"GHI789\",\n        user_id=\"user3\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"FL456\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n        passengers=[],\n        payment_history=[],\n        created_at=created_at,\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"GHI789\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"business\": 1, \"economy\": 1, \"basic_economy\": 1}, prices={\"business\": 1000, \"economy\": 500, \"basic_economy\": 300})\n\n    with pytest.raises(PolicyViolationException):\n        guard_strict_cancellation_rules_enforcement(api, reservation_id=\"GHI789\")"
        }
      ]
    },
    "update_reservation_passengers": {
      "tool": {
        "tool_name": "update_reservation_passengers",
        "policy_items": [
          {
            "name": "Ensure User Confirmation",
            "description": "Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.",
              "The agent calls the user, reads out the proposed updates on passenger details, and hears a verbal 'yes' confirming agreement to proceed.",
              "Prior to modification, the agent sends the updated passenger list via chat and waits for the user to type 'yes', confirming the changes.",
              "During a video call, the agent shares the screen showing the new passenger details and verbally confirms with the user by receiving a 'yes'.",
              "The airline agent displays updated passenger information and receives explicit 'yes' confirmation through the user's account portal.",
              "The agent uses a secure messaging platform to send a PDF summary of updates, and upon receiving a recorded voice message with 'yes', proceeds.",
              "During a conference call, the airline agent explains passenger information changes; upon receiving 'yes' in the chat, updates the database.",
              "Before using ToolX, the agent provides changes as downloadable content, waits for an email reply marked with 'yes', then proceeds with the update.",
              "The agent showcases updates through a mobile app notification, allowing the user to press 'Confirm' with 'yes' before executing the update."
            ],
            "violation_examples": [
              "An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.",
              "Without any prior communication or explicit confirmation, an airline agent updates John Doe's reservation details, assuming agreement."
            ]
          },
          {
            "name": "Validate Passenger Number Consistency",
            "description": "When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same. You can change details like name or date of birth, but the total number must not be altered. This rule is critical and an exception cannot be made, even by human agents.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged, adhering to the passenger number consistency policy.",
              "An update is requested for reservation 'ZFA04Y' to correct spelling errors in passengers' names, ensuring the list retains its original size of 2 passengers, thus complying with the policy.",
              "User modifies passenger ages in the reservation with ID 'ZFA04Y', containing 4 passengers, ensuring no passenger is added or removed, thus correctly validating the number consistency as per the policy requirements."
            ],
            "violation_examples": [
              "A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers, violating the rule that the number of passengers must remain unchanged.",
              "A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers, which incorrectly alters the total count of passengers.",
              "User requests an update on reservation 'ZFA04Y' by submitting a list of 5 passengers, while the original reservation only contained 4, thus conflicting with the passenger count policy."
            ]
          },
          {
            "name": "Transfer Requirement for Human Assistance",
            "description": "Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.",
            "references": [
              "<p>You should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions.</p>",
              "<p>Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged, and the agent successfully uses 'update_reservation_passengers', complying with the tool's capabilities and policy requirements.",
              "An agent receives a request to alter details such as contact or passport information for passengers, ensuring no change in the passenger count, and efficiently addresses it using 'update_reservation_passengers', maintaining policy compliance."
            ],
            "violation_examples": [
              "While updating a reservation, the agent attempts to change the number of passengers, such as adding an extra passenger or reducing it, without transferring the request to a human agent for assistance, thereby violating the policy.",
              "An agent handles a reservation update request to modify passenger numbers, such as from 3 to 6 or 6 to 8, without initiating a transfer to a human agent, which is required by the Transfer Requirement for Human Assistance policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_passengers",
      "guard_file": {
        "file_name": "airline/update_reservation_passengers/guard_update_reservation_passengers.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\n\n\ndef guard_update_reservation_passengers(api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_ensure_user_confirmation(api, reservation_id, passengers)\n    guard_validate_passenger_number_consistency(api, reservation_id, passengers)\n    guard_transfer_requirement_for_human_assistance(api, reservation_id, passengers)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_passengers/guard_ensure_user_confirmation.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_ensure_user_confirmation(api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Before using ToolX to update passenger information in the booking database, \n    an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') \n    from them before proceeding.\n\n    Args:\n        api (I_Airline): API to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Retrieve the current reservation details to compare existing passengers with the new list\n    current_reservation = api.get_reservation_details(reservation_id)\n    current_passengers = current_reservation.passengers\n\n    # If there is any change in passenger details, confirmation is required\n    if current_passengers != passengers:\n        # In a real scenario, confirmation would be obtained from the user.\n        # Here, we simulate the check by requiring a special marker in passengers to indicate confirmation.\n        # For example, the last passenger dict could contain a key '__user_confirmed__': 'yes'.\n        confirmed = False\n        for p in passengers:\n            if isinstance(p, dict) and p.get('__user_confirmed__', '').lower() == 'yes':\n                confirmed = True\n                break\n        if not confirmed:\n            raise PolicyViolationException(\n                \"Explicit user confirmation ('yes') is required before updating passenger information.\"\n            )"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_validate_passenger_number_consistency.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_validate_passenger_number_consistency(api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\n    You can change details like name or date of birth, but the total number must not be altered.\n    This rule is critical and an exception cannot be made, even by human agents.\n\n    Args:\n        api (I_Airline): API to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \n    Raises:\n        PolicyViolationException: If the number of passengers in the update does not match the original reservation.\n    \"\"\"\n    # Retrieve the existing reservation details using the dependent tool\n    existing_reservation = api.get_reservation_details(reservation_id)\n    original_count = len(existing_reservation.passengers)\n    new_count = len(passengers)\n\n    # Validate passenger count consistency\n    if new_count != original_count:\n        raise PolicyViolationException(\n            f\"Passenger count mismatch: original reservation has {original_count} passengers, \"\n            f\"but update request contains {new_count} passengers. The number of passengers must remain the same.\"\n        )"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_transfer_requirement_for_human_assistance.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_transfer_requirement_for_human_assistance(api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Agents are instructed to transfer users to a human agent when passenger modification requests surpass \n    the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications \n    not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved \n    due to passenger number constraints before initiating the transfer.\n\n    Args:\n        api (I_Airline): API to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Retrieve the current reservation details to compare passenger count\n    reservation = api.get_reservation_details(reservation_id)\n    current_passenger_count = len(reservation.passengers)\n    new_passenger_count = len(passengers)\n\n    # If passenger count changes, it surpasses the capabilities of 'update_reservation_passengers'\n    if current_passenger_count != new_passenger_count:\n        raise PolicyViolationException(\n            \"Passenger count change detected. Must transfer to a human agent as per policy requirements.\"\n        )"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_passengers/test_guard_ensure_user_confirmation.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_email_confirmation_before_update():\n    \"\"\" \n    Policy: Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\n    Example: Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.\n    \"\"\"\n    \n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=300)],\n        passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n    passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n    \n    # Should not raise exception for compliance\n    guard_ensure_user_confirmation(api, reservation_id=\"ZFA04Y\", passengers=passengers)\n\ndef test_update_without_user_confirmation():\n    \"\"\" \n    Policy: Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\n    Example: An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.\n    \"\"\"\n    \n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=300)],\n        passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n    passengers = [Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1992-02-02\")]\n    \n    with pytest.raises(PolicyViolationException):\n        guard_ensure_user_confirmation(api, reservation_id=\"ZFA04Y\", passengers=passengers)"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_validate_passenger_number_consistency.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_update_passenger_details_same_count():\n    \"\"\" \n    Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n    Example: \"A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged.\"\n    \"\"\"\n    \n    # mock other tools function return values\n    original_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\")\n    ]\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=original_passengers,\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=2,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    \n    updated_passengers = [\n        Passenger(first_name=\"Johnathan\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\")\n    ]\n    \n    #invoke function under test.\n    guard_validate_passenger_number_consistency(api, reservation_id=\"ZFA04Y\", passengers=updated_passengers)\n\ndef test_reduce_passenger_count_raises():\n    \"\"\" \n    Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n    Example: \"A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers.\"\n    \"\"\"\n    \n    original_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\")\n    ]\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=original_passengers,\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=2,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    \n    updated_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")\n    ]\n    \n    with pytest.raises(PolicyViolationException):\n        guard_validate_passenger_number_consistency(api, reservation_id=\"ZFA04Y\", passengers=updated_passengers)\n\ndef test_increase_passenger_count_raises():\n    \"\"\" \n    Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n    Example: \"A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers.\"\n    \"\"\"\n    \n    original_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\")\n    ]\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=original_passengers,\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=2,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    \n    updated_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\"),\n        Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1995-09-09\")\n    ]\n    \n    with pytest.raises(PolicyViolationException):\n        guard_validate_passenger_number_consistency(api, reservation_id=\"ZFA04Y\", passengers=updated_passengers)\n\ndef test_modify_passenger_ages_same_count():\n    \"\"\" \n    Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n    Example: \"User modifies passenger ages in the reservation with ID 'ZFA04Y', containing 4 passengers, ensuring no passenger is added or removed.\"\n    \"\"\"\n    \n    original_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2000-07-07\"),\n        Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1995-09-09\")\n    ]\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=original_passengers,\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=2,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    \n    updated_passengers = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1991-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1986-05-05\"),\n        Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"2001-07-07\"),\n        Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1996-09-09\")\n    ]\n    \n    guard_validate_passenger_number_consistency(api, reservation_id=\"ZFA04Y\", passengers=updated_passengers)"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_transfer_requirement_for_human_assistance.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_update_passenger_info_no_count_change():\n    \"\"\" \n    Policy: Agents must transfer to a human agent only if passenger modification requests surpass the capabilities of 'update_reservation_passengers'.\n    Example: A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged.\n    \"\"\"\n    \n    # Mock reservation with 2 passengers\n    reservation = Reservation(\n        reservation_id=\"ABC123\",\n        user_id=\"user_1\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1992-02-02\")\n        ],\n        payment_history=[],\n        created_at=\"2024-05-01T10:00:00\",\n        total_baggages=2,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ABC123\" else None\n\n    # Invoke function under test with same passenger count\n    passengers_update = [\n        Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n        Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1992-02-02\")\n    ]\n\n    try:\n        guard_transfer_requirement_for_human_assistance(api, reservation_id=\"ABC123\", passengers=passengers_update)\n    except PolicyViolationException:\n        pytest.fail(\"Function raised PolicyViolationException unexpectedly when passenger count remained unchanged.\")\n\n\ndef test_attempt_change_passenger_count_additional():\n    \"\"\" \n    Policy: Must transfer to human agent if passenger count changes.\n    Example: Agent attempts to change the number of passengers, such as adding an extra passenger.\n    \"\"\"\n    \n    # Mock reservation with 2 passengers\n    reservation = Reservation(\n        reservation_id=\"DEF456\",\n        user_id=\"user_2\",\n        origin=\"LAX\",\n        destination=\"ORD\",\n        flight_type=\"one_way\",\n        cabin=\"business\",\n        flights=[],\n        passengers=[\n            Passenger(first_name=\"Alice\", last_name=\"Wonder\", dob=\"1985-03-03\"),\n            Passenger(first_name=\"Bob\", last_name=\"Builder\", dob=\"1980-04-04\")\n        ],\n        payment_history=[],\n        created_at=\"2024-05-02T11:00:00\",\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"DEF456\" else None\n\n    # Invoke function under test with increased passenger count\n    passengers_update = [\n        Passenger(first_name=\"Alice\", last_name=\"Wonder\", dob=\"1985-03-03\"),\n        Passenger(first_name=\"Bob\", last_name=\"Builder\", dob=\"1980-04-04\"),\n        Passenger(first_name=\"Charlie\", last_name=\"Chaplin\", dob=\"1975-05-05\")\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_transfer_requirement_for_human_assistance(api, reservation_id=\"DEF456\", passengers=passengers_update)\n\n\ndef test_attempt_change_passenger_count_reduction():\n    \"\"\" \n    Policy: Must transfer to human agent if passenger count changes.\n    Example: Agent handles a reservation update request to modify passenger numbers from 3 to 2.\n    \"\"\"\n    \n    # Mock reservation with 3 passengers\n    reservation = Reservation(\n        reservation_id=\"GHI789\",\n        user_id=\"user_3\",\n        origin=\"MIA\",\n        destination=\"SEA\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[\n            Passenger(first_name=\"Tom\", last_name=\"Thumb\", dob=\"1995-06-06\"),\n            Passenger(first_name=\"Jerry\", last_name=\"Mouse\", dob=\"1994-07-07\"),\n            Passenger(first_name=\"Spike\", last_name=\"Bulldog\", dob=\"1993-08-08\")\n        ],\n        payment_history=[],\n        created_at=\"2024-05-03T12:00:00\",\n        total_baggages=3,\n        nonfree_baggages=1,\n        insurance=\"yes\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"GHI789\" else None\n\n    # Invoke function under test with reduced passenger count\n    passengers_update = [\n        Passenger(first_name=\"Tom\", last_name=\"Thumb\", dob=\"1995-06-06\"),\n        Passenger(first_name=\"Jerry\", last_name=\"Mouse\", dob=\"1994-07-07\")\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_transfer_requirement_for_human_assistance(api, reservation_id=\"GHI789\", passengers=passengers_update)"
        }
      ]
    },
    "update_reservation_baggages": {
      "tool": {
        "tool_name": "update_reservation_baggages",
        "policy_items": [
          {
            "name": "Explicit Confirmation for Baggage Update",
            "description": "Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "A user asks to update reservation 'ZFA04Y' baggages. The system lists changes: increasing total baggages from 2 to 3, nonfree from 0 to 2, using payment method 'certificate_7815826'. User explicitly confirms 'yes' and the operation proceeds.",
              "Before updating the reservation 'XJ43MS', the agent presents a summary of requested changes: altering total baggages to 5 and nonfree baggages to 3. The user confirms with a 'yes', allowing the update to take place using 'gift_card_987654'.",
              "User intends to change baggage data for reservation 'LMN456'. All update details are neatly listed: decrementing total baggages to 1, charging nonfree baggages as 1 via 'credit_card_394820'. After receiving a clear 'yes' from the user, the tool proceeds.",
              "To update baggage details for reservation ID 'FGH789', system meticulously lists: changing total to 3 baggages, nonfree are zero, paid by 'certificate_112233'. Awaiting explicit confirmation 'yes' from the agent before proceeding ensures rule compliance."
            ],
            "violation_examples": [
              "A user provides a reservation ID 'ZFA04Y' to update baggage details without explicitly confirming the changes. The system proceeds to update the total baggages to 3 and nonfree baggages to 1 using the payment method 'credit_card_7815826' without asking for explicit confirmation.",
              "An agent wishes to update the baggage count by reducing total baggages from 5 to 3 using reservation ID 'T125HG' and payment method 'gift_card_123456', but does not list the changes beforehand or seek affirmation from the user.",
              "User requests to change reservation 'XJ43MS' baggage details and the agent immediately proceeds with modifying nonfree baggages to 2, without listing these adjustments or waiting for a user to say 'yes' for confirmation.",
              "The reservation update tool is utilized to change baggage information on reservation 'ABCD123' from a total of 2 baggages to 4 without outlining all changes and obtaining user approval."
            ]
          },
          {
            "name": "Baggage Addition Policy",
            "description": "When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.",
            "references": [
              "Change baggage and insurance: The user can add but not remove checked bags.",
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. Each extra baggage is 50 dollars.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "Increasing checked bags from 2 to 4 on reservation 'ZFA04Y': A gold member in business class adds 2 additional nonfree bags using a stored credit card, correctly applying fees according to policy.",
              "For reservation 'ZFA04Y', updating with a silver member traveling in economy by adding 2 checked bags, correctly adjusting total_baggages to 4 and nonfree_baggages to 2, using a stored gift card for payment as per policy.",
              "Updating reservation 'ZFA04Y' with a regular member in economy class, adding 1 nonfree bag, correctly setting total_baggages to 2 and nonfree_baggages to 1, using a stored payment method, adhering to the free checked bag allowance.",
              "Adding 2 checked bags to existing reservation 'ZFA04Y' for a silver member in business class: Ensuring total_baggages is 4 and nonfree_baggages is 1 due to the free allocation rule, with fees charged to a stored certificate according to policy.",
              "A regular member in business class updates reservation 'ZFA04Y' by adding 2 nonfree bags, ensuring total_baggages is 4 and nonfree_baggages is 2 based on their allowance, processing payment via an existing credit card according to policy.",
              "For reservation 'ZFA04Y', a regular member in business class correctly updates total_baggages to 5 and nonfree_baggages to 3, using a stored payment method and adhering to the policy for recognizing free bags.",
              "A gold member in business class updates reservation 'ZFA04Y' to include 5 total checked bags, correctly increasing nonfree_baggages to 2 with stored gift card payment, adhering to policy requirements.",
              "A silver member in basic economy adds 2 checked bags to reservation 'ZFA04Y', updating total_baggages to 3 and nonfree_baggages to 2, considering 1 free checked bag according to the policy, with fees covered using a stored payment method."
            ],
            "violation_examples": [
              "Updating reservation with ID 'ZFA04Y' to reduce the total checked bags from 3 to 2, violating the policy that prevents removing checked bags.",
              "Attempting to use a new payment method not stored in user profile for baggage fees when updating reservation 'ZFA04Y', violating the policy requiring existing payment methods.",
              "Setting total_baggages to 4 but nonfree_baggages to 1 for a regular member in basic economy, violating the policy as regular members get 0 free checked bags in basic economy, so nonfree_baggages should match total_baggages.",
              "For a silver member in business class, updating the baggage on reservation 'ZFA04Y' with total_baggages set to 5 checked bags but incorrectly setting nonfree_baggages to 1. The policy grants 3 free checked bags; thus, 2 should be non-free.",
              "Adding 3 checked bags to reservation 'ZFA04Y' without calculating and applying a fee for each additional nonfree bag, violating the baggage policy.",
              "Updating reservation ID 'ZFA04Y' by setting total_baggages to 6 while nonfree_baggages are only set to 2 for a gold member in economy class, violating the policy as a gold member in economy has 3 free checked bags, meaning nonfree_baggages should be 3.",
              "A regular member in economy class updates reservation 'ZFA04Y' by setting total_baggages to 3 and nonfree_baggages to 1, violating the policy because regular members in economy receive 1 free bag and thus nonfree_baggages should be 2.",
              "An attempt to update reservation 'ZFA04Y' using a payment method labeled as 'debit_card_123456', not stored in the user's profile, violating the policy requirement for existing payment methods.",
              "For reservation 'ZFA04Y', a gold member in basic economy attempts to set total_baggages at 3 and nonfree_baggages at 0, violating the policy that requires nonfree_baggages to be 1 as gold members receive 2 free bags."
            ]
          },
          {
            "name": "Payment Method Validation for Baggage Update",
            "description": "Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "A user successfully updates their reservation baggages using a credit card stored in their profile, ensuring secure payment.",
              "The reservation baggages are updated using gift cards stored within the user's profile, complying with the gift card limit.",
              "A stored travel certificate from the user's profile is utilized to update non-free baggages, aligning with policy requirements.",
              "Updating the baggage information using a combination of payment methods from the user's profile, adhering to policy limits."
            ],
            "violation_examples": [
              "A user attempts to update their reservation baggages using a certificate or credit card that is not stored in their profile, which leads to transaction insecurity.",
              "A user tries to update their reservation baggages using multiple gift cards, exceeding the allowed limit and thus violating payment method constraints.",
              "A user attempts to use a combination of certificates for paying the baggage update, exceeding the allowed limit per reservation."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_baggages",
      "guard_file": {
        "file_name": "airline/update_reservation_baggages/guard_update_reservation_baggages.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_baggages.guard_explicit_confirmation_for_baggage_update import guard_explicit_confirmation_for_baggage_update\nfrom airline.update_reservation_baggages.guard_baggage_addition_policy import guard_baggage_addition_policy\nfrom airline.update_reservation_baggages.guard_payment_method_validation_for_baggage_update import guard_payment_method_validation_for_baggage_update\n\n\ndef guard_update_reservation_baggages(api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_explicit_confirmation_for_baggage_update(api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_baggage_addition_policy(api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_payment_method_validation_for_baggage_update(api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_baggages/guard_explicit_confirmation_for_baggage_update.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_confirmation_for_baggage_update(api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_baggage_addition_policy.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_baggage_addition_policy(api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_payment_method_validation_for_baggage_update.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_validation_for_baggage_update(api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        null,
        null,
        null
      ]
    },
    "send_certificate": {
      "tool": {
        "tool_name": "send_certificate",
        "policy_items": [
          {
            "name": "Compensation for cancelled or delayed flights",
            "description": "Agents can issue compensation certificates using the `send_certificate` tool, but only for users who meet specific eligibility criteria: they must be silver/gold members, have travel insurance, or travel in business class. Compensation amounts are $100 per passenger for cancellations, and $50 per passenger for delays if the reservation is altered as requested by the user. Before sending compensation, the agent must ensure eligibility by verifying the user's membership, whether they have purchased travel insurance, the class they are flying, and the status of the flight.",
            "references": [
              "If the user is silver/gold member or has travel insurance or flies business, and complains about cancelled flights in a reservation, the agent can offer a certificate as a gesture after confirming the facts, with the amount being $100 times the number of passengers.",
              "If the user is silver/gold member or has travel insurance or flies business, and complains about delayed flights in a reservation and wants to change or cancel the reservation, the agent can offer a certificate as a gesture after confirming the facts and changing or cancelling the reservation, with the amount being $50 times the number of passengers.",
              "Do not proactively offer these unless the user complains about the situation and explicitly asks for some compensation. Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy."
            ],
            "compliance_examples": [
              "After a silver member complains about their flight being canceled, the agent verifies membership and sends a certificate of $100 per passenger to the two passengers in the reservation.",
              "The agent checks the user profile and confirms the user is a gold member with travel insurance who has just experienced a flight delay, and has requested a reservation change, thus issuing a certificate of $50 per passenger for the three passengers.",
              "A user, traveling in business class, complains about a flight cancellation. The agent verifies this and issues a $100 certificate per passenger after confirming the cancellation, following the policy's eligibility criteria.",
              "The agent issues a $50 certificate per passenger following a user's complaint about delayed flights and altered reservations. The user is confirmed to have travel insurance, complying with the policy.",
              "For a business class traveler who complained about flight cancellations, the agent sends $100 compensation per passenger after verifying all eligibility conditions and the affectation to the reservation.",
              "After verifying the user's status as a gold member with travel insurance, who has reported a flight delay, the agent confirms the reservation alteration and issues a $50 certificate per passenger, meeting policy requirements.",
              "A complaint from a user traveling in business class triggers the agent to check the flight status and verify eligibility criteria before issuing a $100 certificate for a canceled flight."
            ],
            "violation_examples": [
              "An agent tries to send a $100 compensation certificate for a canceled flight to a regular member who does not have travel insurance and is traveling in basic economy class, violating the eligibility criteria.",
              "An agent issues a compensation certificate of $50 for flight delay without confirming the user is traveling in business class, has travel insurance, or membership status and fails to verify if a reservation change was requested.",
              "A certificate is sent to a user without verifying their eligibility. The user is neither a silver/gold member nor has travel insurance, traveling in economy, and did not complain about the canceled flight, which is a breach of policy requirements.",
              "The agent sends compensation for a delay without ensuring the reservation is altered as per user request and fails to verify the user's membership status, travel insurance, or business class booking.",
              "An agent sends a compensation certificate for a canceled flight without verifications: whether the user is traveling in business class, has travel insurance, or membership status.",
              "A certificate is issued for a delayed flight without confirming if the user had actually complained, requested a reservation change, or met eligibility criteria such as silver/gold membership or insurance holding."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_send_certificate",
      "guard_file": {
        "file_name": "airline/send_certificate/guard_send_certificate.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.send_certificate.guard_compensation_for_cancelled_or_delayed_flights import guard_compensation_for_cancelled_or_delayed_flights\n\n\ndef guard_send_certificate(api: I_Airline, user_id: str, amount: int):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_compensation_for_cancelled_or_delayed_flights(api, user_id, amount)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/send_certificate/guard_compensation_for_cancelled_or_delayed_flights.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_compensation_for_cancelled_or_delayed_flights(api: I_Airline, user_id: str, amount: int):\n    \"\"\"\n    Guard to enforce policy for issuing compensation certificates for cancelled or delayed flights.\n\n    Policy:\n        - Only silver/gold members, or those with travel insurance, or those traveling in business class are eligible.\n        - Compensation amounts:\n            * $100 per passenger for cancellations.\n            * $50 per passenger for delays if the reservation is altered as requested by the user.\n        - Must verify membership, insurance, cabin class, and flight status before issuing.\n        - Do not compensate if the user is a regular member, has no travel insurance, and flies economy/basic economy.\n    \"\"\"\n    # Get user details\n    user = api.get_user_details(user_id)\n\n    # Check eligibility criteria\n    eligible_membership = user.membership in [\"silver\", \"gold\"]\n\n    # Iterate over reservations to find affected flights\n    eligible = False\n    for res_id in user.reservations:\n        reservation = api.get_reservation_details(res_id)\n        has_insurance = reservation.insurance == \"yes\"\n        business_class = reservation.cabin == \"business\"\n\n        # Check if user meets at least one eligibility criterion\n        if not (eligible_membership or has_insurance or business_class):\n            continue\n\n        # Check flight statuses in the reservation\n        for flight in reservation.flights:\n            status = api.get_flight_status(flight.flight_number, flight.date)\n            if status == \"cancelled\":\n                expected_amount = 100 * len(reservation.passengers)\n                if amount != expected_amount:\n                    raise PolicyViolationException(\n                        f\"Invalid amount for cancellation. Expected ${expected_amount}\"\n                    )\n                eligible = True\n            elif status == \"delayed\":\n                expected_amount = 50 * len(reservation.passengers)\n                if amount != expected_amount:\n                    raise PolicyViolationException(\n                        f\"Invalid amount for delay. Expected ${expected_amount}\"\n                    )\n                eligible = True\n\n    if not eligible:\n        raise PolicyViolationException(\n            \"User is not eligible for compensation under the policy.\"\n        )"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/send_certificate/test_guard_compensation_for_cancelled_or_delayed_flights.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.send_certificate.guard_compensation_for_cancelled_or_delayed_flights import guard_compensation_for_cancelled_or_delayed_flights\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestGuardCompensationForCancelledOrDelayedFlights:\n\n    def test_silver_member_cancelled_flight_two_passengers(self):\n        \"\"\" \n        Policy: \"If the user is silver/gold member or has travel insurance or flies business, and complains about cancelled flights in a reservation, the agent can offer a certificate as a gesture after confirming the facts, with the amount being $100 times the number of passengers.\"\n        Example: \"After a silver member complains about their flight being canceled, the agent verifies membership and sends a certificate of $100 per passenger to the two passengers in the reservation.\"\n        \"\"\"\n        user = User(\n            user_id=\"user123\",\n            name=Name(first_name=\"John\", last_name=\"Doe\"),\n            address=Address(address1=\"123 St\", address2=None, city=\"City\", country=\"Country\", state=\"State\", zip=\"12345\"),\n            email=\"john@example.com\",\n            dob=\"1980-01-01\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[\"resv1\"]\n        )\n        reservation = Reservation(\n            reservation_id=\"resv1\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"FL123\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1980-01-01\"), Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1985-05-05\")],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"resv1\" else None\n        api.get_flight_status.side_effect = lambda fn, date: \"cancelled\" if fn == \"FL123\" and date == \"2024-06-01\" else \"on time\"\n\n        guard_compensation_for_cancelled_or_delayed_flights(api, user_id=\"user123\", amount=200)\n\n    def test_regular_member_no_insurance_basic_economy(self):\n        \"\"\" \n        Policy: \"Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy.\"\n        Example: \"An agent tries to send a $100 compensation certificate for a canceled flight to a regular member who does not have travel insurance and is traveling in basic economy class, violating the eligibility criteria.\"\n        \"\"\"\n        user = User(\n            user_id=\"user456\",\n            name=Name(first_name=\"Alice\", last_name=\"Smith\"),\n            address=Address(address1=\"456 St\", address2=None, city=\"City\", country=\"Country\", state=\"State\", zip=\"67890\"),\n            email=\"alice@example.com\",\n            dob=\"1990-02-02\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[\"resv2\"]\n        )\n        reservation = Reservation(\n            reservation_id=\"resv2\",\n            user_id=\"user456\",\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"FL456\", origin=\"LAX\", destination=\"ORD\", date=\"2024-06-02\", price=300)],\n            passengers=[Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-02-02\")],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == \"user456\" else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"resv2\" else None\n        api.get_flight_status.side_effect = lambda fn, date: \"cancelled\" if fn == \"FL456\" and date == \"2024-06-02\" else \"on time\"\n\n        with pytest.raises(PolicyViolationException):\n            guard_compensation_for_cancelled_or_delayed_flights(api, user_id=\"user456\", amount=100)"
        }
      ]
    },
    "transfer_to_human_agents": {
      "tool": {
        "tool_name": "transfer_to_human_agents",
        "policy_items": [
          {
            "name": "Transfer to Human Agent Conditions",
            "description": "Transfer a user to a human agent only if the user explicitly requests this transfer or if the problem cannot be resolved using available tools and policies within the scope of your actions. Include a summary of the user's issue when making the transfer.",
            "references": [
              "You should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions."
            ],
            "compliance_examples": [
              "A user asks for details about their reservation ID '8JX2WO'. Without attempting to retrieve the reservation details using `get_reservation_details`, the tool transfers the user to a human agent with the summary: 'User requests reservation details'. This violates the policy as the issue can be resolved with the available tool.",
              "The user wanted to update their reservation with ID 'ZFA04Y' to reflect a change in flight dates. Instead of using `update_reservation_flights`, the tool transfers the user to a human agent with the summary: 'User requests flight date change'. The policy is violated as the available tools can handle the request.",
              "A user asks for a human agent but is looking to calculate a simple mathematical expression '3 * 8 + (5 - 1)' that can be resolved using the `calculate` tool. The tool transfers the user without checking that the issue can be resolved internally, violating the policy requirement.",
              "The tool transfers a user asking for airport listings to a human agent with the summary 'User requests list of airports'. This violates the policy as the tool `list_all_airports` can be used to solve the issue.",
              "A user is transferred to a human agent upon asking for the status of a flight number 'AA123' on a specific date '2024-01-01', without attempting to use `get_flight_status`. This violates the policy as the available tool can resolve the issue."
            ],
            "violation_examples": [
              "A user explicitly requests to be transferred to a human agent stating: 'I need to speak with a real person about my bill.'. The tool complies by transferring the user with the summary: 'User requests assistance with billing directly from an agent'.",
              "A user has an issue with their reservation and explicitly states: 'Please transfer me to a human agent'. The tool transfers the user with the summary 'User requests transfer to human agent for reservation issue,' complying with their express request.",
              "The user requests information on a flight destination that is not covered by the available tools as it includes airports outside the supported database. Given that no tool can resolve this, the tool transfers the user with the summary 'User seeks flight info for unsupported airports', adhering to policy.",
              "A user requests to use a gift card to update reservation baggage information, but the gift card balance is insufficient and no payment method is available to handle the transaction. The tool correctly transfers the user with the summary 'Insufficient gift card balance for baggage update'.",
              "The user asks for a direct flight search between two destinations on a date that no flight data is available. After confirming that using `search_direct_flight` does not yield results and no other tools can aid, the transfer is made with the summary 'No direct flights found on requested date', complying with the policy criteria.",
              "A user is looking for help on something that cannot be resolved by any tool available, like getting guidance on flight cancellation due to severe health issues. The user says 'Can I talk to a human agent about cancelling due to health reasons?' The tool complies and transfers the user to a human agent with the summary 'User requests human assistance for cancellation due to severe health issues'.",
              "The user is trying to book a type of flight that involves special travel arrangement not supported by the existing tools. After confirming that none of the tools can fulfill the request, the transfer is made with the summary 'User requests special travel arrangements not supported by tools', ensuring compliance with the policy.",
              "A user experiences a critical app error that support tools cannot address and requests: 'I need to speak with a human agent to fix this issue.' The tool appropriately transfers the user to a human agent with the summary 'User faces critical app error and requests agent assistance', following the policy.",
              "A user requests information about changes in company policy that are not covered within the available tools. After verifying that the issue cannot be resolved internally, the user is transferred with the summary 'User inquires about policy changes not within tool support', adhering to the policy.",
              "The user reports a highly complex query that involves multiple reservations and payments, explicitly stating: 'I'd like detailed assistance from a human agent on my reservations and payments.' The transfer is made with the summary 'User requests detailed human assistance on reservations and payments', ensuring compliance with the policy.",
              "A user expresses a desire to be transferred directly to a human agent, stating: 'I insist on speaking with a human agent about the delay of my flight.' The tool complies with this explicit request by transferring the user with the summary 'User requests direct discussion on flight delay with a human agent', ensuring adherence to the policy.",
              "A user requires assistance for complex travel arrangements that involve a combination of factors not supported by the current tools, expressly mentioning: 'I need expert help from a person to sort out my itinerary changes.' After verifying that no solution is available through the existing tools, the transfer is made with the summary 'User requests expert assistance due to unsupported itinerary changes', providing compliance with the policy.",
              "A user needs specialized assistance due to their unique travel requirements involving government directives, and requests: 'Transfer me to someone who can discuss these government travel directives.' The tool appropriately transfers the user to a human agent with the summary 'User requests discussion on specialized government travel directives', ensuring policy compliance.",
              "A user requests assistance for resolving an issue with their reservation that none of the current tools can address, and explicitly states: 'I need help from a human agent to sort out this unique issue with my reservation.' The transfer is made with the summary 'User requests human agent for unique reservation issue', ensuring adherence to the policy.",
              "The user continues to encounter an unresolvable issue after attempting various tool-based solutions, ultimately stating: 'No tool can solve this problem, please transfer me to a real person'. The tool complies by transferring the user with the summary 'Persistent unresolved issue, transfer requested by user', following the policy.",
              "A user faces a technical glitch that prevents usage of available tools and requests: 'Can you help me get in touch with a human agent because I can't use the tools due to this error?'. The tool transfers the user and provides the summary 'Technical glitch preventing tool usage and user requests agent assistance', complying with the policy.",
              "The user seeks guidance for a complex travel itinerary adjustment due to unexpected circumstances not covered by any tools, explicitly requesting: 'I need to discuss this with someone who understands these complexities.'. The transfer is correctly made with the summary 'Complex travel itinerary adjustment, user requests human agent', ensuring compliance with the policy."
            ]
          },
          {
            "name": "Flight Segment Transfer Condition",
            "description": "If a user requests to cancel a trip and any segments have already been flown, transfer the user to a human agent as the current tool cannot process partial trip cancellations.",
            "references": [
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "A user requests to cancel their trip, and it is found that the first segment has already been flown. The system properly transfers the user's request to a human agent since it cannot process partial trip cancellations.",
              "A user explicitly requests a human agent to cancel a trip with flown segments. The system transfers to a human agent without attempting to use any tools.",
              "The system intelligently transfers to a human agent when it can't handle trip cancellations involving flown segments, even if a human agent isn't explicitly requested.",
              "Upon a user\u2019s request to cancel their trip, the system identifies flown segments and transfers to a human agent for assistance.",
              "A user requests cancellation with some flights already flown and the system swiftly transfers the issue to comply with the policy.",
              "When a user indirectly requests a human agent for cancelling a trip with flown segments, the system recognizes this condition and complies."
            ],
            "violation_examples": [
              "The user requests to cancel a trip that has already been fully or partially flown. The system attempts to process the cancellation without transferring the user to a human agent.",
              "A user asks to cancel a trip but has not explicitly requested a human agent, even though some flight segments in the trip have already been flown. The system ignores the requirement to transfer.",
              "The system attempts to cancel a multi-segment trip where segments have already been flown without transferring the user to a human agent, violating the policy for partial cancellations.",
              "A user requests a cancellation of their reservation with flown segments. The system ignores the transfer requirement and attempts to handle the request using automated tools.",
              "The system processes a full trip cancellation without a transfer, aware that parts of the trip have already been flown, and the user does not specify needing human assistance."
            ]
          },
          {
            "name": "Human Agent Assistance Limitation",
            "description": "For requests involving changes to the number of passengers in a reservation, notify the user that neither the automated system nor human agents can process this change. Therefore, transfer to a human agent is not permitted for these requests.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user requests to update passenger details without changing the number of passengers and is not transferred to a human agent since the tool can handle the modification, adhering to the policy.",
              "The user asks to modify passport details for existing passengers, and the system performs the update without any transfer, as passenger count remains unchanged.",
              "A user needs to change seat preferences for the same number of passengers in a reservation. The automated system successfully handles this request as it does not involve altering passenger count, complying with the policy.",
              "A user wants to change the arrival time preferences for existing passengers in a reservation without changing the number of passengers. This update is handled by the automated system, in alignment with the policy.",
              "The user requests to modify the contact information of current passengers in the booking. Since the number of passengers remains the same, the automated system processes the update, complying with the policy without transferring to a human agent."
            ],
            "violation_examples": [
              "A user requests to change the number of passengers in a reservation and since it cannot be done via the automated system, the user is transferred to a human agent, violating the policy.",
              "The user attempts to modify from five to six passengers in their reservation and, despite being impossible both automatically and manually, they are incorrectly transferred to a human agent for assistance, contrary to policy restrictions.",
              "A customer is transferred to a human agent after attempting to add an additional passenger to their booking, which the policy clearly prohibits."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_transfer_to_human_agents",
      "guard_file": {
        "file_name": "airline/transfer_to_human_agents/guard_transfer_to_human_agents.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.transfer_to_human_agents.guard_transfer_to_human_agent_conditions import guard_transfer_to_human_agent_conditions\nfrom airline.transfer_to_human_agents.guard_flight_segment_transfer_condition import guard_flight_segment_transfer_condition\nfrom airline.transfer_to_human_agents.guard_human_agent_assistance_limitation import guard_human_agent_assistance_limitation\n\n\ndef guard_transfer_to_human_agents(api: I_Airline, summary: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_transfer_to_human_agent_conditions(api, summary)\n    guard_flight_segment_transfer_condition(api, summary)\n    guard_human_agent_assistance_limitation(api, summary)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/transfer_to_human_agents/guard_transfer_to_human_agent_conditions.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_transfer_to_human_agent_conditions(api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: Transfer a user to a human agent only if the user explicitly requests this transfer\n    or if the problem cannot be resolved using available tools and policies within the scope of your actions.\n    Include a summary of the user's issue when making the transfer.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n    \"\"\"\n    if not summary or not summary.strip():\n        raise PolicyViolationException(\"Summary of the user's issue must be provided.\")\n\n    # Normalize summary for keyword checks\n    normalized_summary = summary.lower()\n\n    # Check if the user explicitly requests a human agent\n    explicit_request_keywords = [\n        \"human agent\", \"real person\", \"speak with\", \"talk to\", \"transfer me\", \"agent assistance\"\n    ]\n    if any(keyword in normalized_summary for keyword in explicit_request_keywords):\n        return  # Allowed due to explicit request\n\n    # If not explicitly requested, check if the issue can be resolved with available tools\n    # We will check for keywords that match the capabilities of dependent tools\n    tool_keywords = {\n        'get_reservation_details': [\"reservation details\", \"reservation id\"],\n        'update_reservation_flights': [\"change flight\", \"update flight\", \"flight date change\"],\n        'calculate': [\"calculate\", \"calculation\", \"math\", \"expression\"],\n        'list_all_airports': [\"list of airports\", \"airport list\"],\n        'get_flight_status': [\"flight status\", \"status of flight\"],\n        'search_direct_flight': [\"search direct flight\", \"find direct flight\"]\n    }\n\n    for tool, keywords in tool_keywords.items():\n        if any(keyword in normalized_summary for keyword in keywords):\n            # This means the issue can be resolved with an available tool\n            raise PolicyViolationException(\n                f\"The issue described can be resolved using the available tool '{tool}', transfer not allowed.\"\n            )\n\n    # If no explicit request and no matching tool found, allow transfer\n    return"
        },
        {
          "file_name": "airline/transfer_to_human_agents/guard_flight_segment_transfer_condition.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_segment_transfer_condition(api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: If a user requests to cancel a trip and any segments have already been flown, transfer the user to a human agent as the current tool cannot process partial trip cancellations.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/transfer_to_human_agents/guard_human_agent_assistance_limitation.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_human_agent_assistance_limitation(api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: For requests involving changes to the number of passengers in a reservation, notify the user that neither the automated system nor human agents can process this change. Therefore, transfer to a human agent is not permitted for these requests.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/transfer_to_human_agents/test_guard_transfer_to_human_agent_conditions.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.transfer_to_human_agents.guard_transfer_to_human_agent_conditions import guard_transfer_to_human_agent_conditions\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\ndef test_transfer_for_reservation_details_violation():\n    \"\"\"\n    Policy: Transfer only if explicitly requested or cannot be resolved with available tools.\n    Example: \"A user asks for details about their reservation ID '8JX2WO'... This violates the policy as the issue can be resolved with the available tool.\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    # Mock dependent tools\n    api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n        reservation_id=reservation_id,\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    ) if reservation_id == \"8JX2WO\" else None\n    api.get_flight_status.side_effect = lambda *args, **kwargs: \"on time\"\n    api.calculate.side_effect = lambda expr: str(eval(expr))\n    api.update_reservation_flights.side_effect = lambda *args, **kwargs: None\n    api.search_direct_flight.side_effect = lambda *args, **kwargs: []\n    api.list_all_airports.side_effect = lambda: []\n\n    with pytest.raises(PolicyViolationException):\n        guard_transfer_to_human_agent_conditions(api, summary=\"User requests reservation details\")\n\ndef test_transfer_explicit_user_request_compliance():\n    \"\"\"\n    Policy: Transfer only if explicitly requested or cannot be resolved with available tools.\n    Example: \"A user explicitly requests to be transferred to a human agent stating: 'I need to speak with a real person about my bill.'\"\n    \"\"\"\n    api = MagicMock(spec=I_Airline)\n    # Mock dependent tools\n    api.get_reservation_details.side_effect = lambda *args, **kwargs: None\n    api.get_flight_status.side_effect = lambda *args, **kwargs: \"on time\"\n    api.calculate.side_effect = lambda expr: str(eval(expr))\n    api.update_reservation_flights.side_effect = lambda *args, **kwargs: None\n    api.search_direct_flight.side_effect = lambda *args, **kwargs: []\n    api.list_all_airports.side_effect = lambda: []\n\n    # Should not raise exception\n    guard_transfer_to_human_agent_conditions(api, summary=\"User requests assistance with billing directly from an agent\")"
        },
        null,
        null
      ]
    },
    "update_reservation_flights": {
      "tool": {
        "tool_name": "update_reservation_flights",
        "policy_items": [
          {
            "name": "Explicit User Confirmation Required",
            "description": "Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "The agent presents the updated flight itinerary, cabin class changes, and passenger adjustments in detail and waits for the user to reply 'yes' before proceeding, ensuring compliance with the required user confirmation.",
              "User interaction history reveals explicit verbal confirmation ('yes') after presenting action details via email, allowing the update_reservation_flights tool to proceed in accordance with policy.",
              "Before confirming flight changes, the system shows a summary detailing new flight segments and asks, 'Do you confirm?' The user responds with 'yes', thereby validating the action and meeting the explicit consent requirement.",
              "Flight changes are sent to the user's registered email address with clear action details, and the system waits until the user replies 'yes' before executing any update, ensuring compliance with the policy.",
              "A detailed list of updates, including flight, baggage, and cabin class changes, is shown to the user during a live chat, and the agent proceeds only after a clear 'yes' from the user, validating adherence to the explicit confirmation policy."
            ],
            "violation_examples": [
              "An agent updates the flight details of a reservation without asking the user for confirmation, proceeding with changes based on assumed preferences, which violates the requirement for explicit user consent.",
              "The system automatically applies updates to the reservation based on recent user activity without presenting details or receiving explicit confirmation, failing to adhere to the explicit confirmation policy.",
              "Updates to the cabin class and passenger information are executed without the user explicitly saying 'yes', after merely highlighting them, leading to non-compliance with the explicit consent requirement.",
              "A reservation update is initiated after receiving implicit consent from phrases like 'okay' or 'sounds good', rather than a clear 'yes', which does not meet the policy's explicit confirmation standard.",
              "The system pre-fills all updates regarding flights and baggage but does not prompt the user for confirmation before finalizing, violating the policy's demand for explicit consent."
            ]
          },
          {
            "name": "Cannot Modify Basic Economy Flights",
            "description": "Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified.</p>",
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type.</p>"
            ],
            "compliance_examples": [
              "An agent successfully updates a 'business' reservation by changing the flight times, keeping the same origin 'SFO' and destination 'JFK' without altering the trip type from 'round_trip', ensuring compliance with the policy.",
              "A user with a 'business' class reservation updates the cabin class and flight numbers, ensuring the original origin and destination IATA codes 'ORD' and 'LAX' remain unchanged, thus complying with reservation policies.",
              "A user successfully modifies their 'economy' reservation by adding a special meal preference, while preserving all other flight details including origin and trip type, adhering to policy guidelines.",
              "An agent updates a 'business' class reservation, adding another layover in the flight segments but maintaining the original itinerary's origin 'ATL', destination 'HNL', and 'round_trip' type, in line with the policy.",
              "An agent processes an update for an economy reservation by adding extra baggage allowance, ensuring the flight itinerary remains intact with the original destination 'BOS' and trip type 'round_trip', fulfilling the policy requirements.",
              "A user successfully modifies an economy reservation by adding a preferred seating option, while ensuring the origin, destination, and trip type 'one_way' remain unchanged, complying with the policy."
            ],
            "violation_examples": [
              "A user attempts to change a reservation with basic economy flights by providing a new itinerary with updated origin and destination details, violating the restriction on modifying basic economy flights.",
              "An agent tries to update a basic economy flight reservation by changing the cabin class from 'basic_economy' to 'economy', which violates the policy against altering basic economy reservations.",
              "A user requests modifying a reservation classified as basic economy by supplying an edited flight array containing different departure times, going against the policy of non-modification for basic economy.",
              "A user tries to adjust the basic economy flight itinerary by requesting a new connecting flight option instead of their direct flight, contravening the reservation policy.",
              "An agent attempts to update a reservation classified as 'economy' by changing the trip type from 'round_trip' to 'one_way', which violates the policy of maintaining trip type for non-basic reservations.",
              "A user submits a request to change the flights in a business class reservation by altering the destination from 'SFO' to 'NYC', breaking the rule against changing destinations in non-basic reservations."
            ]
          },
          {
            "name": "Cabin Change Payment Requirement",
            "description": "ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user changes the entire reservation's cabin class from economy to business, ensuring all flight segments are included in the updated reservation request and provides payment details to cover the fare difference, fully complying with the policy.",
              "A user updates all flight segments of their reservation from basic economy to economy class, ensuring the cabin class is uniformly changed across the entire reservation and pays the required fare difference, adhering to policy requirements.",
              "The user modifies their reservation to change all flight segments from economy to first class and provides necessary payment methods to cover the new cabin class fare difference, ensuring full compliance.",
              "A user updates all flight segments from first class to business class, providing their credit card details that have sufficient funds to cover the fare reduction difference for all segments in their reservation.",
              "A user requests a cabin change for their reservation, ensuring all flight segments are updated from premium economy to economy class and provides a payment method with a sufficient balance to cover the reduced fare difference, meeting policy standards."
            ],
            "violation_examples": [
              "A user attempts to change only one segment of their reservation from economy to business class without updating the cabin class for the entire reservation, violating the required uniform cabin change.",
              "A user updates their reservation to have mixed cabin classes, changing one flight to economy and another to business class within the same reservation, which breaks the policy mandating uniform cabin class across all flights.",
              "A user changes their entire reservation from basic economy to business class but only provides payment that covers the difference for a single flight segment, not fulfilling the policy requirement for covering the fare difference for the entire reservation.",
              "A user attempts to change their reservation's cabin class from economy to premium economy for all flights but incorrectly inputs payment that covers a partial fare difference, resulting in insufficient payment for the full reservation change.",
              "A user tries to change the cabin class for certain flight segments without updating all flights in the reservation, resulting in an inconsistent cabin class within the reservation.",
              "A user tries to change the entire reservation to business class but their payment method is actually a gift card with a balance insufficient to cover the necessary fare difference, violating payment requirement policies.",
              "A user updates their reservation's cabin class across multiple flights but improperly inputs payment details, leading to a request that lacks coverage for every part of the cabin fare change."
            ]
          },
          {
            "name": "Cabin Uniformity Requirement",
            "description": "Cabin class must be the same across all flights in a reservation.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user updates a reservation so all flights are reassigned to economy class, ensuring uniform cabin class and complying with the policy.",
              "The reservation is modified to have all flights in business class, maintaining a consistent cabin class across the entire reservation as per the policy.",
              "Both flight segments in a round-trip reservation are changed to the same cabin class, such as economy, meeting the Cabin Uniformity Requirement."
            ],
            "violation_examples": [
              "A reservation is updated with mixed cabin classes, such as economy and business, across different flights within the same reservation. This violates the policy requiring uniform cabin class.",
              "A user changes one flight to economy and another to basic economy within a reservation, failing the Cabin Uniformity Requirement that mandates the same cabin class for all flights."
            ]
          },
          {
            "name": "Payment Method Requirement for Flight Changes",
            "description": "Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.",
            "references": [
              "<p>Payment: If the flights are changed, the user needs to provide one gift card or credit card for payment or refund method. The agent should ask for the payment or refund method instead.</p>"
            ],
            "compliance_examples": [
              "The user requests a flight change and provides a valid credit card from their profile, satisfying the policy requirement for payment method.",
              "Flight changes are applied after the user selects a valid gift card from their profile for payment, in line with the policy.",
              "Users update their flight details and use a valid credit card linked to their profile for payment, fully complying with the policy guidelines."
            ],
            "violation_examples": [
              "A user attempts to change flights in a reservation without providing any valid payment information such as a gift card or credit card linked to their profile, which contravenes the policy.",
              "A flight update process begins with the user providing only a certificate as payment, despite the requirement for a gift card or credit card.",
              "Whilst trying to modify their flight itinerary, the user neglects to choose any valid payment method from their profile, which violates the mandatory payment method requirement.",
              "A user insists on using a payment method not linked to their profile, such as a friend's credit card, defying the policy's requirement for payment methods to be from the user's profile."
            ]
          },
          {
            "name": "Flight Modification API Limitation Check",
            "description": "Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.",
            "references": [
              "Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!"
            ],
            "compliance_examples": [
              "An agent updates a reservation by changing the flight times while preserving the original cabin class, origin, destination, and trip type, complying with the policy requirements.",
              "Update reservation flights with the same 'origin' and 'destination', ensuring no changes in basic structure, and manually verify segment prices, complying with the policy.",
              "The agent modifies a reservation by adding additional flight segments while original flight details, including trip type and destination, remain unchanged, adhering to the policy.",
              "Keeping the flight segments unchanged and manually verifying that the prices remain the same while modifying flights in a business cabin reservation complies with the policy.",
              "The agent updates a reservation to change seat preference while ensuring the origin, destination, and trip type are consistent with the initial booking, meeting policy criteria."
            ],
            "violation_examples": [
              "An agent attempts to use the Flight Modification API to change the cabin class of a reservation booked under 'basic_economy'. This violates the policy since 'basic_economy' flights are unmodifiable.",
              "The agent changes the origin from 'SFO' to 'LAX' in a reservation update, violating the policy as the origin must remain unchanged.",
              "Changing the destination from 'JFK' to 'BOS' during a reservation update violates the policy because the destination must remain unchanged.",
              "An agent updates a flight reservation from a 'round_trip' to a 'one_way' trip, violating the policy since the trip type cannot be altered.",
              "An agent uses the API to modify a flight reservation without manually verifying the prices of retained flight segments, violating the policy that requires agents to confirm original rates manually."
            ]
          },
          {
            "name": "Consistency Across Flight Segments",
            "description": "When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!</p>"
            ],
            "compliance_examples": [
              "A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.",
              "When modifying an itinerary, the agent ensures the flights array contains every flight segment from the original reservation, even those that were not changed, complying fully with the policy.",
              "A reservation update for altering the cabin class is processed correctly with all segments kept in the flights array to maintain consistency as per policy rules."
            ],
            "violation_examples": [
              "A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.",
              "An agent updates the reservation for a flight change but mistakenly excludes connecting segments that were part of the same trip, leading to an incomplete submission.",
              "During a reservation update involving a cabin class upgrade, the flights array only lists flights under the new cabin class, excluding previously booked ancillary services segments, violating the policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_flights",
      "guard_file": {
        "file_name": "airline/update_reservation_flights/guard_update_reservation_flights.py",
        "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_flights.guard_explicit_user_confirmation_required import guard_explicit_user_confirmation_required\nfrom airline.update_reservation_flights.guard_cannot_modify_basic_economy_flights import guard_cannot_modify_basic_economy_flights\nfrom airline.update_reservation_flights.guard_cabin_change_payment_requirement import guard_cabin_change_payment_requirement\nfrom airline.update_reservation_flights.guard_cabin_uniformity_requirement import guard_cabin_uniformity_requirement\nfrom airline.update_reservation_flights.guard_payment_method_requirement_for_flight_changes import guard_payment_method_requirement_for_flight_changes\nfrom airline.update_reservation_flights.guard_flight_modification_api_limitation_check import guard_flight_modification_api_limitation_check\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\n\n\ndef guard_update_reservation_flights(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n\n    Raises:\n        PolicyViolationException: If the tool call does not comply to the policy.\n    \"\"\"\n    \n    guard_explicit_user_confirmation_required(api, reservation_id, cabin, flights, payment_id)\n    guard_cannot_modify_basic_economy_flights(api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_change_payment_requirement(api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_uniformity_requirement(api, reservation_id, cabin, flights, payment_id)\n    guard_payment_method_requirement_for_flight_changes(api, reservation_id, cabin, flights, payment_id)\n    guard_flight_modification_api_limitation_check(api, reservation_id, cabin, flights, payment_id)\n    guard_consistency_across_flight_segments(api, reservation_id, cabin, flights, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_flights/guard_explicit_user_confirmation_required.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_user_confirmation_required(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cannot_modify_basic_economy_flights.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cannot_modify_basic_economy_flights(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_change_payment_requirement.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_change_payment_requirement(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Retrieve the current reservation details\n    reservation = api.get_reservation_details(reservation_id)\n\n    # Ensure all flights in the updated reservation are included\n    if len(flights) != len(reservation.flights):\n        raise PolicyViolationException(\"All flight segments must be included in the cabin change request.\")\n\n    # Ensure uniform cabin class change across all flights\n    for flight in flights:\n        # The new cabin must be the same for all flights\n        if cabin != cabin:\n            raise PolicyViolationException(\"Cabin class must be uniform across all flights in the reservation.\")\n\n    # Ensure the cabin change is actually for all flights (no partial changes)\n    if reservation.cabin == cabin:\n        raise PolicyViolationException(\"Cabin class is unchanged; no update required.\")\n\n    # Ensure payment is provided (basic validation)\n    if not payment_id or not isinstance(payment_id, str):\n        raise PolicyViolationException(\"A valid payment method must be provided to cover the fare difference.\")\n\n    # Additional validation could be added here to check payment sufficiency if API supports it\n    # For now, we assume payment_id existence is enough for guard validation."
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_uniformity_requirement.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_uniformity_requirement(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Cabin class must be the same across all flights in a reservation.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_payment_method_requirement_for_flight_changes.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_requirement_for_flight_changes(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \"\"\"\n    # Retrieve reservation details to get the user_id\n    reservation = api.get_reservation_details(reservation_id)\n    user_id = reservation.user_id\n\n    # Retrieve user details to check payment methods\n    user = api.get_user_details(user_id)\n\n    # Check if the provided payment_id exists in the user's payment methods\n    payment_method = user.payment_methods.get(payment_id)\n    if payment_method is None:\n        raise PolicyViolationException(\"Provided payment method is not linked to the user's profile.\")\n\n    # Ensure the payment method is either a gift card or a credit card\n    if payment_method.source not in ('gift_card', 'credit_card'):\n        raise PolicyViolationException(\"Payment method must be a valid gift card or credit card from the user's profile.\")"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_flight_modification_api_limitation_check.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_modification_api_limitation_check(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.\n\n    Args:\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_consistency_across_flight_segments.py",
          "content": "from typing import *\n\nimport airline\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_consistency_across_flight_segments(api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: When updating a reservation, all flight segments must be included in the list of flights provided, \n    regardless of whether they have been altered or not.\n\n    Args:\n        api (I_Airline): API to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation.\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. \n                Even if a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \n    Raises:\n        PolicyViolationException: If not all original flight segments are included in the provided flights list.\n    \"\"\"\n    # Retrieve the original reservation details\n    original_reservation = api.get_reservation_details(reservation_id)\n    original_flights = original_reservation.flights\n\n    # Normalize provided flights to FlightInfo objects if they are dicts\n    provided_flights_info = []\n    for f in flights:\n        if isinstance(f, dict):\n            provided_flights_info.append(FlightInfo(**f))\n        else:\n            provided_flights_info.append(f)\n\n    # Check that all original flights are present in the provided flights list\n    for orig_flight in original_flights:\n        match_found = any(\n            pf.flight_number == orig_flight.flight_number and pf.date == orig_flight.date\n            for pf in provided_flights_info\n        )\n        if not match_found:\n            raise PolicyViolationException(\n                f\"Missing original flight segment {orig_flight.flight_number} on {orig_flight.date} in the update request.\"\n            )"
        }
      ],
      "test_files": [
        null,
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_cabin_change_payment_requirement.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_cabin_change_payment_requirement import guard_cabin_change_payment_requirement\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_change_entire_reservation_cabin():\n    \"\"\"\n    Policy: Ensure a uniform cabin class change across all flights within the reservation and payment for the fare difference.\n    Example: A user changes the entire reservation's cabin class from economy to business, ensuring all flight segments are included and provides payment details to cover the fare difference.\n    \"\"\"\n    \n    # Mock reservation details\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=200),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-06-10\", price=200)\n        ],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    # Mock API\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusAvailable(\n        status=\"available\",\n        available_seats={\"business\": 5, \"economy\": 5, \"basic_economy\": 5},\n        prices={\"business\": 400, \"economy\": 200, \"basic_economy\": 100}\n    ) if (fn, date) in [(\"HAT001\", \"2024-06-01\"), (\"HAT002\", \"2024-06-10\")] else None\n\n    flights = [\n        FlightInfo(flight_number=\"HAT001\", date=\"2024-06-01\"),\n        FlightInfo(flight_number=\"HAT002\", date=\"2024-06-10\")\n    ]\n\n    guard_cabin_change_payment_requirement(api, \"ZFA04Y\", \"business\", flights, \"credit_card_123\")\n\ndef test_change_only_one_segment_raises():\n    \"\"\"\n    Policy: Uniform cabin class change required across all flights.\n    Example: A user attempts to change only one segment of their reservation from economy to business class without updating the cabin class for the entire reservation.\n    \"\"\"\n    \n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=200),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-06-10\", price=200)\n        ],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusAvailable(\n        status=\"available\",\n        available_seats={\"business\": 5, \"economy\": 5, \"basic_economy\": 5},\n        prices={\"business\": 400, \"economy\": 200, \"basic_economy\": 100}\n    ) if (fn, date) in [(\"HAT001\", \"2024-06-01\"), (\"HAT002\", \"2024-06-10\")] else None\n\n    flights = [\n        FlightInfo(flight_number=\"HAT001\", date=\"2024-06-01\")\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_cabin_change_payment_requirement(api, \"ZFA04Y\", \"business\", flights, \"credit_card_123\")\n\ndef test_mixed_cabin_classes_raises():\n    \"\"\"\n    Policy: Uniform cabin class change required across all flights.\n    Example: A user updates their reservation to have mixed cabin classes, changing one flight to economy and another to business class.\n    \"\"\"\n    \n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"SFO\",\n        destination=\"JFK\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=200),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-06-10\", price=200)\n        ],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=0,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n    api.get_flight_instance.side_effect = lambda fn, date: FlightDateStatusAvailable(\n        status=\"available\",\n        available_seats={\"business\": 5, \"economy\": 5, \"basic_economy\": 5},\n        prices={\"business\": 400, \"economy\": 200, \"basic_economy\": 100}\n    ) if (fn, date) in [(\"HAT001\", \"2024-06-01\"), (\"HAT002\", \"2024-06-10\")] else None\n\n    flights = [\n        FlightInfo(flight_number=\"HAT001\", date=\"2024-06-01\"),\n        FlightInfo(flight_number=\"HAT002\", date=\"2024-06-10\")\n    ]\n\n    with pytest.raises(PolicyViolationException):\n        guard_cabin_change_payment_requirement(api, \"ZFA04Y\", \"economy\", flights, \"credit_card_123\")"
        },
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_payment_method_requirement_for_flight_changes.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_payment_method_requirement_for_flight_changes import guard_payment_method_requirement_for_flight_changes\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\ndef test_flight_change_with_valid_credit_card():\n    \"\"\"\n    Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method.\"\n    Example: \"The user requests a flight change and provides a valid credit card from their profile, satisfying the policy requirement for payment method.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"John\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"New York\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n        email=\"john.doe@example.com\",\n        dob=\"1980-01-01\",\n        payment_methods={\n            \"credit_card_123\": CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_123\")\n        },\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[\"resv001\"]\n    )\n    reservation = Reservation(\n        reservation_id=\"resv001\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"FL123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-01\", price=300)],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"resv001\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-02\")]\n    guard_payment_method_requirement_for_flight_changes(api, reservation_id=\"resv001\", cabin=\"economy\", flights=flights, payment_id=\"credit_card_123\")\n\ndef test_flight_change_without_payment_method():\n    \"\"\"\n    Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method.\"\n    Example: \"A user attempts to change flights in a reservation without providing any valid payment information such as a gift card or credit card linked to their profile, which contravenes the policy.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"John\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"New York\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n        email=\"john.doe@example.com\",\n        dob=\"1980-01-01\",\n        payment_methods={},\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[\"resv001\"]\n    )\n    reservation = Reservation(\n        reservation_id=\"resv001\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"FL123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-01\", price=300)],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"resv001\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-02\")]\n    with pytest.raises(PolicyViolationException):\n        guard_payment_method_requirement_for_flight_changes(api, reservation_id=\"resv001\", cabin=\"economy\", flights=flights, payment_id=\"\")\n\ndef test_flight_change_with_certificate_only():\n    \"\"\"\n    Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method.\"\n    Example: \"A flight update process begins with the user providing only a certificate as payment, despite the requirement for a gift card or credit card.\"\n    \"\"\"\n    user = User(\n        user_id=\"user123\",\n        name=Name(first_name=\"John\", last_name=\"Doe\"),\n        address=Address(address1=\"123 Main St\", address2=None, city=\"New York\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n        email=\"john.doe@example.com\",\n        dob=\"1980-01-01\",\n        payment_methods={\n            \"certificate_123\": Certificate(source=\"certificate\", amount=100.0, id=\"certificate_123\")\n        },\n        saved_passengers=[],\n        membership=\"gold\",\n        reservations=[\"resv001\"]\n    )\n    reservation = Reservation(\n        reservation_id=\"resv001\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"round_trip\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"FL123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-01\", price=300)],\n        passengers=[],\n        payment_history=[],\n        created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n    api = MagicMock(spec=I_Airline)\n    api.get_user_details.side_effect = lambda uid: user if uid == \"user123\" else None\n    api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"resv001\" else None\n\n    flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-02\")]\n    with pytest.raises(PolicyViolationException):\n        guard_payment_method_requirement_for_flight_changes(api, reservation_id=\"resv001\", cabin=\"economy\", flights=flights, payment_id=\"certificate_123\")"
        },
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_consistency_across_flight_segments.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestGuardConsistencyAcrossFlightSegments:\n\n    def test_update_with_all_segments_included(self):\n        \"\"\" \n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.\"\n        \"\"\"\n        \n        # Mock reservation with two segments\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=300),\n                ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-06-10\", price=320)\n            ],\n            passengers=[],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n        flights = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-06-01\"),\n            FlightInfo(flight_number=\"HAT002\", date=\"2024-06-10\")\n        ]\n\n        # Should not raise\n        guard_consistency_across_flight_segments(api, reservation_id=\"ZFA04Y\", cabin=\"economy\", flights=flights, payment_id=\"credit_card_123\")\n\n    def test_update_with_only_altered_segment(self):\n        \"\"\" \n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.\"\n        \"\"\"\n        \n        # Mock reservation with two segments\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=300),\n                ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-06-10\", price=320)\n            ],\n            passengers=[],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n        flights = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-06-01\")\n        ]\n\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(api, reservation_id=\"ZFA04Y\", cabin=\"economy\", flights=flights, payment_id=\"credit_card_123\")\n\n    def test_update_excludes_connecting_segments(self):\n        \"\"\" \n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"An agent updates the reservation for a flight change but mistakenly excludes connecting segments that were part of the same trip, leading to an incomplete submission.\"\n        \"\"\"\n        \n        # Mock reservation with three segments (one connection)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"LHR\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT100\", origin=\"SFO\", destination=\"JFK\", date=\"2024-07-01\", price=200),\n                ReservationFlight(flight_number=\"HAT200\", origin=\"JFK\", destination=\"LHR\", date=\"2024-07-02\", price=500)\n            ],\n            passengers=[],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n        flights = [\n            FlightInfo(flight_number=\"HAT100\", date=\"2024-07-01\")\n        ]\n\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(api, reservation_id=\"ZFA04Y\", cabin=\"business\", flights=flights, payment_id=\"credit_card_123\")\n\n    def test_update_excludes_ancillary_service_segments(self):\n        \"\"\" \n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"During a reservation update involving a cabin class upgrade, the flights array only lists flights under the new cabin class, excluding previously booked ancillary services segments, violating the policy.\"\n        \"\"\"\n        \n        # Mock reservation with main flight and ancillary service segment\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"HAT300\", origin=\"SFO\", destination=\"JFK\", date=\"2024-08-01\", price=300),\n                ReservationFlight(flight_number=\"ANC001\", origin=\"JFK\", destination=\"JFK\", date=\"2024-08-01\", price=50)\n            ],\n            passengers=[],\n            payment_history=[],\n            created_at=datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n\n        flights = [\n            FlightInfo(flight_number=\"HAT300\", date=\"2024-08-01\")\n        ]\n\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(api, reservation_id=\"ZFA04Y\", cabin=\"business\", flights=flights, payment_id=\"credit_card_123\")"
        }
      ]
    }
  }
}