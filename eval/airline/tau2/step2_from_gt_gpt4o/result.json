{
  "domain": {
    "app_name": "airline",
    "toolguard_common": {
      "file_name": "rt_toolguard/data_types.py",
      "content": "from abc import ABC, abstractmethod\nimport os\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import Any, List, Optional\n\nDEBUG_DIR = \"debug\"\nTESTS_DIR = \"tests\"\nRESULTS_FILENAME = \"result.json\"\nHISTORY_PARAM = \"history\"\nHISTORY_PARAM_TYPE = \"ChatHistory\"\nAPI_PARAM = \"api\"\n\nclass FileTwin(BaseModel):\n    file_name: str\n    content: str\n\n    def save(self, folder:str)->'FileTwin':\n        full_path = os.path.join(folder, self.file_name)\n        parent = Path(full_path).parent\n        os.makedirs(parent, exist_ok=True)\n        with open(full_path, \"w\") as file:\n            file.write(self.content)\n        return self\n\n    def save_as(self, folder:str, file_name:str)->'FileTwin':\n        file_path = os.path.join(folder, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(self.content)\n        return FileTwin(file_name=file_name, content=self.content)\n\n    @staticmethod\n    def load_from(folder:str, file_path:str)->'FileTwin':\n        with open(os.path.join(folder, file_path), \"r\") as file:\n            data = file.read()\n            return FileTwin(\n                file_name=file_path, \n                content=data\n            )\n\nclass ToolPolicyItem(BaseModel):\n    name: str = Field(..., description=\"Policy item name\")\n    description: str = Field(..., description=\"Policy item description\")\n    references: List[str] = Field(..., description=\"original texts\")\n    compliance_examples: Optional[List[str]] = Field(..., description=\"Example of cases that comply with the policy\")\n    violation_examples: Optional[List[str]] = Field(..., description=\"Example of cases that violate the policy\")\n\n    def to_md_bulltets(self, items: List[str])->str:\n        s = \"\"\n        for item in items:\n            s+=f\"* {item}\\n\"\n        return s\n    \n    def __str__(self) -> str:\n        s = f\"#### Policy item \" + self.name + \"\\n\"\n        s += f\"{self.description}\\n\"\n        if self.compliance_examples:\n            s += f\"##### Positive examples\\n{self.to_md_bulltets(self.compliance_examples)}\"\n        if self.violation_examples:\n            s += f\"##### Negative examples\\n{self.to_md_bulltets(self.violation_examples)}\"\n        return s\n\nclass ToolPolicy(BaseModel):\n    tool_name: str = Field(..., description=\"Name of the tool\")\n    policy_items: List[ToolPolicyItem] = Field(..., description=\"Policy items. All (And logic) policy items must hold whehn invoking the tool.\")\n\nclass Domain(BaseModel):\n    app_name: str = Field(..., description=\"Application name\")\n    toolguard_common: FileTwin = Field(..., description=\"Pydantic data types used by toolguard framework.\")\n    app_types: FileTwin = Field(..., description=\"Data types defined used in the application API as payloads.\")\n    app_api_class_name: str = Field(..., description=\"Name of the API class name.\")\n    app_api: FileTwin = Field(..., description=\"Python class (abstract) containing all the API signatures.\")\n    app_api_size: int = Field(..., description=\"Number of functions in the API\")\n\nclass RuntimeDomain(Domain):\n    app_api_impl_class_name: str = Field(..., description=\"Python class (implementaton) class name.\")\n    app_api_impl: FileTwin = Field(..., description=\"Python class containing all the API method implementations.\")\n\nclass ChatHistory(ABC):\n    \"\"\"Represents a history of chat messages and provides methods check if specific events already happened.\"\"\"\n\n    @abstractmethod\n    def ask_bool(self, question:str)->bool:\n        \"\"\"\n        Asks a yes/no question and returns the response as a boolean.\n\n        Args:\n            question (str): The yes/no question to be asked. Example: \"Did the user accepted the agent's proposal?\"\n\n        Returns:\n            bool: The interpreted boolean response from the language model.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def did_tool_return_value(self, tool_name:str, expected_value:Any)->bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history and validates if the expected value was returned\n            Example: \"did_tool_return_value(\"book_hotel\",True) checks if the history shows calling the function book_hotel and if the returned value was true did_tool_return_value will return true else false\n        \n        Args:\n            tool_name (str): The name of the tool to check for in the message history.\n            expected_value: The expected value of the tool call.\n        \n        Returns:\n            bool: True if the tool was called returning expected_value, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def was_tool_called(self, tool_name: str) -> bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history.\n\t\tArgs:\n\t\t\ttool_name (str): The name of the tool to check for in the message history.\n\t\tReturns:\n\t\t\tbool: True if the tool was called, False otherwise.\n\t\t\"\"\"\n        pass\n\n\nclass PolicyViolationException(Exception):\n    _msg: str\n    def __init__(self, message:str):\n        super().__init__(message)\n        self._msg = message\n\n    @property\n    def message(self):\n        return self._msg\n"
    },
    "app_types": {
      "file_name": "airline/airline_types.py",
      "content": "# Auto-generated type definitions\nfrom enum import Enum\nfrom abc import ABC\nfrom typing import *\nfrom pydantic import BaseModel, Field\n\nclass AirportCode(BaseModel):\n    iata: str  # IATA code\n    city: str  # City name\n\nclass FlightDataStatusFlying(BaseModel):\n    status: Literal['flying']  # Indicates flight is in flight\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass Name(BaseModel):\n    first_name: str  # The person's first name\n    last_name: str  # The person's last name\n\nclass FlightDataStatusOnTime(BaseModel):\n    status: Literal['on time']  # Indicates flight is on time\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusAvailable(BaseModel):\n    status: Literal['available']  # Indicates flight is available for booking\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass Address(BaseModel):\n    address1: str  # Primary address line\n    address2: Optional[str]  # Secondary address line (optional)\n    city: str  # City name\n    country: str  # Country name\n    state: str  # State or province name\n    zip: str  # Postal code\n\nclass FlightInfo(BaseModel):\n    flight_number: str  # Flight number, such as 'HAT001'.\n    date: str  # The date for the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\nclass FlightBase(BaseModel):\n    flight_number: str  # Unique flight identifier\n    origin: str  # IATA code for origin airport\n    destination: str  # IATA code for destination airport\n\nclass Passenger(BaseModel):\n    first_name: str  # Passenger's first name\n    last_name: str  # Passenger's last name\n    dob: str  # Date of birth in YYYY-MM-DD format\n\nclass FlightDateStatusCancelled(BaseModel):\n    status: Literal['cancelled']  # Indicates flight was cancelled\n\nclass Payment(BaseModel):\n    payment_id: str  # Unique identifier for the payment\n    amount: int  # Payment amount in dollars\n\nclass FlightDateStatusDelayed(BaseModel):\n    status: Literal['delayed']  # Indicates flight was delayed\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass PaymentMethodBase(BaseModel):\n    source: str  # Type of payment method\n    id: str  # Unique identifier for the payment method\n\nclass FlightDateStatusLanded(BaseModel):\n    status: Literal['landed']  # Indicates flight has landed\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    actual_arrival_time_est: str  # Actual arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass DirectFlight(FlightBase):\n    status: Literal['available']  # Indicates flight is available for booking\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    date: Optional[str]  # Flight date in YYYY-MM-DD format\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass ReservationFlight(FlightBase):\n    date: str  # Flight date in YYYY-MM-DD format\n    price: int  # Flight price in dollars.\n\nclass GiftCard(PaymentMethodBase):\n    source: Literal['gift_card']  # Indicates this is a gift card payment method\n    amount: float  # Gift card value amount\n    id: str  # Unique identifier for the gift card\n\nclass CreditCard(PaymentMethodBase):\n    source: Literal['credit_card']  # Indicates this is a credit card payment method\n    brand: str  # Credit card brand (e.g., visa, mastercard)\n    last_four: str  # Last four digits of the credit card\n\nclass Certificate(PaymentMethodBase):\n    source: Literal['certificate']  # Indicates this is a certificate payment method\n    amount: float  # Certificate value amount\n\nclass Flight(FlightBase):\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    dates: dict[str, Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]]  # Flight status by date (YYYY-MM-DD)\n\nclass Reservation(BaseModel):\n    reservation_id: str  # Unique identifier for the reservation\n    user_id: str  # ID of the user who made the reservation\n    origin: str  # IATA code for trip origin\n    destination: str  # IATA code for trip destination\n    flight_type: Literal['round_trip', 'one_way']  # Type of trip\n    cabin: Literal['business', 'economy', 'basic_economy']  # Selected cabin class\n    flights: list[ReservationFlight]  # List of flights in the reservation\n    passengers: list[Passenger]  # List of passengers on the reservation\n    payment_history: list[Payment]  # History of payments for this reservation\n    created_at: str  # Timestamp when reservation was created in the format YYYY-MM-DDTHH:MM:SS\n    total_baggages: int  # Total number of bags in reservation\n    nonfree_baggages: int  # Number of paid bags in reservation\n    insurance: Literal['yes', 'no']  # Whether travel insurance was purchased\n    status: Optional[Literal['cancelled']]  # Status of the reservation\n\nclass User(BaseModel):\n    user_id: str  # Unique identifier for the user\n    name: Name  # User's full name\n    address: Address  # User's address information\n    email: str  # User's email address\n    dob: str  # User's date of birth in the format YYYY-MM-DD, e.g 1990-04-05\n    payment_methods: dict[str, Union[CreditCard, GiftCard, Certificate]]  # User's saved payment methods\n    saved_passengers: list[Passenger]  # User's saved passenger information\n    membership: Literal['gold', 'silver', 'regular']  # User's membership level\n    reservations: list[str]  # List of user's reservation IDs\n"
    },
    "app_api_class_name": "I_Airline",
    "app_api": {
      "file_name": "airline/i_airline.py",
      "content": "# Auto-generated class interface\nfrom typing import * # type: ignore\nfrom abc import ABC, abstractmethod\nfrom airline.airline_types import *\n\nclass I_Airline(ABC):\n\n    @abstractmethod\n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n        ...\n"
    },
    "app_api_size": 16,
    "app_api_impl_class_name": "Airlineimpl",
    "app_api_impl": {
      "file_name": "airline/airline_impl.py",
      "content": "# Auto-generated class\nfrom typing import *\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass Airlineimpl(I_Airline):\n\n    def __init__(self, delegate: I_Airline):\n        self._delegate = delegate\n    \n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n\n        return self._delegate.book_reservation(user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n\n\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n\n        return self._delegate.calculate(expression)\n\n\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.cancel_reservation(reservation_id)\n\n\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_instance(flight_number, date)\n\n\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_status(flight_number, date)\n\n\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.get_reservation_details(reservation_id)\n\n\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_scheduled_flight(flight_number)\n\n\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.get_user_details(user_id)\n\n\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n\n        return self._delegate.list_all_airports()\n\n\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n\n        return self._delegate.search_direct_flight(origin, destination, date)\n\n\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n\n        return self._delegate.search_onestop_flight(origin, destination, date)\n\n\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.send_certificate(user_id, amount)\n\n\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n\n        return self._delegate.transfer_to_human_agents(summary)\n\n\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_baggages(reservation_id, total_baggages, nonfree_baggages, payment_id)\n\n\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_flights(reservation_id, cabin, flights, payment_id)\n\n\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n\n        return self._delegate.update_reservation_passengers(reservation_id, passengers)\n\n"
    }
  },
  "tools": {
    "book_reservation": {
      "tool": {
        "tool_name": "book_reservation",
        "policy_items": [
          {
            "name": "User ID and User Profile Verification",
            "description": "Before invoking ToolX (BookReservation), make sure that the user's ID is correctly obtained. After verifying the user ID, gather necessary booking information such as trip type, origin, and destination prior to making the reservation using ToolX.",
            "references": [
              "The agent must first obtain the user id, then ask for the trip type, origin, destination."
            ],
            "compliance_examples": [
              "An agent receives a user request to book a flight, first verifies the user's ID exists in the system records, and subsequently collects information on trip type, origin, and destination before proceeding with BookReservation."
            ],
            "violation_examples": [
              "The agent attempts to use BookReservation but enters an incorrect user ID that does not exist in the system records.",
              "After obtaining the user ID, the agent makes a call to BookReservation without confirming the trip type, thereby not gathering necessary booking information.",
              "Upon receiving an ID query from a user, the agent assumes the ID is correct without verifying it against system records and proceeds to book a reservation, breaching the mandate for ID confirmation."
            ]
          },
          {
            "name": "Flight Status Restrictions",
            "description": "Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. Flights with status 'delayed', 'on time', or 'flying' cannot be booked.",
            "references": [
              "If the status is \"available\", the flight has not taken off",
              "If the status is \"delayed\" or \"on time\", the flight has not taken off, cannot be booked.",
              "If the status is \"flying\", the flight has taken off but not landed, cannot be booked."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.",
              "Before booking a round-trip flight for two passengers in economy class, the agent verifies all flights' statuses are 'available' and there are two seats available for this class."
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.",
              "An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.",
              "A reservation request is made for a flight with the status 'on time'.",
              "An agent attempts to book a round-trip from LAX to DFW for a user, but the departure flight's status is 'on time' which is not permissible as per the policy that only allows booking flights with 'available' status.",
              "A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.",
              "A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.",
              "A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'."
            ]
          },
          {
            "name": "Seats Are Available",
            "description": "Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.",
            "references": [
              "If the status is \"available\", the flight has not taken off, available seats and prices are listed."
            ],
            "compliance_examples": [
              "A user requests to book a flight from SFO to LAX on June 20th in economy class. The flight status is 'available' and there are 21 available seats",
              "A user is booking a round-trip flight from SFO to LAX, for two passengers in economy class. There are enough availble seats in the two flights"
            ],
            "violation_examples": [
              "A user attempts to book a flight to New York on May 16th for 5 passengers in business class, however only 4 seats are available on this flight",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, the outgoing flight status is availbale, but the there are no available seat in this cabin",
              "An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, there are enough seats in the outgoing flight and the flight status is availabile. The return flight status is availbale, but the there are no available seat in this cabin"
            ]
          },
          {
            "name": "Passenger Information Completeness",
            "description": "Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.",
            "references": [
              "Passengers: Each reservation can have at most five passengers. The agent needs to collect the first name, last name, and date of birth for each passenger."
            ],
            "compliance_examples": [
              "An agent successfully gathers and verifies all required passenger information including first name, last name, and date of birth for each of the five passengers."
            ],
            "violation_examples": [
              "An agent attempts to book a reservation using BookReservation for six passengers instead of the allowed maximum of five.",
              "An agent calls BookReservation with the passenger details incomplete, missing the date of birth for each passenger.",
              "An agent attempts to book a reservation with no passengers.",
              "Booking a reservation for one passenger with missing first name information.",
              "Booking a reservation for one passenger with missing last name information."
            ]
          },
          {
            "name": "Payment Method Restriction",
            "description": "Ensure each reservation through BookReservation uses a maximum of one travel certificate, one credit card, and up to three gift cards. Verify that all payment methods are pre-registered in the user profile before proceeding with booking to maintain security and database integrity.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "A reservation is made using a single credit card that is already registered in the user's profile.",
              "The user books a flight using one travel certificate and three gift cards (all pre-registered in their profile).",
              "A user uses one credit card and one gift card that are already stored in their user profile.",
              "A reservation is completed using only two gift cards and no travel certificate or credit card. Both gift cards are pre-existing in the user's profile."
            ],
            "violation_examples": [
              "A user attempts to book a reservation using two credit cards.",
              "During reservation, a user inputs four gift cards.",
              "A user submits a booking request where the payment method includes a travel certificate not listed in the user profile.",
              "A booking attempt is made using a travel certificate, a credit card, and an additional travel certificate for balance.",
              "The booking data included the use of an unverified payment method - a newly added gift card not synced with the user profile.",
              "Upon making a reservation, the user provides payment details for a new credit card that isn't in the user's pre-registered profile list."
            ]
          },
          {
            "name": "Checked Bag Allowance by Membership Tier",
            "description": "The checked bag allowance policy for booking a reservation varies by membership tier and cabin class: 1) Regular members have 0 free checked bags for basic economy, 1 for economy, and 2 for business. 2) Silver members have 1 free checked bag for basic economy, 2 for economy, and 3 for business. 3) Gold members have 2 free checked bags for basic economy, 3 for economy and business. An extra baggage fee of $50 applies for additional luggage.",
            "references": [
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. Each extra baggage is 50 dollars."
            ],
            "compliance_examples": [
              "A regular member books a business class flight with 2 free checked bags for a single passenger.",
              "A gold member books an economy class flight with 3 free checked bags.",
              "A gold member books an economy class flight with 4 checked bags, where he pays for one and the other three are free.",
              "A silver member books a basic economy flight with 2 total checked bags, where 1 is free and 1 incurs a $50 additional fee.",
              "A silver member books a basic economy flight for three passengers asking for 5 bags, and pays for two of them.",
              "A regular member books a basic economy flight journey and opts not to check any free bags.",
              "A gold member books a basic economy flight journey and opts not to check any free bags."
            ],
            "violation_examples": [
              "A regular member books a flight in basic economy class with 1 free checked bag.",
              "A silver member attempts to book an economy class flight with 3 free checked bags.",
              "A gold member books a business class flight with 4 free checked bags.",
              "A silver member with one bag books a basic economy class flight and is charged for his single bag.",
              "A regular member books an economy class flight for one passenger with 2 free and 1 non-free checked bags, without incurring additional charges.",
              "A gold member reserves a basic economy ticket and receives 3 free checked bags.",
              "A gold member reserves a basic economy ticket for two passengers, asking for five free bags in total."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_book_reservation",
      "guard_file": {
        "file_name": "airline/book_reservation/guard_book_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.book_reservation.guard_user_id_and_user_profile_verification import guard_user_id_and_user_profile_verification\nfrom airline.book_reservation.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.book_reservation.guard_seats_are_available import guard_seats_are_available\nfrom airline.book_reservation.guard_passenger_information_completeness import guard_passenger_information_completeness\nfrom airline.book_reservation.guard_payment_method_restriction import guard_payment_method_restriction\nfrom airline.book_reservation.guard_checked_bag_allowance_by_membership_tier import guard_checked_bag_allowance_by_membership_tier\n\n\ndef guard_book_reservation(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance. \n    \"\"\"\n    \n    guard_user_id_and_user_profile_verification(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_flight_status_restrictions(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_seats_are_available(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_passenger_information_completeness(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_payment_method_restriction(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_checked_bag_allowance_by_membership_tier(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/book_reservation/guard_user_id_and_user_profile_verification.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_id_and_user_profile_verification(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Before invoking ToolX (BookReservation), make sure that the user's ID is correctly obtained. After verifying the user ID, gather necessary booking information such as trip type, origin, and destination prior to making the reservation using ToolX.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_flight_status_restrictions.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_flight_status_restrictions(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, \n                                      flight_type: Literal['round_trip', 'one_way'], \n                                      cabin: Literal['business', 'economy', 'basic_economy'], \n                                      flights: list[FlightInfo | dict], passengers: list[Passenger | dict], \n                                      payment_methods: list[Payment | dict], total_baggages: int, \n                                      nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Flights chosen for booking using ToolX must have the status 'available' to ensure that they have not taken off. \n    Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Iterate over each flight to check its status\n    for flight in flights:\n        # Ensure flight is a FlightInfo object\n        if isinstance(flight, dict):\n            flight = FlightInfo(**flight)\n        \n        # Retrieve the flight status using the API\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n        \n        # Check if the flight status is not 'available'\n        if flight_status not in ['available']:\n            raise PolicyViolationException(f\"Flight {flight.flight_number} on {flight.date} has status '{flight_status}' which is not allowed for booking.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_seats_are_available.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_seats_are_available(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, \n                              flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], \n                              flights: list[FlightInfo | dict], passengers: list[Passenger | dict], \n                              payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, \n                              insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    num_passengers = len(passengers)\n\n    for flight in flights:\n        # Ensure flight is a FlightInfo object\n        if isinstance(flight, dict):\n            flight = FlightInfo(**flight)\n\n        # Get flight status\n        flight_status = api.get_flight_instance(flight.flight_number, flight.date)\n\n        # Check if the flight is available\n        if flight_status.status != 'available':\n            raise PolicyViolationException(f\"Flight {flight.flight_number} on {flight.date} is not available.\")\n\n        # Check available seats in the specified cabin\n        available_seats = flight_status.available_seats.get(cabin, 0)\n        if available_seats < num_passengers:\n            raise PolicyViolationException(f\"Not enough available seats in {cabin} class for flight {flight.flight_number} on {flight.date}.\")\n\n        # Check if prices are listed\n        if cabin not in flight_status.prices:\n            raise PolicyViolationException(f\"Prices not listed for {cabin} class on flight {flight.flight_number} on {flight.date}.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_passenger_information_completeness.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_passenger_information_completeness(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Check if the number of passengers exceeds the limit\n    if len(passengers) > 5:\n        raise PolicyViolationException(\"More than five passengers are not allowed.\")\n\n    # Check if there are no passengers\n    if len(passengers) == 0:\n        raise PolicyViolationException(\"At least one passenger is required.\")\n\n    # Check for completeness of each passenger's information\n    for passenger in passengers:\n        if isinstance(passenger, dict):\n            first_name = passenger.get('first_name')\n            last_name = passenger.get('last_name')\n            dob = passenger.get('dob')\n        else:\n            first_name = passenger.first_name\n            last_name = passenger.last_name\n            dob = passenger.dob\n\n        if not first_name:\n            raise PolicyViolationException(\"Passenger's first name is missing.\")\n        if not last_name:\n            raise PolicyViolationException(\"Passenger's last name is missing.\")\n        if not dob:\n            raise PolicyViolationException(\"Passenger's date of birth is missing.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_payment_method_restriction.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_restriction(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Ensure each reservation through BookReservation uses a maximum of one travel certificate, one credit card, and up to three gift cards. Verify that all payment methods are pre-registered in the user profile before proceeding with booking to maintain security and database integrity.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Retrieve user details to check pre-registered payment methods\n    user_details = api.get_user_details(user_id)\n    registered_payment_methods = user_details.payment_methods\n\n    # Counters for different payment methods\n    certificate_count = 0\n    credit_card_count = 0\n    gift_card_count = 0\n\n    # Check each payment method\n    for payment in payment_methods:\n        if isinstance(payment, Certificate):\n            certificate_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Certificate not registered in user profile.\")\n        elif isinstance(payment, CreditCard):\n            credit_card_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Credit card not registered in user profile.\")\n        elif isinstance(payment, GiftCard):\n            gift_card_count += 1\n            if payment.id not in registered_payment_methods:\n                raise PolicyViolationException(\"Gift card not registered in user profile.\")\n\n    # Validate the counts against policy\n    if certificate_count > 1:\n        raise PolicyViolationException(\"More than one travel certificate is not allowed.\")\n    if credit_card_count > 1:\n        raise PolicyViolationException(\"More than one credit card is not allowed.\")\n    if gift_card_count > 3:\n        raise PolicyViolationException(\"More than three gift cards are not allowed.\")"
        },
        {
          "file_name": "airline/book_reservation/guard_checked_bag_allowance_by_membership_tier.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_checked_bag_allowance_by_membership_tier(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The checked bag allowance policy for booking a reservation varies by membership tier and cabin class: \n    1) Regular members have 0 free checked bags for basic economy, 1 for economy, and 2 for business. \n    2) Silver members have 1 free checked bag for basic economy, 2 for economy, and 3 for business. \n    3) Gold members have 2 free checked bags for basic economy, 3 for economy and business. \n    An extra baggage fee of $50 applies for additional luggage.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Retrieve user details to determine membership tier\n    user_details = api.get_user_details(user_id)\n    membership_tier = user_details.membership\n\n    # Define free baggage allowance based on membership tier and cabin class\n    free_baggage_allowance = {\n        'regular': {'basic_economy': 0, 'economy': 1, 'business': 2},\n        'silver': {'basic_economy': 1, 'economy': 2, 'business': 3},\n        'gold': {'basic_economy': 2, 'economy': 3, 'business': 3}\n    }\n\n    # Calculate allowed free baggage\n    allowed_free_bags = free_baggage_allowance[membership_tier][cabin]\n\n    # Check if the number of free bags exceeds the allowed limit\n    if total_baggages - nonfree_baggages > allowed_free_bags:\n        raise PolicyViolationException(f\"Exceeded free baggage allowance for {membership_tier} members in {cabin} class.\")\n\n    # Check if non-free baggage count matches the expected extra baggage\n    expected_nonfree_bags = total_baggages - allowed_free_bags\n    if nonfree_baggages != expected_nonfree_bags:\n        raise PolicyViolationException(\"Non-free baggage count does not match the expected extra baggage fee.\")\n\n    # Additional check for silver members in basic economy\n    if membership_tier == 'silver' and cabin == 'basic_economy' and total_baggages == 1 and nonfree_baggages == 0:\n        raise PolicyViolationException(\"Silver members with one bag in basic economy should be charged for the bag.\")"
        }
      ],
      "test_files": [
        null,
        {
          "file_name": "tests/book_reservation/test_guard_flight_status_restrictions.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_flight_status_restrictions import guard_flight_status_restrictions\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardFlightStatusRestrictions:\n\n    def test_compliance_booking_available_flight(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking using ToolX must have the status 'available'\"\n        Example: \"A user requests to book a flight from SFO to LAX on June 20th. The agent checks the flight information and confirms that the flight status is 'available' before proceeding with the booking using the BookReservation tool.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == \"FL123\" and date == \"2024-06-20\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-20\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        payment_methods = [Payment(payment_id=\"pay123\", amount=200)]\n\n        # Invoke function under test\n        guard_flight_status_restrictions(\n            history=history,\n            api=api,\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\n    def test_violation_booking_delayed_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to book a flight to New York on May 16th using the BookReservation tool. However, the flight status indicates 'delayed'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == \"FL456\" and date == \"2024-05-16\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL456\", date=\"2024-05-16\")]\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")]\n        payment_methods = [Payment(payment_id=\"pay456\", amount=300)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user456\",\n                origin=\"ATL\",\n                destination=\"NYC\",\n                flight_type=\"one_way\",\n                cabin=\"business\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_flying_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"An agent tries to book a reservation for a user on flight HAT007 from ATL to MIA. The API checks reveal that the flight's status is currently 'flying'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'flying' if flight_number == \"HAT007\" and date == \"2024-05-16\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"HAT007\", date=\"2024-05-16\")]\n        passengers = [Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1992-03-03\")]\n        payment_methods = [Payment(payment_id=\"pay789\", amount=400)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user789\",\n                origin=\"ATL\",\n                destination=\"MIA\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=3,\n                nonfree_baggages=2,\n                insurance=\"no\"\n            )\n\n    def test_violation_booking_on_time_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation request is made for a flight with the status 'on time'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'on time' if flight_number == \"FL789\" and date == \"2024-05-16\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL789\", date=\"2024-05-16\")]\n        passengers = [Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1988-07-07\")]\n        payment_methods = [Payment(payment_id=\"pay321\", amount=500)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user321\",\n                origin=\"LAX\",\n                destination=\"DFW\",\n                flight_type=\"round_trip\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=4,\n                nonfree_baggages=3,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_cancelled_flight(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A reservation is attempted for a flight where the status is 'cancelled'. Despite knowing that only flights with 'available' status can be booked, the agent proceeds, resulting in a policy breach.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'cancelled' if flight_number == \"FL654\" and date == \"2024-05-16\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL654\", date=\"2024-05-16\")]\n        passengers = [Passenger(first_name=\"Charlie\", last_name=\"Green\", dob=\"1995-09-09\")]\n        payment_methods = [Payment(payment_id=\"pay654\", amount=600)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user654\",\n                origin=\"LAX\",\n                destination=\"DFW\",\n                flight_type=\"round_trip\",\n                cabin=\"business\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=5,\n                nonfree_baggages=4,\n                insurance=\"no\"\n            )\n\n    def test_violation_booking_mixed_flight_status(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'delayed', and the second one is 'available'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'delayed' if flight_number == \"FL111\" and date == \"2024-05-16\" else 'available' if flight_number == \"FL222\" and date == \"2024-05-17\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL111\", date=\"2024-05-16\"), FlightInfo(flight_number=\"FL222\", date=\"2024-05-17\")]\n        passengers = [Passenger(first_name=\"David\", last_name=\"Black\", dob=\"1993-11-11\")]\n        payment_methods = [Payment(payment_id=\"pay111\", amount=700)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user111\",\n                origin=\"SFO\",\n                destination=\"LAX\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=6,\n                nonfree_baggages=5,\n                insurance=\"yes\"\n            )\n\n    def test_violation_booking_mixed_flight_status_reverse(self):\n        \"\"\"\n        Policy: \"Flights with status 'delayed', 'on time', or 'flying' cannot be booked.\"\n        Example: \"A user attempts to make a reservation with two flights. The first one's status is 'available', and the second one is 'delayed'.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        api.get_flight_status.side_effect = lambda flight_number, date: 'available' if flight_number == \"FL333\" and date == \"2024-05-16\" else 'delayed' if flight_number == \"FL444\" and date == \"2024-05-17\" else None\n\n        # Flight and passenger details\n        flights = [FlightInfo(flight_number=\"FL333\", date=\"2024-05-16\"), FlightInfo(flight_number=\"FL444\", date=\"2024-05-17\")]\n        passengers = [Passenger(first_name=\"Eve\", last_name=\"Blue\", dob=\"1991-12-12\")]\n        payment_methods = [Payment(payment_id=\"pay333\", amount=800)]\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_flight_status_restrictions(\n                history=history,\n                api=api,\n                user_id=\"user333\",\n                origin=\"SFO\",\n                destination=\"LAX\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=7,\n                nonfree_baggages=6,\n                insurance=\"no\"\n            )\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_seats_are_available.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_seats_are_available import guard_seats_are_available\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardSeatsAreAvailable:\n\n    def test_compliance_booking_economy_class(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\"\n        Example: \"A user requests to book a flight from SFO to LAX on June 20th in economy class. The flight status is 'available' and there are 21 available seats\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock the API\n        api = MagicMock(spec=I_Airline)\n        flight_status = FlightDateStatusAvailable(status='available', available_seats={'economy': 21}, prices={'economy': 300})\n        api.get_flight_instance.side_effect = lambda flight_number, date: flight_status if flight_number == \"FL123\" and date == \"2024-06-20\" else None\n\n        flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-06-20\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        payment_methods = [Payment(payment_id=\"pay123\", amount=300)]\n\n        # invoke function under test\n        guard_seats_are_available(history, api, user_id=\"user123\", origin=\"SFO\", destination=\"LAX\", flight_type=\"one_way\", cabin=\"economy\", flights=flights, passengers=passengers, payment_methods=payment_methods, total_baggages=1, nonfree_baggages=0, insurance=\"no\")\n\n    def test_violation_not_enough_seats(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\"\n        Example: \"A user attempts to book a flight to New York on May 16th for 5 passengers in business class, however only 4 seats are available on this flight\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock the API\n        api = MagicMock(spec=I_Airline)\n        flight_status = FlightDateStatusAvailable(status='available', available_seats={'business': 4}, prices={'business': 1000})\n        api.get_flight_instance.side_effect = lambda flight_number, date: flight_status if flight_number == \"FL456\" and date == \"2024-05-16\" else None\n\n        flights = [FlightInfo(flight_number=\"FL456\", date=\"2024-05-16\")]\n        passengers = [Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1985-05-05\") for _ in range(5)]\n        payment_methods = [Payment(payment_id=\"pay456\", amount=5000)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_seats_are_available(history, api, user_id=\"user456\", origin=\"SFO\", destination=\"JFK\", flight_type=\"one_way\", cabin=\"business\", flights=flights, passengers=passengers, payment_methods=payment_methods, total_baggages=5, nonfree_baggages=2, insurance=\"yes\")\n\n    def test_violation_no_available_seats_return_flight(self):\n        \"\"\"\n        Policy: \"Flights chosen for booking must have enough available seats for all passengers, and prices listed for booking.\"\n        Example: \"An agent attempts to book a round-trip from LAX to DFW for a user in economy cabin, the outgoing flight status is available, but there are no available seats in this cabin\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock the API\n        api = MagicMock(spec=I_Airline)\n        outgoing_flight_status = FlightDateStatusAvailable(status='available', available_seats={'economy': 10}, prices={'economy': 200})\n        return_flight_status = FlightDateStatusAvailable(status='available', available_seats={'economy': 0}, prices={'economy': 200})\n        api.get_flight_instance.side_effect = lambda flight_number, date: outgoing_flight_status if flight_number == \"FL789\" and date == \"2024-07-01\" else return_flight_status if flight_number == \"FL790\" and date == \"2024-07-10\" else None\n\n        flights = [FlightInfo(flight_number=\"FL789\", date=\"2024-07-01\"), FlightInfo(flight_number=\"FL790\", date=\"2024-07-10\")]\n        passengers = [Passenger(first_name=\"Bob\", last_name=\"Brown\", dob=\"1975-03-03\")]\n        payment_methods = [Payment(payment_id=\"pay789\", amount=400)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_seats_are_available(history, api, user_id=\"user789\", origin=\"LAX\", destination=\"DFW\", flight_type=\"round_trip\", cabin=\"economy\", flights=flights, passengers=passengers, payment_methods=payment_methods, total_baggages=1, nonfree_baggages=0, insurance=\"no\")\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_passenger_information_completeness.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_passenger_information_completeness import guard_passenger_information_completeness\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestPassengerInformationCompleteness:\n\n    def test_successful_passenger_information_collection(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"An agent successfully gathers and verifies all required passenger information including first name, last name, and date of birth for each of the five passengers.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\"),\n            Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1990-07-20\"),\n            Passenger(first_name=\"Emily\", last_name=\"Jones\", dob=\"1992-11-30\"),\n            Passenger(first_name=\"Michael\", last_name=\"Brown\", dob=\"1988-03-25\"),\n            Passenger(first_name=\"Jessica\", last_name=\"Taylor\", dob=\"1995-09-10\")\n        ]\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        guard_passenger_information_completeness(\n            history=history,\n            api=api,\n            user_id=\"sara_doe_496\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\n    def test_exceed_passenger_limit(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"An agent attempts to book a reservation using BookReservation for six passengers instead of the allowed maximum of five.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-05-15\"),\n            Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1990-07-20\"),\n            Passenger(first_name=\"Emily\", last_name=\"Jones\", dob=\"1992-11-30\"),\n            Passenger(first_name=\"Michael\", last_name=\"Brown\", dob=\"1988-03-25\"),\n            Passenger(first_name=\"Jessica\", last_name=\"Taylor\", dob=\"1995-09-10\"),\n            Passenger(first_name=\"Chris\", last_name=\"Wilson\", dob=\"1987-02-14\")\n        ]\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_passenger_information_completeness(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_missing_passenger_dob(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"An agent calls BookReservation with the passenger details incomplete, missing the date of birth for each passenger.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"\"),\n            Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"\"),\n            Passenger(first_name=\"Emily\", last_name=\"Jones\", dob=\"\"),\n            Passenger(first_name=\"Michael\", last_name=\"Brown\", dob=\"\"),\n            Passenger(first_name=\"Jessica\", last_name=\"Taylor\", dob=\"\")\n        ]\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_passenger_information_completeness(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_no_passengers(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"An agent attempts to book a reservation with no passengers.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = []\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_passenger_information_completeness(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_missing_first_name(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"Booking a reservation for one passenger with missing first name information.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = [Passenger(first_name=\"\", last_name=\"Doe\", dob=\"1985-05-15\")]\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_passenger_information_completeness(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_missing_last_name(self):\n        \"\"\"\n        Policy: \"Ensure all required passenger details are collected. Limit to five passengers per reservation, with details including first name, last name, and date of birth.\"\n        Example: \"Booking a reservation for one passenger with missing last name information.\"\n        \"\"\"\n        \n        # mock the history service:\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # mock other tools function return values \n        user = User(user_id=\"sara_doe_496\", name=Name(first_name=\"Sara\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"), email=\"sara.doe@example.com\", dob=\"1990-04-05\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        passengers = [Passenger(first_name=\"John\", last_name=\"\", dob=\"1985-05-15\")]\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n\n        # invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_passenger_information_completeness(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_payment_method_restriction.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_payment_method_restriction import guard_payment_method_restriction\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardPaymentMethodRestriction:\n\n    def test_single_credit_card_compliance(self):\n        \"\"\"\n        Policy: Ensure each reservation uses a maximum of one travel certificate, one credit card, and up to three gift cards.\n        Example: A reservation is made using a single credit card that is already registered in the user's profile.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n\n        user = User(\n            user_id=\"sara_doe_496\",\n            name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"),\n            email=\"sara.doe@example.com\",\n            dob=\"1990-04-05\",\n            payment_methods={\n                \"credit_card_1234\": CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_1234\")\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_1234\")]\n\n        try:\n            guard_payment_method_restriction(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"one_way\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n        except PolicyViolationException:\n            pytest.fail(\"Unexpected PolicyViolationException raised for compliant payment method.\")\n\n    def test_two_credit_cards_violation(self):\n        \"\"\"\n        Policy: Ensure each reservation uses a maximum of one travel certificate, one credit card, and up to three gift cards.\n        Example: A user attempts to book a reservation using two credit cards.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n\n        user = User(\n            user_id=\"sara_doe_496\",\n            name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"),\n            email=\"sara.doe@example.com\",\n            dob=\"1990-04-05\",\n            payment_methods={\n                \"credit_card_1234\": CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_1234\"),\n                \"credit_card_5678\": CreditCard(source=\"credit_card\", brand=\"mastercard\", last_four=\"5678\", id=\"credit_card_5678\")\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [\n            CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_1234\"),\n            CreditCard(source=\"credit_card\", brand=\"mastercard\", last_four=\"5678\", id=\"credit_card_5678\")\n        ]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_restriction(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"one_way\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n\n    def test_unregistered_payment_method_violation(self):\n        \"\"\"\n        Policy: Verify that all payment methods are pre-registered in the user profile before proceeding with booking.\n        Example: A user submits a booking request where the payment method includes a travel certificate not listed in the user profile.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n\n        user = User(\n            user_id=\"sara_doe_496\",\n            name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"),\n            email=\"sara.doe@example.com\",\n            dob=\"1990-04-05\",\n            payment_methods={\n                \"credit_card_1234\": CreditCard(source=\"credit_card\", brand=\"visa\", last_four=\"1234\", id=\"credit_card_1234\")\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"sara_doe_496\" else None\n\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [\n            Certificate(source=\"certificate\", amount=100.0, id=\"certificate_9999\")\n        ]\n\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_restriction(\n                history=history,\n                api=api,\n                user_id=\"sara_doe_496\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"one_way\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_checked_bag_allowance_by_membership_tier.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_checked_bag_allowance_by_membership_tier import guard_checked_bag_allowance_by_membership_tier\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardCheckedBagAllowanceByMembershipTier:\n\n    def test_regular_member_business_class_two_free_bags(self):\n        \"\"\"\n        Policy: \"Regular members have 2 free checked bags for business class.\"\n        Example: \"A regular member books a business class flight with 2 free checked bags for a single passenger.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"user123\", name=Name(first_name=\"John\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=\"\", city=\"Anytown\", country=\"USA\", state=\"CA\", zip=\"12345\"), email=\"john.doe@example.com\", dob=\"1990-01-01\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user123\" else None\n\n        flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        payment_methods = [Payment(payment_id=\"pay123\", amount=0)]\n\n        guard_checked_bag_allowance_by_membership_tier(\n            history=history,\n            api=api,\n            user_id=\"user123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\n    def test_regular_member_basic_economy_one_free_bag_violation(self):\n        \"\"\"\n        Policy: \"Regular members have 0 free checked bags for basic economy.\"\n        Example: \"A regular member books a flight in basic economy class with 1 free checked bag.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"user123\", name=Name(first_name=\"John\", last_name=\"Doe\"), address=Address(address1=\"123 Main St\", address2=\"\", city=\"Anytown\", country=\"USA\", state=\"CA\", zip=\"12345\"), email=\"john.doe@example.com\", dob=\"1990-01-01\", payment_methods={}, saved_passengers=[], membership=\"regular\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user123\" else None\n\n        flights = [FlightInfo(flight_number=\"FL123\", date=\"2024-05-01\")]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        payment_methods = [Payment(payment_id=\"pay123\", amount=0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_checked_bag_allowance_by_membership_tier(\n                history=history,\n                api=api,\n                user_id=\"user123\",\n                origin=\"SFO\",\n                destination=\"JFK\",\n                flight_type=\"one_way\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n\n    def test_gold_member_economy_four_checked_bags(self):\n        \"\"\"\n        Policy: \"Gold members have 3 free checked bags for economy class.\"\n        Example: \"A gold member books an economy class flight with 4 checked bags, where he pays for one and the other three are free.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"user456\", name=Name(first_name=\"Jane\", last_name=\"Smith\"), address=Address(address1=\"456 Elm St\", address2=\"\", city=\"Othertown\", country=\"USA\", state=\"NY\", zip=\"67890\"), email=\"jane.smith@example.com\", dob=\"1985-05-05\", payment_methods={}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user456\" else None\n\n        flights = [FlightInfo(flight_number=\"FL456\", date=\"2024-06-01\")]\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")]\n        payment_methods = [Payment(payment_id=\"pay456\", amount=50)]\n\n        guard_checked_bag_allowance_by_membership_tier(\n            history=history,\n            api=api,\n            user_id=\"user456\",\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=4,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\n    def test_silver_member_basic_economy_two_bags_violation(self):\n        \"\"\"\n        Policy: \"Silver members have 1 free checked bag for basic economy.\"\n        Example: \"A silver member with one bag books a basic economy class flight and is charged for his single bag.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"user789\", name=Name(first_name=\"Alice\", last_name=\"Johnson\"), address=Address(address1=\"789 Pine St\", address2=\"\", city=\"Sometown\", country=\"USA\", state=\"TX\", zip=\"54321\"), email=\"alice.johnson@example.com\", dob=\"1975-07-07\", payment_methods={}, saved_passengers=[], membership=\"silver\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user789\" else None\n\n        flights = [FlightInfo(flight_number=\"FL789\", date=\"2024-07-01\")]\n        passengers = [Passenger(first_name=\"Alice\", last_name=\"Johnson\", dob=\"1975-07-07\")]\n        payment_methods = [Payment(payment_id=\"pay789\", amount=0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_checked_bag_allowance_by_membership_tier(\n                history=history,\n                api=api,\n                user_id=\"user789\",\n                origin=\"MIA\",\n                destination=\"ATL\",\n                flight_type=\"one_way\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n\n    def test_gold_member_basic_economy_three_free_bags_violation(self):\n        \"\"\"\n        Policy: \"Gold members have 2 free checked bags for basic economy.\"\n        Example: \"A gold member reserves a basic economy ticket and receives 3 free checked bags.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        user = User(user_id=\"user101\", name=Name(first_name=\"Bob\", last_name=\"Brown\"), address=Address(address1=\"101 Maple St\", address2=\"\", city=\"Newcity\", country=\"USA\", state=\"FL\", zip=\"98765\"), email=\"bob.brown@example.com\", dob=\"1980-08-08\", payment_methods={}, saved_passengers=[], membership=\"gold\", reservations=[])\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda user_id: user if user_id == \"user101\" else None\n\n        flights = [FlightInfo(flight_number=\"FL101\", date=\"2024-08-01\")]\n        passengers = [Passenger(first_name=\"Bob\", last_name=\"Brown\", dob=\"1980-08-08\")]\n        payment_methods = [Payment(payment_id=\"pay101\", amount=0)]\n\n        with pytest.raises(PolicyViolationException):\n            guard_checked_bag_allowance_by_membership_tier(\n                history=history,\n                api=api,\n                user_id=\"user101\",\n                origin=\"SEA\",\n                destination=\"DEN\",\n                flight_type=\"round_trip\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=3,\n                nonfree_baggages=0,\n                insurance=\"yes\"\n            )\n"
        }
      ]
    },
    "cancel_reservation": {
      "tool": {
        "tool_name": "cancel_reservation",
        "policy_items": [
          {
            "name": "Cancellation Policy for All Flights",
            "description": "To use the 'cancel_reservation' tool, confirm the following with the user: 1) The cancellation is within 24 hours of booking, 2) The airline cancelled the flight, 3) For economy class, cancellation is only allowed if travel insurance was purchased and qualifies, 4) Business class flights can be cancelled anytime. These conditions must be validated prior to invoking the tool.",
            "references": [
              "All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled. The rules are strict regardless of the membership status.",
              "The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!"
            ],
            "compliance_examples": [
              "An agent checks and confirms the reservation was made within 24 hours before invoking CancelReservation.",
              "For a basic economy reservation done 36 hours ago, and the user has purchased travel insurance for flight canceling.",
              "An agent verifies that the airline has cancelled the flight before proceeding with the CancelReservation call.",
              "A user requests the cancellation of an economy class reservation booked 18 hours ago.",
              "A user with a business class reservation requests cancellation for a reservation done 40 hours ago."
            ],
            "violation_examples": [
              "A user contacts support to cancel a reservation for an economy class ticket without having purchased travel insurance, and the booking was made more than 24 hours ago.",
              "A basic user requests a reservation cancellation 48 hours after purchase, without the airline canceling any flights and the reservation has no insurance."
            ]
          },
          {
            "name": "Cancellation of Entire Trips Only",
            "description": "Before using the CancelReservation tool, the agent should confirm that the entire trip is unused. If any flight segment has already been flown, the reservation cannot be canceled by the agent and should be escalated to a human agent.",
            "references": [
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "An agent receives a user request for cancellation and checks each flight segment to ensure none have been flown or taken off. After verifying that all segments are 'scheduled', the agent proceeds with the CancelReservation tool in compliance with the policy.",
              "Before calling the CancelReservation tool, the agent reviews the reservation details and confirms that all flight segments have a status of 'available' and none have been departed or used. The cancellation is then processed, adhering to the policy.",
              "The agent is asked to cancel a trip and confirms each segment of the reservation is still 'on time' with a future departure. After verifying no segments have flown, the agent processes the full cancellation successfully following policy guidelines.",
              "Upon a cancellation request, the agent checks reservation details and finds all flight segments under 'available' and none used. After this thorough validation against the policy requirements, the agent calls the CancelReservation tool.",
              "Upon receiving a cancellation request, the agent carefully reviews the reservation details and confirms that all flight segments have a status of 'delayed' but have not departed. Ensuring compliance, the agent proceeds with the cancellation.",
              "The agent is asked to cancel a reservation and verifies all flight segments are in 'scheduled' status. After ensuring that the segments are not flown and there's no discrepancy in status, the agent follows the policy and proceeds with the cancellation.",
              "A user requests cancellation for their trip, and the agent conducts a thorough check to confirm all segments are 'flying' but have not completed any leg. Ensuring no segments are considered 'used', the agent processes the request as per the policy's compliance.",
              "Before processing a cancellation, the agent confirms that the reservation details show all segments as 'on time', yet still at the gate. This early confirmation allows safe adherence to the policy, and the agent cancels the reservation.",
              "An agent receives a cancellation request and meticulously checks that all flight segments within the reservation have the status 'scheduled'. After confirming that no segments have been flown, the agent calls CancelReservation in line with the policy.",
              "Upon receiving a cancellation request, the agent validates that none of the flights have the status 'departed'. The agent confirms each segment reflects a 'scheduled' status before proceeding, thus adhering to the policy.",
              "Before initiating the cancellation, the agent calculates the latest status of all segments. All the flights show as 'scheduled', so with this confirmed safe status, the agent executes CancelReservation correctly.",
              "The agent evaluates the reservation and checks the flight records: all segments are confirmed as 'delayed', yet none have reached 'departed'. Confirming compliance, the agent proceeds with the complete cancellation.",
              "Before proceeding with the CancelReservation, the agent validates the flight details, confirming that all segments are currently marked 'scheduled' with no ongoing or completed statuses. This thorough check ensures adherence to the policy before executing the cancellation.",
              "An agent is tasked with a cancellation and conducts a comprehensive check of each flight segment status. Upon confirming all are marked 'available' and unflown, the agent complies with policy requirements by using the CancelReservation tool cleanly.",
              "The agent, upon receiving a request for cancellation, meticulously reviews the reservation, confirming that no part of the trip has been flown or is currently underway. This diligence complies with the policy, allowing safe execution of the CancelReservation tool.",
              "Upon receiving a cancellation request, the agent accesses each flight detail within the reservation, identifying all segments as 'scheduled' and unflown before aptly utilizing the CancelReservation tool according to policy.",
              "During a busy shift, the agent maintains rigor by validating every flight segment of a reservation as 'delayed but not departed' and adheres to the policy by confirming this before processing the cancellation."
            ],
            "violation_examples": [
              "An agent tries to call the CancelReservation tool without verifying the status of all flight segments in the reservation.",
              "The agent receives a request to cancel a trip, and while one of the segments shows a 'flying' status, the agent proceeds with CancelReservation.",
              "An agent cancels a reservation marking all segments as 'scheduled' without confirming their status. Post-cancellation, it is discovered that one segment was marked 'delayed' but has already departed, violating the policy that mandates confirming every segment before cancellation.",
              "The agent proceeds to call CancelReservation after only checking a subset of flight segments, assuming the others are unused. However, it is later revealed that this assumption was incorrect, as some segments were in 'departed' status, which violates the policy requiring complete verification.",
              "An agent falsely assumes that since the trip is set to occur in the future, none of the flights have been flown, and calls the CancelReservation tool. Upon review, one segment is found to have been flown, breaking the policy which requires a check prior to cancellation.",
              "An agent initiates the CancelReservation tool after only a brief glance at the reservation details, assuming that a delay means the segment hasn't departed when in actuality, the flight has taken off. This action violates the policy since all segments status must be verified accurately before cancellation.",
              "A user inquires about canceling a trip with multiple flight legs. The agent overlooks checking the status of each individual segment and proceeds with the cancellation based on user assurance, later finding one segment was flown, not complying with the policy guidelines.",
              "The agent immediately processes a cancellation request for a business class reservation without confirming if all flights are entirely unused. One flight being marked as 'on time' was actually close to takeoff, thus not adhering to the necessary policy to verify flight status before using the tool.",
              "The agent receives a user request to cancel a trip and skips over verifying the status of connecting flights that involve multiple airlines. It is later discovered that one of the connecting segments had already taken off, violating the policy of confirming each segment\u2019s status before cancellation.",
              "An agent attempts to process a cancellation request for a very complex itinerary involving multiple layovers and accidentally misses a segment that had changed status to 'departed'. This oversight breaches the policy's requirement that no flown segments be present before using the CancelReservation tool.",
              "Facing a high volume of requests, an agent decides to batch process cancellations, inadvertently including a reservation where one of the segments was 'flying', thus violating the requirement to transfer such cases to a human agent."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_cancel_reservation",
      "guard_file": {
        "file_name": "airline/cancel_reservation/guard_cancel_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.cancel_reservation.guard_cancellation_policy_for_all_flights import guard_cancellation_policy_for_all_flights\nfrom airline.cancel_reservation.guard_cancellation_of_entire_trips_only import guard_cancellation_of_entire_trips_only\n\n\ndef guard_cancel_reservation(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n         \n    \"\"\"\n    \n    guard_cancellation_policy_for_all_flights(history, api, reservation_id)\n    guard_cancellation_of_entire_trips_only(history, api, reservation_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/cancel_reservation/guard_cancellation_policy_for_all_flights.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cancellation_policy_for_all_flights(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Policy to check: To use the 'cancel_reservation' tool, confirm the following with the user: \n    1) The cancellation is within 24 hours of booking, \n    2) The airline cancelled the flight, \n    3) For economy class, cancellation is only allowed if travel insurance was purchased and qualifies, \n    4) Business class flights can be cancelled anytime. \n    These conditions must be validated prior to invoking the tool.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n    \"\"\"\n    reservation = api.get_reservation_details(reservation_id)\n    \n    # Check if cancellation is within 24 hours of booking\n    from datetime import datetime, timedelta\n    booking_time = datetime.strptime(reservation.created_at, \"%Y-%m-%dT%H:%M:%S\")\n    if datetime.now() - booking_time <= timedelta(hours=24):\n        return\n    \n    # Check if the airline cancelled the flight\n    for flight in reservation.flights:\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n        if flight_status == 'cancelled':\n            return\n    \n    # Check economy class cancellation policy\n    if reservation.cabin in ['economy', 'basic_economy']:\n        if reservation.insurance == 'yes':\n            return\n        else:\n            raise PolicyViolationException(\"Economy class cancellation requires travel insurance.\")\n    \n    # Business class can be cancelled anytime\n    if reservation.cabin == 'business':\n        return\n    \n    # If none of the conditions are met, raise an exception\n    raise PolicyViolationException(\"Cancellation policy conditions not met.\")"
        },
        {
          "file_name": "airline/cancel_reservation/guard_cancellation_of_entire_trips_only.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\n\ndef guard_cancellation_of_entire_trips_only(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Policy to check: Before using the CancelReservation tool, the agent should confirm that the entire trip is unused. If any flight segment has already been flown, the reservation cannot be canceled by the agent and should be escalated to a human agent.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n    \"\"\"\n    # Retrieve reservation details using the API\n    reservation = api.get_reservation_details(reservation_id)\n\n    # Check each flight segment in the reservation\n    for flight in reservation.flights:\n        # Get the status of each flight segment\n        flight_status = api.get_flight_status(flight.flight_number, flight.date)\n\n        # If any flight segment has already been flown, raise a PolicyViolationException\n        if flight_status in ['landed', 'flying', 'departed']:\n            raise PolicyViolationException(\"The reservation cannot be canceled as one or more flight segments have already been flown.\")\n\n        # Ensure all segments are confirmed as 'scheduled' or 'available'\n        if flight_status not in ['scheduled', 'available', 'on time', 'delayed']:\n            raise PolicyViolationException(\"The reservation cannot be canceled as one or more flight segments are not in a valid status for cancellation.\")"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/cancel_reservation/test_guard_cancellation_policy_for_all_flights.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_cancellation_policy_for_all_flights import guard_cancellation_policy_for_all_flights\nfrom airline.i_airline import *\nfrom airline.airline_types import *\n\n\ndef test_cancellation_within_24_hours():\n    \"\"\"\n    Policy: \"The cancellation is within 24 hours of booking\"\n    Example: \"An agent checks and confirms the reservation was made within 24 hours before invoking CancelReservation.\"\n    \"\"\"\n    \n    # Mock the history service\n    history = MagicMock()\n    history.ask_bool.return_value = True\n\n    # Mock the API\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"JFK\", destination=\"LAX\", date=\"2024-05-01\", price=300)],\n        passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n        payment_history=[Payment(payment_id=\"pay123\", amount=300)],\n        created_at=(datetime.now() - timedelta(hours=23)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n    # Invoke function under test\n    guard_cancellation_policy_for_all_flights(history, api, \"ZFA04Y\")\n\n\ndef test_cancellation_without_insurance_economy_class():\n    \"\"\"\n    Policy: \"For economy class, cancellation is only allowed if travel insurance was purchased and qualifies\"\n    Example: \"A user contacts support to cancel a reservation for an economy class ticket without having purchased travel insurance, and the booking was made more than 24 hours ago.\"\n    \"\"\"\n    \n    # Mock the history service\n    history = MagicMock()\n    history.ask_bool.return_value = True\n\n    # Mock the API\n    reservation = Reservation(\n        reservation_id=\"ZFA04Y\",\n        user_id=\"user123\",\n        origin=\"JFK\",\n        destination=\"LAX\",\n        flight_type=\"one_way\",\n        cabin=\"economy\",\n        flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"JFK\", destination=\"LAX\", date=\"2024-05-01\", price=300)],\n        passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n        payment_history=[Payment(payment_id=\"pay123\", amount=300)],\n        created_at=(datetime.now() - timedelta(hours=48)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        total_baggages=1,\n        nonfree_baggages=0,\n        insurance=\"no\",\n        status=None\n    )\n\n    api = MagicMock(spec=I_Airline)\n    api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n\n    # Invoke function under test\n    with pytest.raises(PolicyViolationException):\n        guard_cancellation_policy_for_all_flights(history, api, \"ZFA04Y\")\n"
        },
        {
          "file_name": "tests/cancel_reservation/test_guard_cancellation_of_entire_trips_only.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_cancellation_of_entire_trips_only import guard_cancellation_of_entire_trips_only\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardCancellationOfEntireTripsOnly:\n\n    def test_compliance_all_segments_scheduled(self):\n        \"\"\"\n        Policy: \"Before using the CancelReservation tool, the agent should confirm that the entire trip is unused.\"\n        Example: \"An agent receives a user request for cancellation and checks each flight segment to ensure none have been flown or taken off.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"AA123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-05-01\", price=300)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"scheduled\" if flight_number == \"AA123\" and date == \"2024-05-01\" else \"unknown\"\n\n        # Invoke function under test\n        guard_cancellation_of_entire_trips_only(history, api, \"ZFA04Y\")\n\n    def test_violation_segment_flying(self):\n        \"\"\"\n        Policy: \"If any flight segment has already been flown, the reservation cannot be canceled by the agent.\"\n        Example: \"The agent receives a request to cancel a trip, and while one of the segments shows a 'flying' status, the agent proceeds with CancelReservation.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"AA123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-05-01\", price=300)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"flying\" if flight_number == \"AA123\" and date == \"2024-05-01\" else \"unknown\"\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_cancellation_of_entire_trips_only(history, api, \"ZFA04Y\")\n\n    def test_violation_segment_departed(self):\n        \"\"\"\n        Policy: \"If any flight segment has already been flown, the reservation cannot be canceled by the agent.\"\n        Example: \"An agent cancels a reservation marking all segments as 'scheduled' without confirming their status.\"\n        \"\"\"\n        \n        # Mock the history service\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock the API\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"AA123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-05-01\", price=300)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        api.get_flight_status.side_effect = lambda flight_number, date: \"departed\" if flight_number == \"AA123\" and date == \"2024-05-01\" else \"unknown\"\n\n        # Invoke function under test\n        with pytest.raises(PolicyViolationException):\n            guard_cancellation_of_entire_trips_only(history, api, \"ZFA04Y\")\n"
        }
      ]
    }
  }
}