{
  "domain": {
    "app_name": "airline",
    "toolguard_common": {
      "file_name": "rt_toolguard/data_types.py",
      "content": "from abc import ABC, abstractmethod\nimport os\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import Any, List, Optional\n\nDEBUG_DIR = \"debug\"\nTESTS_DIR = \"tests\"\nRESULTS_FILENAME = \"result.json\"\nHISTORY_PARAM = \"history\"\nHISTORY_PARAM_TYPE = \"ChatHistory\"\nAPI_PARAM = \"api\"\n\nclass FileTwin(BaseModel):\n    file_name: str\n    content: str\n\n    def save(self, folder:str)->'FileTwin':\n        full_path = os.path.join(folder, self.file_name)\n        parent = Path(full_path).parent\n        os.makedirs(parent, exist_ok=True)\n        with open(full_path, \"w\") as file:\n            file.write(self.content)\n        return self\n\n    def save_as(self, folder:str, file_name:str)->'FileTwin':\n        file_path = os.path.join(folder, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(self.content)\n        return FileTwin(file_name=file_name, content=self.content)\n\n    @staticmethod\n    def load_from(folder:str, file_path:str)->'FileTwin':\n        with open(os.path.join(folder, file_path), \"r\") as file:\n            data = file.read()\n            return FileTwin(\n                file_name=file_path, \n                content=data\n            )\n\nclass ToolPolicyItem(BaseModel):\n    name: str = Field(..., description=\"Policy item name\")\n    description: str = Field(..., description=\"Policy item description\")\n    references: List[str] = Field(..., description=\"original texts\")\n    compliance_examples: Optional[List[str]] = Field(..., description=\"Example of cases that comply with the policy\")\n    violation_examples: Optional[List[str]] = Field(..., description=\"Example of cases that violate the policy\")\n\n    def to_md_bulltets(self, items: List[str])->str:\n        s = \"\"\n        for item in items:\n            s+=f\"* {item}\\n\"\n        return s\n    \n    def __str__(self) -> str:\n        s = f\"#### Policy item \" + self.name + \"\\n\"\n        s += f\"{self.description}\\n\"\n        if self.compliance_examples:\n            s += f\"##### Positive examples\\n{self.to_md_bulltets(self.compliance_examples)}\"\n        if self.violation_examples:\n            s += f\"##### Negative examples\\n{self.to_md_bulltets(self.violation_examples)}\"\n        return s\n\nclass ToolPolicy(BaseModel):\n    tool_name: str = Field(..., description=\"Name of the tool\")\n    policy_items: List[ToolPolicyItem] = Field(..., description=\"Policy items. All (And logic) policy items must hold whehn invoking the tool.\")\n\nclass Domain(BaseModel):\n    app_name: str = Field(..., description=\"Application name\")\n    toolguard_common: FileTwin = Field(..., description=\"Pydantic data types used by toolguard framework.\")\n    app_types: FileTwin = Field(..., description=\"Data types defined used in the application API as payloads.\")\n    app_api_class_name: str = Field(..., description=\"Name of the API class name.\")\n    app_api: FileTwin = Field(..., description=\"Python class (abstract) containing all the API signatures.\")\n    app_api_size: int = Field(..., description=\"Number of functions in the API\")\n\nclass RuntimeDomain(Domain):\n    app_api_impl_class_name: str = Field(..., description=\"Python class (implementaton) class name.\")\n    app_api_impl: FileTwin = Field(..., description=\"Python class containing all the API method implementations.\")\n\nclass ChatHistory(ABC):\n    \"\"\"Represents a history of chat messages and provides methods check if specific events already happened.\"\"\"\n\n    @abstractmethod\n    def ask_bool(self, question:str)->bool:\n        \"\"\"\n        Asks a yes/no question and returns the response as a boolean.\n\n        Args:\n            question (str): The yes/no question to be asked. Example: \"Did the user accepted the agent's proposal?\"\n\n        Returns:\n            bool: The interpreted boolean response from the language model.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def did_tool_return_value(self, tool_name:str, expected_value:Any)->bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history and validates if the expected value was returned\n            Example: \"did_tool_return_value(\"book_hotel\",True) checks if the history shows calling the function book_hotel and if the returned value was true did_tool_return_value will return true else false\n        \n        Args:\n            tool_name (str): The name of the tool to check for in the message history.\n            expected_value: The expected value of the tool call.\n        \n        Returns:\n            bool: True if the tool was called returning expected_value, False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def was_tool_called(self, tool_name: str) -> bool:\n        \"\"\"\n        Checks whether a specific tool was called in the chat history.\n\t\tArgs:\n\t\t\ttool_name (str): The name of the tool to check for in the message history.\n\t\tReturns:\n\t\t\tbool: True if the tool was called, False otherwise.\n\t\t\"\"\"\n        pass\n\n\nclass PolicyViolationException(Exception):\n    _msg: str\n    def __init__(self, message:str):\n        super().__init__(message)\n        self._msg = message\n\n    @property\n    def message(self):\n        return self._msg\n"
    },
    "app_types": {
      "file_name": "airline/airline_types.py",
      "content": "# Auto-generated type definitions\nfrom enum import Enum\nfrom abc import ABC\nfrom typing import *\nfrom pydantic import BaseModel, Field\n\nclass FlightBase(BaseModel):\n    flight_number: str  # Unique flight identifier\n    origin: str  # IATA code for origin airport\n    destination: str  # IATA code for destination airport\n\nclass Address(BaseModel):\n    address1: str  # Primary address line\n    address2: Optional[str]  # Secondary address line (optional)\n    city: str  # City name\n    country: str  # Country name\n    state: str  # State or province name\n    zip: str  # Postal code\n\nclass FlightDateStatusAvailable(BaseModel):\n    status: Literal['available']  # Indicates flight is available for booking\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass FlightDateStatusCancelled(BaseModel):\n    status: Literal['cancelled']  # Indicates flight was cancelled\n\nclass PaymentMethodBase(BaseModel):\n    source: str  # Type of payment method\n    id: str  # Unique identifier for the payment method\n\nclass FlightDateStatusLanded(BaseModel):\n    status: Literal['landed']  # Indicates flight has landed\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    actual_arrival_time_est: str  # Actual arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightInfo(BaseModel):\n    flight_number: str  # Flight number, such as 'HAT001'.\n    date: str  # The date for the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n\nclass FlightDataStatusFlying(BaseModel):\n    status: Literal['flying']  # Indicates flight is in flight\n    actual_departure_time_est: str  # Actual departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass AirportCode(BaseModel):\n    iata: str  # IATA code\n    city: str  # City name\n\nclass FlightDataStatusOnTime(BaseModel):\n    status: Literal['on time']  # Indicates flight is on time\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass FlightDateStatusDelayed(BaseModel):\n    status: Literal['delayed']  # Indicates flight was delayed\n    estimated_departure_time_est: str  # Estimated departure time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T06:04:00\n    estimated_arrival_time_est: str  # Estimated arrival time in EST in the format YYYY-MM-DDTHH:MM:SS, e.g 2024-05-15T07:30:00\n\nclass Payment(BaseModel):\n    payment_id: str  # Unique identifier for the payment\n    amount: int  # Payment amount in dollars\n\nclass Passenger(BaseModel):\n    first_name: str  # Passenger's first name\n    last_name: str  # Passenger's last name\n    dob: str  # Date of birth in YYYY-MM-DD format\n\nclass Name(BaseModel):\n    first_name: str  # The person's first name\n    last_name: str  # The person's last name\n\nclass DirectFlight(FlightBase):\n    status: Literal['available']  # Indicates flight is available for booking\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    date: Optional[str]  # Flight date in YYYY-MM-DD format\n    available_seats: dict[Literal['business', 'economy', 'basic_economy'], int]  # Available seats by class\n    prices: dict[Literal['business', 'economy', 'basic_economy'], int]  # Current prices by class\n\nclass ReservationFlight(FlightBase):\n    date: str  # Flight date in YYYY-MM-DD format\n    price: int  # Flight price in dollars.\n\nclass GiftCard(PaymentMethodBase):\n    source: Literal['gift_card']  # Indicates this is a gift card payment method\n    amount: float  # Gift card value amount\n    id: str  # Unique identifier for the gift card\n\nclass CreditCard(PaymentMethodBase):\n    source: Literal['credit_card']  # Indicates this is a credit card payment method\n    brand: str  # Credit card brand (e.g., visa, mastercard)\n    last_four: str  # Last four digits of the credit card\n\nclass Certificate(PaymentMethodBase):\n    source: Literal['certificate']  # Indicates this is a certificate payment method\n    amount: float  # Certificate value amount\n\nclass Flight(FlightBase):\n    scheduled_departure_time_est: str  # Scheduled departure time in EST in the format HH:MM:SS, e.g 06:00:00\n    scheduled_arrival_time_est: str  # Scheduled arrival time in EST in the format HH:MM:SS, e.g 07:00:00\n    dates: dict[str, Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]]  # Flight status by date (YYYY-MM-DD)\n\nclass Reservation(BaseModel):\n    reservation_id: str  # Unique identifier for the reservation\n    user_id: str  # ID of the user who made the reservation\n    origin: str  # IATA code for trip origin\n    destination: str  # IATA code for trip destination\n    flight_type: Literal['round_trip', 'one_way']  # Type of trip\n    cabin: Literal['business', 'economy', 'basic_economy']  # Selected cabin class\n    flights: list[ReservationFlight]  # List of flights in the reservation\n    passengers: list[Passenger]  # List of passengers on the reservation\n    payment_history: list[Payment]  # History of payments for this reservation\n    created_at: str  # Timestamp when reservation was created in the format YYYY-MM-DDTHH:MM:SS\n    total_baggages: int  # Total number of bags in reservation\n    nonfree_baggages: int  # Number of paid bags in reservation\n    insurance: Literal['yes', 'no']  # Whether travel insurance was purchased\n    status: Optional[Literal['cancelled']]  # Status of the reservation\n\nclass User(BaseModel):\n    user_id: str  # Unique identifier for the user\n    name: Name  # User's full name\n    address: Address  # User's address information\n    email: str  # User's email address\n    dob: str  # User's date of birth in the format YYYY-MM-DD, e.g 1990-04-05\n    payment_methods: dict[str, Union[CreditCard, GiftCard, Certificate]]  # User's saved payment methods\n    saved_passengers: list[Passenger]  # User's saved passenger information\n    membership: Literal['gold', 'silver', 'regular']  # User's membership level\n    reservations: list[str]  # List of user's reservation IDs\n"
    },
    "app_api_class_name": "I_Airline",
    "app_api": {
      "file_name": "airline/i_airline.py",
      "content": "# Auto-generated class interface\nfrom typing import * # type: ignore\nfrom abc import ABC, abstractmethod\nfrom airline.airline_types import *\n\nclass I_Airline(ABC):\n\n    @abstractmethod\n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n        ...\n"
    },
    "app_api_size": 16,
    "app_api_impl_class_name": "Airlineimpl",
    "app_api_impl": {
      "file_name": "airline/airline_impl.py",
      "content": "# Auto-generated class\nfrom typing import *\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass Airlineimpl(I_Airline):\n\n    def __init__(self, delegate: I_Airline):\n        self._delegate = delegate\n    \n    def book_reservation(self, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], passengers: list[Passenger| dict], payment_methods: list[Payment| dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']) -> Reservation:\n        \"\"\"\n        Book a reservation.\n        \n        Args:\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n        \"\"\"\n\n        return self._delegate.book_reservation(user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n\n\n    def calculate(self, expression: str) -> str:\n        \"\"\"\n        Calculate the result of a mathematical expression.\n        \n        Args:\n        expression: The mathematical expression to calculate, such as '2 + 2'. The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.\n        \n        Returns:\n        The result of the mathematical expression.\n        \n        Raises:\n        ValueError: If the expression is invalid.\n        \"\"\"\n\n        return self._delegate.calculate(expression)\n\n\n    def cancel_reservation(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Cancel the whole reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.cancel_reservation(reservation_id)\n\n\n    def get_flight_instance(self, flight_number: str, date: str) -> Union[FlightDateStatusAvailable, FlightDateStatusLanded, FlightDateStatusCancelled, FlightDateStatusDelayed, FlightDataStatusFlying, FlightDataStatusOnTime]:\n        \"\"\"\n        Get the flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_instance(flight_number, date)\n\n\n    def get_flight_status(self, flight_number: str, date: str) -> Literal['available', 'on time', 'flying', 'cancelled', 'delayed', 'landed']:\n        \"\"\"\n        Get the status of a flight.\n        \n        Args:\n        flight_number: The flight number.\n        date: The date of the flight.\n        \n        Returns:\n        The status of the flight.\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_flight_status(flight_number, date)\n\n\n    def get_reservation_details(self, reservation_id: str) -> Reservation:\n        \"\"\"\n        Get the details of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as '8JX2WO'.\n        \n        Returns:\n        The reservation details.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        \"\"\"\n\n        return self._delegate.get_reservation_details(reservation_id)\n\n\n    def get_scheduled_flight(self, flight_number: str) -> Flight:\n        \"\"\"\n        Get the flight schedule.\n        \n        Args:\n        flight_number: The flight number.\n        \n        Returns:\n        The flight schedule\n        \n        Raises:\n        ValueError: If the flight is not found.\n        \"\"\"\n\n        return self._delegate.get_scheduled_flight(flight_number)\n\n\n    def get_user_details(self, user_id: str) -> User:\n        \"\"\"\n        Get the details of a user, including their reservations.\n        \n        Args:\n        user_id: The user ID, such as 'sara_doe_496'.\n        \n        Returns:\n        The user details.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.get_user_details(user_id)\n\n\n    def list_all_airports(self) -> list[AirportCode]:\n        \"\"\"\n        Returns a list of all available airports.\n        \n        Returns:\n        A dictionary mapping IATA codes to AirportInfo objects.\n        \"\"\"\n\n        return self._delegate.list_all_airports()\n\n\n    def search_direct_flight(self, origin: str, destination: str, date: str) -> list[DirectFlight]:\n        \"\"\"\n        Search for direct flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-01-01'.\n        \n        Returns:\n        The direct flights between the two cities on the specific date.\n        \"\"\"\n\n        return self._delegate.search_direct_flight(origin, destination, date)\n\n\n    def search_onestop_flight(self, origin: str, destination: str, date: str) -> list[tuple[DirectFlight, DirectFlight]]:\n        \"\"\"\n        Search for one-stop flights between two cities on a specific date.\n        \n        Args:\n        origin: The origin city airport in three letters, such as 'JFK'.\n        destination: The destination city airport in three letters, such as 'LAX'.\n        date: The date of the flight in the format 'YYYY-MM-DD', such as '2024-05-01'.\n        \n        Returns:\n        A list of pairs of DirectFlight objects.\n        \"\"\"\n\n        return self._delegate.search_onestop_flight(origin, destination, date)\n\n\n    def send_certificate(self, user_id: str, amount: int) -> str:\n        \"\"\"\n        Send a certificate to a user. Be careful!\n        \n        Args:\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n        \n        Returns:\n        A message indicating the certificate was sent.\n        \n        Raises:\n        ValueError: If the user is not found.\n        \"\"\"\n\n        return self._delegate.send_certificate(user_id, amount)\n\n\n    def transfer_to_human_agents(self, summary: str) -> str:\n        \"\"\"\n        Transfer the user to a human agent, with a summary of the user's issue.\n        Only transfer if\n        -  the user explicitly asks for a human agent\n        -  given the policy and the available tools, you cannot solve the user's issue.\n        \n        Args:\n        summary: A summary of the user's issue.\n        \n        Returns:\n        A message indicating the user has been transferred to a human agent.\n        \"\"\"\n\n        return self._delegate.transfer_to_human_agents(summary)\n\n\n    def update_reservation_baggages(self, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str) -> Reservation:\n        \"\"\"\n        Update the baggage information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_baggages(reservation_id, total_baggages, nonfree_baggages, payment_id)\n\n\n    def update_reservation_flights(self, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo| dict], payment_id: str) -> Reservation:\n        \"\"\"\n        Update the flight information of a reservation.\n        \n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the user is not found.\n        ValueError: If the payment method is not found.\n        ValueError: If the certificate cannot be used to update reservation.\n        ValueError: If the gift card balance is not enough.\n        \"\"\"\n\n        return self._delegate.update_reservation_flights(reservation_id, cabin, flights, payment_id)\n\n\n    def update_reservation_passengers(self, reservation_id: str, passengers: list[Passenger| dict]) -> Reservation:\n        \"\"\"\n        Update the passenger information of a reservation.\n        \n        Args:\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n        \n        Returns:\n        The updated reservation.\n        \n        Raises:\n        ValueError: If the reservation is not found.\n        ValueError: If the number of passengers does not match.\n        \"\"\"\n\n        return self._delegate.update_reservation_passengers(reservation_id, passengers)\n\n"
    }
  },
  "tools": {
    "book_reservation": {
      "tool": {
        "tool_name": "book_reservation",
        "policy_items": [
          {
            "name": "User Confirmation Before Database Update",
            "description": "Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before finalizing a new reservation for Emily, including flight details, passenger names, and baggage information, the system displays all changes to Emily and obtains her explicit 'yes' confirmation to proceed with the booking.",
              "Jane wants to change her seat to economy class and add an additional baggage item to her reservation. The system provides a detailed summary of these changes and asks Jane to confirm with a 'yes' before proceeding.",
              "While updating passenger details and flight preference for Michael's trip, the system presents all updates to him clearly and requests a 'yes' confirmation to ensure understanding and agreement before making any database changes.",
              "George received a notice about his frequent flyer miles being used for an upgrade to business class; the system displays the upgrade details and asks George for an explicit 'yes' confirmation before applying the change.",
              "Anna reviews the summary of her amended flight itinerary and cabin upgrade. The system awaits her verbal confirmation of 'yes' before making any updates to her reservation in the database.",
              "Before executing a booking for Tom's round-trip flight and adding travel insurance, the system presents all reservation details and secures a 'yes' confirmation from Tom before proceeding.",
              "Lisa wants to adjust her travel itinerary by changing the flight type to one-way and removing insurance coverage. The system displays these proposed updates and requires Lisa to confirm with a 'yes' before finalizing the changes.",
              "During the reservation process for Kevin's flight, which includes preferences for basic economy cabin and payment method adjustments, the system details all intended changes and obtains Kevin's affirmative 'yes' to proceed."
            ],
            "violation_examples": [
              "The system attempts to book a reservation and update the flight details without displaying them to the user first. John does not get the chance to review or confirm these changes before they are applied. It proceeds without obtaining an affirmative 'yes' from John.",
              "The system updates the number of non-free baggage items directly based on the user's preferences without explicitly asking for a 'yes' confirmation. This violates the policy by not requesting confirmation before making database changes.",
              "After Sarah requests an upgrade to business class for her flight reservation, the system processes the upgrade without sending her a summary of the changes and obtaining her confirmation. This fails to meet the user confirmation requirement.",
              "Tom modifies passenger information for his upcoming flight, yet the system saves these updates without showing Tom the new passenger details and without an affirmative 'yes' from him. This action violates user confirmation policy.",
              "The computer applies changes to Mark's reservation for round-trip flights and edits to baggage allowance based on a prior conversation but fails to explicitly ask for confirmation from Mark before updating the database. This contradicts the policy's confirmation mandate.",
              "Rachel wants to book a flight from LAX to JFK with a cabin upgrade, but the system updates her reservation without displaying changes and fails to obtain explicit 'yes' confirmation. This violates policy requirements on user confirmation.",
              "The system processes a reservation update for David's flight details after he selects new departure times but does not display these changes or ask for David's approval before applying them. Lacking explicit confirmation is a violation.",
              "After Nancy requests additional baggage and a change in passenger details, the system performs these updates without listing them for her and without requesting a 'yes' confirmation. This breaches the user confirmation policy."
            ]
          },
          {
            "name": "Flight Passenger Limit for Booking",
            "description": "A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.",
            "references": [
              "Passengers: Each reservation can have at most five passengers. The agent needs to collect the first name, last name, and date of birth for each passenger. All passengers must fly the same flights in the same cabin."
            ],
            "compliance_examples": [
              "Booking for three passengers: John Doe, Jane Smith, and Alex Murphy, all flying economy class from JFK to SFO with identical flight segments, fits the maximum passenger limit and same flight itinerary requirement.",
              "A reservation for five passengers, all flying from SFO to JFK in basic economy, with collected details including first name, last name, and date of birth for each passenger, adheres to the policy's constraints.",
              "Booking for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown from JFK to LAX in business class, all having the exact flight itinerary and cabin. This meets the policy requirements for passenger limits and identical flight itineraries.",
              "Two passengers, John Doe and Jane Smith, fly together on a round_trip from SFO to MIA in economy class, maintaining identical flight itineraries and cabin, complying with the policy.",
              "One reservation for four passengers all flying from SFO to JFK in basic economy class, with first name, last name, and date of birth collected for each. The reservation complies with passenger limits and identical flight requirements."
            ],
            "violation_examples": [
              "A reservation is attempted for six passengers: John Doe, Jane Smith, Alex Murphy, Ella Brown, Chris Davis, and Emily White, which exceeds the maximum allowed five passengers per reservation.",
              "A reservation is made for four passengers: John Doe, Jane Smith, Alex Murphy, and Ella Brown, with John flying business class and the others flying economy. Cabin classes must be the same for all passengers within a reservation.",
              "Three passengers, John Doe, Jane Smith, and Alex Murphy, have different flight itineraries: John and Jane are flying from JFK to SFO, and Alex is flying from LAX to SFO. All passengers must share the same flight itinerary.",
              "Booking for two passengers, John Doe and Jane Smith, with different flight types: John on a 'one_way' ticket and Jane on a 'round_trip' ticket. Flight types must be identical among passengers in the reservation.",
              "A reservation for five passengers includes one passenger flying only part of the shared flight itinerary. All passengers are required to fly all shared flights together."
            ]
          },
          {
            "name": "Payment Method Limits in Booking",
            "description": "Each reservation can use at most one travel certificate, one credit card, and three gift cards.",
            "references": [
              "<p>Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons.</p>"
            ],
            "compliance_examples": [
              "A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.",
              "Booking a trip with one credit card and one gift card, complying perfectly with the policy by using no travel certificates.",
              "A booking that utilizes one travel certificate and three gift cards but no credit card, fitting within the acceptable boundaries.",
              "A reservation uses exactly one credit card and no other forms of payment, showing compliance with guidelines.",
              "A reservation is booked using one travel certificate, two gift cards, and no credit card. This adheres to the policy's restrictions on payment use by staying within the boundaries for each method."
            ],
            "violation_examples": [
              "A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.",
              "A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.",
              "Attempting to book a flight using one travel certificate and four gift cards, which breaches the limit on gift cards.",
              "A user uses two credit cards, exceeding the number allowed per reservation.",
              "An attempt is made to book a reservation using zero travel certificates, three credit cards, and four gift cards, violating the restriction on both credit card and gift card quantities."
            ]
          },
          {
            "name": "User ID Requirement for Flight Booking",
            "description": "The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.",
            "references": [
              "The agent must first obtain the user id, then ask for the trip type, origin, destination."
            ],
            "compliance_examples": [
              "The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.",
              "User ID is obtained and validated first, followed by inquiries about flight type, cabin class, and insurance coverage, maintaining the correct sequence as per policy.",
              "Upon confirming the user's ID, such as 'sara_doe_496', the agent systematically handles inquiries about flight specifics, ensuring compliance through verification of user ID first."
            ],
            "violation_examples": [
              "The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.",
              "Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.",
              "The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy."
            ]
          },
          {
            "name": "Prohibition on Modifying User's Passenger Count",
            "description": "The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.",
            "references": [
              "<p>The",
              "user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "An agent updates passengers' details such as name spelling, date of birth, or contact information without changing the established number of passengers in the reservation.",
              "Agent makes changes to existing passenger preferences like seat, dietary needs, or passport details while keeping the passenger count unchanged, demonstrating compliance with the policy.",
              "The agent modifies information such as language preference or special assistance needs for existing reservation passengers, maintaining the originally specified number of passengers."
            ],
            "violation_examples": [
              "An agent attempts to alter the number of passengers in a reservation by changing the count, such as from 2 to 3, violating the policy of immutability on passenger count.",
              "The reservation system allows an agent to add or remove passengers, such as reducing the passenger count established from 5 to 4, thereby violating the no-alteration policy.",
              "Without user consent, the agent modifies the passenger count from the initially scheduled 3 passengers to 2, which goes against the policy of maintaining a fixed passenger count."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_book_reservation",
      "guard_file": {
        "file_name": "airline/book_reservation/guard_book_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.book_reservation.guard_user_confirmation_before_database_update import guard_user_confirmation_before_database_update\nfrom airline.book_reservation.guard_flight_passenger_limit_for_booking import guard_flight_passenger_limit_for_booking\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.book_reservation.guard_prohibition_on_modifying_user_s_passenger_count import guard_prohibition_on_modifying_user_s_passenger_count\n\n\ndef guard_book_reservation(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance. \n    \"\"\"\n    \n    guard_user_confirmation_before_database_update(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_flight_passenger_limit_for_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_payment_method_limits_in_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_user_id_requirement_for_flight_booking(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n    guard_prohibition_on_modifying_user_s_passenger_count(history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/book_reservation/guard_user_confirmation_before_database_update.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_confirmation_before_database_update(\n    history: ChatHistory,\n    api: I_Airline,\n    user_id: str,\n    origin: str,\n    destination: str,\n    flight_type: Literal['round_trip', 'one_way'],\n    cabin: Literal['business', 'economy', 'basic_economy'],\n    flights: list[FlightInfo | dict],\n    passengers: list[Passenger | dict],\n    payment_methods: list[Payment | dict],\n    total_baggages: int,\n    nonfree_baggages: int,\n    insurance: Literal['yes', 'no']\n):\n    \"\"\"\n    Policy to check: Ensure that before using ToolX for database updates related to booking a reservation, changing flight details, passenger information, baggage edits, or cabin upgrades, you must present the details of these actions to the user and obtain a clear affirmative confirmation ('yes') from the user before proceeding.\n\n    This guard checks that explicit user confirmation ('yes') was obtained before proceeding with any database update action.\n    If confirmation is missing, a PolicyViolationException is raised.\n    \"\"\"\n    # Ask the chat history if the user has given an explicit 'yes' confirmation for the presented details\n    confirmed = history.ask_bool(\n        \"Did the user give an explicit 'yes' confirmation after being presented with all details of the intended booking or update action?\"\n    )\n    if not confirmed:\n        raise PolicyViolationException(\n            \"Explicit user confirmation ('yes') was not obtained before performing a database update.\"\n        )\n"
        },
        {
          "file_name": "airline/book_reservation/guard_flight_passenger_limit_for_booking.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_passenger_limit_for_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: A flight reservation can have at most five passengers, and all must fly the same flights in the same cabin.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/book_reservation/guard_payment_method_limits_in_booking.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_limits_in_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n    All payment methods must already be in user profile for safety reasons.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    # Count payment method types\n    certificate_count = 0\n    credit_card_count = 0\n    gift_card_count = 0\n    payment_ids = set()\n    for pm in payment_methods:\n        # Accept both dict and Payment objects\n        source = pm.get('source') if isinstance(pm, dict) else getattr(pm, 'source', None)\n        payment_id = pm.get('id') if isinstance(pm, dict) else getattr(pm, 'payment_id', None)\n        if source == 'certificate':\n            certificate_count += 1\n        elif source == 'credit_card':\n            credit_card_count += 1\n        elif source == 'gift_card':\n            gift_card_count += 1\n        # Collect payment ids for user profile check\n        if payment_id:\n            payment_ids.add(payment_id)\n        else:\n            # Try fallback for id field in GiftCard/Certificate/CreditCard\n            fallback_id = pm.get('id') if isinstance(pm, dict) else getattr(pm, 'id', None)\n            if fallback_id:\n                payment_ids.add(fallback_id)\n    # Policy checks\n    if certificate_count > 1:\n        raise PolicyViolationException(\"At most one travel certificate is allowed per reservation.\")\n    if credit_card_count > 1:\n        raise PolicyViolationException(\"At most one credit card is allowed per reservation.\")\n    if gift_card_count > 3:\n        raise PolicyViolationException(\"At most three gift cards are allowed per reservation.\")\n    # Check all payment methods are in user profile\n    user = api.get_user_details(user_id)\n    user_payment_ids = set(user.payment_methods.keys())\n    if not payment_ids.issubset(user_payment_ids):\n        raise PolicyViolationException(\"All payment methods must already be in user profile.\")\n"
        },
        {
          "file_name": "airline/book_reservation/guard_user_id_requirement_for_flight_booking.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_user_id_requirement_for_flight_booking(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\n\n    This guard ensures that the user_id is present and valid before allowing booking or any related inquiries.\n    If user_id is missing or empty, a PolicyViolationException is raised.\n    \"\"\"\n    # Check that user_id is provided and is a non-empty string\n    if not user_id or not isinstance(user_id, str) or user_id.strip() == \"\":\n        raise PolicyViolationException(\"User ID must be obtained before proceeding with flight booking or related inquiries.\")\n    # Optionally, check that the user_id exists in the backend\n    try:\n        api.get_user_details(user_id)\n    except Exception:\n        raise PolicyViolationException(f\"User ID '{user_id}' is not valid or does not exist.\")\n"
        },
        {
          "file_name": "airline/book_reservation/guard_prohibition_on_modifying_user_s_passenger_count.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_prohibition_on_modifying_user_s_passenger_count(history: ChatHistory, api: I_Airline, user_id: str, origin: str, destination: str, flight_type: Literal['round_trip', 'one_way'], cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], passengers: list[Passenger | dict], payment_methods: list[Payment | dict], total_baggages: int, nonfree_baggages: int, insurance: Literal['yes', 'no']):\n    \"\"\"\n    Policy to check: The agent must not alter the number of passengers in a reservation once established, though modifications to passenger details like name or date of birth are allowed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation such as 'sara_doe_496'`.\n        origin: The IATA code for the origin city such as 'SFO'.\n        destination: The IATA code for the destination city such as 'JFK'.\n        flight_type: The type of flight such as 'one_way' or 'round_trip'.\n        cabin: The cabin class such as 'basic_economy', 'economy', or 'business'.\n        flights: An array of objects containing details about each piece of flight.\n        passengers: An array of objects containing details about each passenger.\n        payment_methods: An array of objects containing details about each payment method.\n        total_baggages: The total number of baggage items to book the reservation.\n        nonfree_baggages: The number of non-free baggage items to book the reservation.\n        insurance: Whether the reservation has insurance.\n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/book_reservation/test_guard_user_confirmation_before_database_update.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_user_confirmation_before_database_update import guard_user_confirmation_before_database_update\nfrom airline.airline_types import FlightInfo, Passenger, Payment\nfrom airline.i_airline import I_Airline\n\nclass TestGuardUserConfirmationBeforeDatabaseUpdate:\n    def test_compliance_explicit_confirmation_before_booking(self):\n        \"\"\"\n        Policy: \"Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed.\"\n        Example: \"Before finalizing a new reservation for Emily, including flight details, passenger names, and baggage information, the system displays all changes to Emily and obtains her explicit 'yes' confirmation to proceed with the booking.\"\n        \"\"\"\n        # Mock chat history to simulate explicit 'yes' confirmation\n        history = MagicMock()\n        history.ask_bool.return_value = True\n\n        # Mock API (no tool dependencies for this policy)\n        api = MagicMock(spec=I_Airline)\n\n        # Populate all required fields\n        user_id = \"emily_123\"\n        origin = \"SFO\"\n        destination = \"JFK\"\n        flight_type = \"round_trip\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT001\", date=(datetime.now() + timedelta(days=7)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Emily\", last_name=\"Stone\", dob=\"1990-04-05\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n        total_baggages = 2\n        nonfree_baggages = 1\n        insurance = \"yes\"\n\n        # Should NOT raise exception\n        try:\n            guard_user_confirmation_before_database_update(\n                history, api, user_id, origin, destination, flight_type, cabin,\n                flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_violation_no_confirmation_before_booking(self):\n        \"\"\"\n        Policy: \"Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed.\"\n        Example: \"The system attempts to book a reservation and update the flight details without displaying them to the user first. John does not get the chance to review or confirm these changes before they are applied. It proceeds without obtaining an affirmative 'yes' from John.\"\n        \"\"\"\n        # Mock chat history to simulate NO confirmation\n        history = MagicMock()\n        history.ask_bool.return_value = False\n\n        api = MagicMock(spec=I_Airline)\n\n        user_id = \"john_456\"\n        origin = \"LAX\"\n        destination = \"ORD\"\n        flight_type = \"one_way\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT002\", date=(datetime.now() + timedelta(days=10)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1985-09-12\")]\n        payment_methods = [Payment(payment_id=\"pay_002\", amount=800)]\n        total_baggages = 1\n        nonfree_baggages = 1\n        insurance = \"no\"\n\n        with pytest.raises(PolicyViolationException):\n            guard_user_confirmation_before_database_update(\n                history, api, user_id, origin, destination, flight_type, cabin,\n                flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n\n    def test_compliance_confirmation_before_baggage_edit(self):\n        \"\"\"\n        Policy: \"Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed.\"\n        Example: \"Jane wants to change her seat to economy class and add an additional baggage item to her reservation. The system provides a detailed summary of these changes and asks Jane to confirm with a 'yes' before proceeding.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        user_id = \"jane_789\"\n        origin = \"SEA\"\n        destination = \"BOS\"\n        flight_type = \"one_way\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT003\", date=(datetime.now() + timedelta(days=5)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1992-11-23\")]\n        payment_methods = [Payment(payment_id=\"pay_003\", amount=300)]\n        total_baggages = 2\n        nonfree_baggages = 2\n        insurance = \"no\"\n        try:\n            guard_user_confirmation_before_database_update(\n                history, api, user_id, origin, destination, flight_type, cabin,\n                flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_violation_no_confirmation_on_baggage_update(self):\n        \"\"\"\n        Policy: \"Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed.\"\n        Example: \"The system updates the number of non-free baggage items directly based on the user's preferences without explicitly asking for a 'yes' confirmation. This violates the policy by not requesting confirmation before making database changes.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False\n        api = MagicMock(spec=I_Airline)\n        user_id = \"mike_321\"\n        origin = \"ATL\"\n        destination = \"DEN\"\n        flight_type = \"round_trip\"\n        cabin = \"basic_economy\"\n        flights = [FlightInfo(flight_number=\"HAT004\", date=(datetime.now() + timedelta(days=3)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Mike\", last_name=\"Brown\", dob=\"1988-07-15\")]\n        payment_methods = [Payment(payment_id=\"pay_004\", amount=200)]\n        total_baggages = 3\n        nonfree_baggages = 3\n        insurance = \"yes\"\n        with pytest.raises(PolicyViolationException):\n            guard_user_confirmation_before_database_update(\n                history, api, user_id, origin, destination, flight_type, cabin,\n                flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n"
        },
        null,
        {
          "file_name": "tests/book_reservation/test_guard_payment_method_limits_in_booking.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_payment_method_limits_in_booking import guard_payment_method_limits_in_booking\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestGuardPaymentMethodLimitsInBooking:\n    # --- Compliance Examples ---\n\n    def test_one_certificate_one_credit_two_gift_cards(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A reservation where the user uses one travel certificate, one credit card, and two gift cards, adhering to the payment method limits.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_001\"\n        # Mock get_user_details to return a user with all payment methods\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Sara\", last_name=\"Doe\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94105\"),\n            email=\"sara@example.com\",\n            dob=\"1990-01-01\",\n            payment_methods={\n                \"cert1\": Certificate(source=\"certificate\", id=\"cert1\", amount=200.0),\n                \"cc1\": CreditCard(source=\"credit_card\", id=\"cc1\", brand=\"visa\", last_four=\"1234\"),\n                \"gc1\": GiftCard(source=\"gift_card\", id=\"gc1\", amount=50.0),\n                \"gc2\": GiftCard(source=\"gift_card\", id=\"gc2\", amount=30.0),\n            },\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[]\n        )\n        payment_methods = [\n            Certificate(source=\"certificate\", id=\"cert1\", amount=200.0),\n            CreditCard(source=\"credit_card\", id=\"cc1\", brand=\"visa\", last_four=\"1234\"),\n            GiftCard(source=\"gift_card\", id=\"gc1\", amount=50.0),\n            GiftCard(source=\"gift_card\", id=\"gc2\", amount=30.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT001\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-01-01\")]\n        guard_payment_method_limits_in_booking(\n            history=history,\n            api=api,\n            user_id=user_id,\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\n    def test_one_credit_card_one_gift_card(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: Booking a trip with one credit card and one gift card, complying perfectly with the policy by using no travel certificates.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_002\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"John\", last_name=\"Smith\"),\n            address=Address(address1=\"456 Oak Ave\", address2=None, city=\"New York\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n            email=\"john@example.com\",\n            dob=\"1985-05-05\",\n            payment_methods={\n                \"cc2\": CreditCard(source=\"credit_card\", id=\"cc2\", brand=\"mastercard\", last_four=\"5678\"),\n                \"gc3\": GiftCard(source=\"gift_card\", id=\"gc3\", amount=60.0),\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n        payment_methods = [\n            CreditCard(source=\"credit_card\", id=\"cc2\", brand=\"mastercard\", last_four=\"5678\"),\n            GiftCard(source=\"gift_card\", id=\"gc3\", amount=60.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT002\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-05-05\")]\n        guard_payment_method_limits_in_booking(\n            history=history,\n            api=api,\n            user_id=user_id,\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\n    def test_one_certificate_three_gift_cards(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A booking that utilizes one travel certificate and three gift cards but no credit card, fitting within the acceptable boundaries.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_003\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Alice\", last_name=\"Lee\"),\n            address=Address(address1=\"789 Pine Rd\", address2=None, city=\"Chicago\", country=\"USA\", state=\"IL\", zip=\"60601\"),\n            email=\"alice@example.com\",\n            dob=\"1992-07-15\",\n            payment_methods={\n                \"cert2\": Certificate(source=\"certificate\", id=\"cert2\", amount=150.0),\n                \"gc4\": GiftCard(source=\"gift_card\", id=\"gc4\", amount=40.0),\n                \"gc5\": GiftCard(source=\"gift_card\", id=\"gc5\", amount=25.0),\n                \"gc6\": GiftCard(source=\"gift_card\", id=\"gc6\", amount=35.0),\n            },\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[]\n        )\n        payment_methods = [\n            Certificate(source=\"certificate\", id=\"cert2\", amount=150.0),\n            GiftCard(source=\"gift_card\", id=\"gc4\", amount=40.0),\n            GiftCard(source=\"gift_card\", id=\"gc5\", amount=25.0),\n            GiftCard(source=\"gift_card\", id=\"gc6\", amount=35.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT003\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Alice\", last_name=\"Lee\", dob=\"1992-07-15\")]\n        guard_payment_method_limits_in_booking(\n            history=history,\n            api=api,\n            user_id=user_id,\n            origin=\"ORD\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\"\n        )\n\n    def test_one_credit_card_only(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A reservation uses exactly one credit card and no other forms of payment, showing compliance with guidelines.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_004\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Bob\", last_name=\"Brown\"),\n            address=Address(address1=\"321 Cedar St\", address2=None, city=\"Seattle\", country=\"USA\", state=\"WA\", zip=\"98101\"),\n            email=\"bob@example.com\",\n            dob=\"1980-12-12\",\n            payment_methods={\n                \"cc3\": CreditCard(source=\"credit_card\", id=\"cc3\", brand=\"amex\", last_four=\"4321\"),\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n        payment_methods = [\n            CreditCard(source=\"credit_card\", id=\"cc3\", brand=\"amex\", last_four=\"4321\"),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT004\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Bob\", last_name=\"Brown\", dob=\"1980-12-12\")]\n        guard_payment_method_limits_in_booking(\n            history=history,\n            api=api,\n            user_id=user_id,\n            origin=\"SEA\",\n            destination=\"DEN\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=1,\n            nonfree_baggages=1,\n            insurance=\"yes\"\n        )\n\n    def test_one_certificate_two_gift_cards(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A reservation is booked using one travel certificate, two gift cards, and no credit card. This adheres to the policy's restrictions on payment use by staying within the boundaries for each method.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_005\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Eve\", last_name=\"White\"),\n            address=Address(address1=\"654 Spruce Ln\", address2=None, city=\"Boston\", country=\"USA\", state=\"MA\", zip=\"02108\"),\n            email=\"eve@example.com\",\n            dob=\"1995-03-03\",\n            payment_methods={\n                \"cert3\": Certificate(source=\"certificate\", id=\"cert3\", amount=100.0),\n                \"gc7\": GiftCard(source=\"gift_card\", id=\"gc7\", amount=20.0),\n                \"gc8\": GiftCard(source=\"gift_card\", id=\"gc8\", amount=15.0),\n            },\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[]\n        )\n        payment_methods = [\n            Certificate(source=\"certificate\", id=\"cert3\", amount=100.0),\n            GiftCard(source=\"gift_card\", id=\"gc7\", amount=20.0),\n            GiftCard(source=\"gift_card\", id=\"gc8\", amount=15.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT005\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Eve\", last_name=\"White\", dob=\"1995-03-03\")]\n        guard_payment_method_limits_in_booking(\n            history=history,\n            api=api,\n            user_id=user_id,\n            origin=\"BOS\",\n            destination=\"ATL\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=flights,\n            passengers=passengers,\n            payment_methods=payment_methods,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\"\n        )\n\n    # --- Violation Examples ---\n\n    def test_two_certificates_four_gift_cards_violation(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A user attempts to book a reservation using two travel certificates and four gift cards, exceeding the policy limits for each of these payment types.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_006\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Tom\", last_name=\"Green\"),\n            address=Address(address1=\"987 Maple Dr\", address2=None, city=\"Austin\", country=\"USA\", state=\"TX\", zip=\"73301\"),\n            email=\"tom@example.com\",\n            dob=\"1988-08-08\",\n            payment_methods={\n                \"cert4\": Certificate(source=\"certificate\", id=\"cert4\", amount=120.0),\n                \"cert5\": Certificate(source=\"certificate\", id=\"cert5\", amount=80.0),\n                \"gc9\": GiftCard(source=\"gift_card\", id=\"gc9\", amount=10.0),\n                \"gc10\": GiftCard(source=\"gift_card\", id=\"gc10\", amount=15.0),\n                \"gc11\": GiftCard(source=\"gift_card\", id=\"gc11\", amount=20.0),\n                \"gc12\": GiftCard(source=\"gift_card\", id=\"gc12\", amount=25.0),\n            },\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[]\n        )\n        payment_methods = [\n            Certificate(source=\"certificate\", id=\"cert4\", amount=120.0),\n            Certificate(source=\"certificate\", id=\"cert5\", amount=80.0),\n            GiftCard(source=\"gift_card\", id=\"gc9\", amount=10.0),\n            GiftCard(source=\"gift_card\", id=\"gc10\", amount=15.0),\n            GiftCard(source=\"gift_card\", id=\"gc11\", amount=20.0),\n            GiftCard(source=\"gift_card\", id=\"gc12\", amount=25.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT006\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Tom\", last_name=\"Green\", dob=\"1988-08-08\")]\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(\n                history=history,\n                api=api,\n                user_id=user_id,\n                origin=\"AUS\",\n                destination=\"PHX\",\n                flight_type=\"one_way\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=1,\n                insurance=\"no\"\n            )\n\n    def test_three_credit_cards_violation(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A reservation is attempted using a combination of three credit cards, violating the policy as only one credit card is permitted per reservation.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_007\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Linda\", last_name=\"Black\"),\n            address=Address(address1=\"246 Elm St\", address2=None, city=\"Dallas\", country=\"USA\", state=\"TX\", zip=\"75201\"),\n            email=\"linda@example.com\",\n            dob=\"1975-11-11\",\n            payment_methods={\n                \"cc4\": CreditCard(source=\"credit_card\", id=\"cc4\", brand=\"visa\", last_four=\"1111\"),\n                \"cc5\": CreditCard(source=\"credit_card\", id=\"cc5\", brand=\"mastercard\", last_four=\"2222\"),\n                \"cc6\": CreditCard(source=\"credit_card\", id=\"cc6\", brand=\"amex\", last_four=\"3333\"),\n            },\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[]\n        )\n        payment_methods = [\n            CreditCard(source=\"credit_card\", id=\"cc4\", brand=\"visa\", last_four=\"1111\"),\n            CreditCard(source=\"credit_card\", id=\"cc5\", brand=\"mastercard\", last_four=\"2222\"),\n            CreditCard(source=\"credit_card\", id=\"cc6\", brand=\"amex\", last_four=\"3333\"),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT007\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Linda\", last_name=\"Black\", dob=\"1975-11-11\")]\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(\n                history=history,\n                api=api,\n                user_id=user_id,\n                origin=\"DFW\",\n                destination=\"LAS\",\n                flight_type=\"round_trip\",\n                cabin=\"business\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_one_certificate_four_gift_cards_violation(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: Attempting to book a flight using one travel certificate and four gift cards, which breaches the limit on gift cards.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_008\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Sam\", last_name=\"Blue\"),\n            address=Address(address1=\"135 Willow Way\", address2=None, city=\"Miami\", country=\"USA\", state=\"FL\", zip=\"33101\"),\n            email=\"sam@example.com\",\n            dob=\"1993-09-09\",\n            payment_methods={\n                \"cert6\": Certificate(source=\"certificate\", id=\"cert6\", amount=90.0),\n                \"gc13\": GiftCard(source=\"gift_card\", id=\"gc13\", amount=10.0),\n                \"gc14\": GiftCard(source=\"gift_card\", id=\"gc14\", amount=15.0),\n                \"gc15\": GiftCard(source=\"gift_card\", id=\"gc15\", amount=20.0),\n                \"gc16\": GiftCard(source=\"gift_card\", id=\"gc16\", amount=25.0),\n            },\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[]\n        )\n        payment_methods = [\n            Certificate(source=\"certificate\", id=\"cert6\", amount=90.0),\n            GiftCard(source=\"gift_card\", id=\"gc13\", amount=10.0),\n            GiftCard(source=\"gift_card\", id=\"gc14\", amount=15.0),\n            GiftCard(source=\"gift_card\", id=\"gc15\", amount=20.0),\n            GiftCard(source=\"gift_card\", id=\"gc16\", amount=25.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT008\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sam\", last_name=\"Blue\", dob=\"1993-09-09\")]\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(\n                history=history,\n                api=api,\n                user_id=user_id,\n                origin=\"MIA\",\n                destination=\"SEA\",\n                flight_type=\"one_way\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=0,\n                nonfree_baggages=0,\n                insurance=\"no\"\n            )\n\n    def test_two_credit_cards_violation(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: A user uses two credit cards, exceeding the number allowed per reservation.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_009\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Nina\", last_name=\"Gray\"),\n            address=Address(address1=\"753 Birch Blvd\", address2=None, city=\"Denver\", country=\"USA\", state=\"CO\", zip=\"80202\"),\n            email=\"nina@example.com\",\n            dob=\"1982-02-02\",\n            payment_methods={\n                \"cc7\": CreditCard(source=\"credit_card\", id=\"cc7\", brand=\"visa\", last_four=\"4444\"),\n                \"cc8\": CreditCard(source=\"credit_card\", id=\"cc8\", brand=\"mastercard\", last_four=\"5555\"),\n            },\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[]\n        )\n        payment_methods = [\n            CreditCard(source=\"credit_card\", id=\"cc7\", brand=\"visa\", last_four=\"4444\"),\n            CreditCard(source=\"credit_card\", id=\"cc8\", brand=\"mastercard\", last_four=\"5555\"),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT009\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Nina\", last_name=\"Gray\", dob=\"1982-02-02\")]\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(\n                history=history,\n                api=api,\n                user_id=user_id,\n                origin=\"DEN\",\n                destination=\"BOS\",\n                flight_type=\"round_trip\",\n                cabin=\"economy\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=1,\n                nonfree_baggages=1,\n                insurance=\"yes\"\n            )\n\n    def test_zero_certificates_three_credit_cards_four_gift_cards_violation(self):\n        \"\"\"\n        Policy: Each reservation can use at most one travel certificate, one credit card, and three gift cards.\n        Example: An attempt is made to book a reservation using zero travel certificates, three credit cards, and four gift cards, violating the restriction on both credit card and gift card quantities.\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        user_id = \"user_010\"\n        api.get_user_details.return_value = User(\n            user_id=user_id,\n            name=Name(first_name=\"Oscar\", last_name=\"Red\"),\n            address=Address(address1=\"159 Aspen Ct\", address2=None, city=\"Portland\", country=\"USA\", state=\"OR\", zip=\"97201\"),\n            email=\"oscar@example.com\",\n            dob=\"1970-10-10\",\n            payment_methods={\n                \"cc9\": CreditCard(source=\"credit_card\", id=\"cc9\", brand=\"visa\", last_four=\"6666\"),\n                \"cc10\": CreditCard(source=\"credit_card\", id=\"cc10\", brand=\"mastercard\", last_four=\"7777\"),\n                \"cc11\": CreditCard(source=\"credit_card\", id=\"cc11\", brand=\"amex\", last_four=\"8888\"),\n                \"gc17\": GiftCard(source=\"gift_card\", id=\"gc17\", amount=10.0),\n                \"gc18\": GiftCard(source=\"gift_card\", id=\"gc18\", amount=15.0),\n                \"gc19\": GiftCard(source=\"gift_card\", id=\"gc19\", amount=20.0),\n                \"gc20\": GiftCard(source=\"gift_card\", id=\"gc20\", amount=25.0),\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[]\n        )\n        payment_methods = [\n            CreditCard(source=\"credit_card\", id=\"cc9\", brand=\"visa\", last_four=\"6666\"),\n            CreditCard(source=\"credit_card\", id=\"cc10\", brand=\"mastercard\", last_four=\"7777\"),\n            CreditCard(source=\"credit_card\", id=\"cc11\", brand=\"amex\", last_four=\"8888\"),\n            GiftCard(source=\"gift_card\", id=\"gc17\", amount=10.0),\n            GiftCard(source=\"gift_card\", id=\"gc18\", amount=15.0),\n            GiftCard(source=\"gift_card\", id=\"gc19\", amount=20.0),\n            GiftCard(source=\"gift_card\", id=\"gc20\", amount=25.0),\n        ]\n        flights = [FlightInfo(flight_number=\"HAT010\", date=datetime.now().strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Oscar\", last_name=\"Red\", dob=\"1970-10-10\")]\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_limits_in_booking(\n                history=history,\n                api=api,\n                user_id=user_id,\n                origin=\"PDX\",\n                destination=\"LAX\",\n                flight_type=\"one_way\",\n                cabin=\"business\",\n                flights=flights,\n                passengers=passengers,\n                payment_methods=payment_methods,\n                total_baggages=2,\n                nonfree_baggages=2,\n                insurance=\"no\"\n            )\n"
        },
        {
          "file_name": "tests/book_reservation/test_guard_user_id_requirement_for_flight_booking.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.book_reservation.guard_user_id_requirement_for_flight_booking import guard_user_id_requirement_for_flight_booking\nfrom airline.i_airline import *\nfrom airline.airline_types import *\nfrom datetime import datetime, timedelta\n\nclass TestGuardUserIdRequirementForFlightBooking:\n    \n    def test_compliance_user_id_asked_first(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent asks the user for their user ID before proceeding with any inquiries on trip type, origin, destination, passenger list, and payment methods, ensuring compliance.\"\n        \"\"\"\n        history = MagicMock()\n        # Simulate that user_id was obtained first\n        history.was_tool_called.return_value = True\n        api = MagicMock(spec=I_Airline)\n        user_id = \"sara_doe_496\"\n        origin = \"SFO\"\n        destination = \"JFK\"\n        flight_type = \"one_way\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT001\", date=(datetime.now() + timedelta(days=7)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n        total_baggages = 2\n        nonfree_baggages = 1\n        insurance = \"no\"\n        # Should not raise\n        try:\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n        except PolicyViolationException:\n            pytest.fail(\"User ID was obtained first, but PolicyViolationException was raised.\")\n\n    def test_compliance_user_id_validated_first(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"User ID is obtained and validated first, followed by inquiries about flight type, cabin class, and insurance coverage, maintaining the correct sequence as per policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = True\n        api = MagicMock(spec=I_Airline)\n        user_id = \"john_smith_123\"\n        origin = \"LAX\"\n        destination = \"ORD\"\n        flight_type = \"round_trip\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT002\", date=(datetime.now() + timedelta(days=10)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-08-15\")]\n        payment_methods = [Payment(payment_id=\"pay_002\", amount=1200)]\n        total_baggages = 1\n        nonfree_baggages = 0\n        insurance = \"yes\"\n        try:\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n        except PolicyViolationException:\n            pytest.fail(\"User ID was validated first, but PolicyViolationException was raised.\")\n\n    def test_compliance_user_id_confirmed_then_flight_details(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"Upon confirming the user's ID, such as 'sara_doe_496', the agent systematically handles inquiries about flight specifics, ensuring compliance through verification of user ID first.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = True\n        api = MagicMock(spec=I_Airline)\n        user_id = \"sara_doe_496\"\n        origin = \"SEA\"\n        destination = \"BOS\"\n        flight_type = \"one_way\"\n        cabin = \"basic_economy\"\n        flights = [FlightInfo(flight_number=\"HAT003\", date=(datetime.now() + timedelta(days=3)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [Payment(payment_id=\"pay_003\", amount=300)]\n        total_baggages = 0\n        nonfree_baggages = 0\n        insurance = \"no\"\n        try:\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n        except PolicyViolationException:\n            pytest.fail(\"User ID was confirmed first, but PolicyViolationException was raised.\")\n\n    def test_violation_proceed_without_user_id(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent proceeds to book a flight without first obtaining the user ID, starting inquiries directly with the trip type, origin, and destination, which violates the policy of collecting user ID first.\"\n        \"\"\"\n        history = MagicMock()\n        # Simulate that user_id was NOT obtained first\n        history.was_tool_called.return_value = False\n        api = MagicMock(spec=I_Airline)\n        user_id = \"\"\n        origin = \"SFO\"\n        destination = \"JFK\"\n        flight_type = \"one_way\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT001\", date=(datetime.now() + timedelta(days=7)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [Payment(payment_id=\"pay_001\", amount=500)]\n        total_baggages = 2\n        nonfree_baggages = 1\n        insurance = \"no\"\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n\n    def test_violation_payment_and_flight_without_user_id(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"Booking is initiated with discussions about payment methods, flight details, and cabin preferences without confirming the user ID beforehand, contrary to policy requirements.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = False\n        api = MagicMock(spec=I_Airline)\n        user_id = \"\"\n        origin = \"LAX\"\n        destination = \"ORD\"\n        flight_type = \"round_trip\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT002\", date=(datetime.now() + timedelta(days=10)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-08-15\")]\n        payment_methods = [Payment(payment_id=\"pay_002\", amount=1200)]\n        total_baggages = 1\n        nonfree_baggages = 0\n        insurance = \"yes\"\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n\n    def test_violation_insurance_and_baggage_without_user_id(self):\n        \"\"\"\n        Policy: \"The agent must first obtain the user ID before proceeding with flight booking and subsequent inquiries for trip type, origin, and destination.\"\n        Example: \"The agent asks for insurance preferences, baggage information, and passenger count directly without verifying the user ID at the start, failing to adhere to user ID sequence policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = False\n        api = MagicMock(spec=I_Airline)\n        user_id = \"\"\n        origin = \"SEA\"\n        destination = \"BOS\"\n        flight_type = \"one_way\"\n        cabin = \"basic_economy\"\n        flights = [FlightInfo(flight_number=\"HAT003\", date=(datetime.now() + timedelta(days=3)).strftime(\"%Y-%m-%d\"))]\n        passengers = [Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")]\n        payment_methods = [Payment(payment_id=\"pay_003\", amount=300)]\n        total_baggages = 0\n        nonfree_baggages = 0\n        insurance = \"no\"\n        with pytest.raises(PolicyViolationException):\n            guard_user_id_requirement_for_flight_booking(\n                history, api, user_id, origin, destination, flight_type, cabin, flights, passengers, payment_methods, total_baggages, nonfree_baggages, insurance\n            )\n"
        },
        null
      ]
    },
    "cancel_reservation": {
      "tool": {
        "tool_name": "cancel_reservation",
        "policy_items": [
          {
            "name": "Strict Cancellation Rules Enforcement",
            "description": "The policy requires ensuring compliance with the cancellation rules before using 'cancel_reservation'. Agents must check if reservations meet these conditions: cancelled by the airline, within 24 hours of booking, or if travel insurance applies due to health or weather. Partial cancellations are prohibited. Transfer to human agents if these rules cannot facilitate cancellation.",
            "references": [
              "All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled.",
              "The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!",
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.",
              "An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.",
              "The agent ensures a business flight reservation is entirely unused and then cancels it, complying with policy stipulations.",
              "An agent confirms health-related travel insurance applies to a reservation due to illness and proceeds to cancel, following policy guidelines.",
              "The agent checks and confirms all conditions are met for whole reservation cancellation since no flights have been used.",
              "An agent validates that a scheduled flight has been cancelled due to inclement weather and proceeds in line with policy requirements.",
              "The agent carefully checks the booking timestamp and confirms it is within the 24-hour cut-off before executing cancellation.",
              "The agent verifies that none of the reservation segments have been flown and checks travel insurance details before proceeding, ensuring adherence."
            ],
            "violation_examples": [
              "An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.",
              "An agent cancels a reservation for a basic economy flight without verifying if travel insurance applies due to health or weather conditions.",
              "The agent proceeds to cancel part of a reservation even when some segments have already been flown, which breaches the rule against partial cancellations.",
              "An agent attempts to cancel a reservation without validating reservation status, leading to cancellation of flown flight segments.",
              "An agent mistakenly cancels a reservation, ignoring policy specifics that business flights require insurance validation post 24 hours.",
              "An agent cancels a reservation based solely on the passenger's request without verifying if airline or insurance cancellation conditions apply."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_cancel_reservation",
      "guard_file": {
        "file_name": "airline/cancel_reservation/guard_cancel_reservation.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\n\n\ndef guard_cancel_reservation(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n         \n    \"\"\"\n    \n    guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/cancel_reservation/guard_strict_cancellation_rules_enforcement.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_strict_cancellation_rules_enforcement(history: ChatHistory, api: I_Airline, reservation_id: str):\n    \"\"\"\n    Enforces strict cancellation rules before allowing reservation cancellation.\n    Checks:\n    - Reservation must be cancelled by the airline, OR\n    - Reservation must be within 24 hours of booking, OR\n    - Travel insurance applies due to health or weather (for basic/economy), OR\n    - Business flights can always be cancelled if unused.\n    - Partial cancellations are prohibited (all segments must be unused).\n    If none of these are met, transfer to human agent is required.\n    Raises PolicyViolationException if policy is violated.\n    \"\"\"\n    # Get reservation details\n    try:\n        reservation = api.get_reservation_details(reservation_id)\n    except Exception as e:\n        raise PolicyViolationException(f\"Reservation not found: {e}\")\n\n    # Check if reservation is already cancelled\n    if reservation.status == 'cancelled':\n        raise PolicyViolationException(\"Reservation is already cancelled.\")\n\n    # Check if any flight segment has already been flown (partial cancellation prohibited)\n    for flight in reservation.flights:\n        flight_status = api.get_flight_instance(flight.flight_number, flight.date)\n        if getattr(flight_status, 'status', None) in ['landed', 'flying']:\n            raise PolicyViolationException(\"Partial cancellations are prohibited. Some segments have already been flown.\")\n\n    # Check if any flight was cancelled by the airline\n    airline_cancelled = any(getattr(api.get_flight_instance(flight.flight_number, flight.date), 'status', None) == 'cancelled' for flight in reservation.flights)\n    if airline_cancelled:\n        return  # Allowed to cancel\n\n    # Check if reservation is within 24 hours of booking\n    from datetime import datetime, timedelta\n    try:\n        created_at = datetime.strptime(reservation.created_at, \"%Y-%m-%dT%H:%M:%S\")\n    except Exception:\n        raise PolicyViolationException(\"Invalid reservation creation timestamp.\")\n    if datetime.utcnow() - created_at <= timedelta(hours=24):\n        return  # Allowed to cancel\n\n    # Check travel insurance for basic/economy flights\n    if reservation.cabin in ['basic_economy', 'economy']:\n        if reservation.insurance == 'yes':\n            # Health or weather condition must apply (ask history)\n            if history.ask_bool(\"Is the cancellation due to health or weather conditions?\"):\n                return  # Allowed to cancel\n            else:\n                raise PolicyViolationException(\"Travel insurance cancellation only allowed for health or weather reasons.\")\n        else:\n            raise PolicyViolationException(\"Basic/economy flights require travel insurance for cancellation after 24 hours.\")\n\n    # Business flights: can always be cancelled if unused\n    if reservation.cabin == 'business':\n        return  # Allowed to cancel\n\n    # If none of the above, transfer to human agent required\n    raise PolicyViolationException(\"Cancellation not allowed by policy. Please transfer to a human agent.\")\n"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/cancel_reservation/test_guard_strict_cancellation_rules_enforcement.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.cancel_reservation.guard_strict_cancellation_rules_enforcement import guard_strict_cancellation_rules_enforcement\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestStrictCancellationRulesEnforcement:\n    \n    def test_cancel_within_24_hours(self):\n        \"\"\"\n        Policy: \"All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled.\"\n        Example: \"An agent checks that a reservation was booked less than 24 hours ago and cancels it accordingly, ensuring compliance with the policy.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES123\"\n        created_at = (datetime.now() - timedelta(hours=2)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_1\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"FL123\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-10\", price=300)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[Payment(payment_id=\"PAY1\", amount=300)],\n            created_at=created_at,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        # Should not raise\n        try:\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Cancellation within 24 hours should be allowed. Exception: {e}\")\n\n    def test_cancelled_by_airline(self):\n        \"\"\"\n        Policy: \"All reservations can be cancelled within 24 hours of booking, or if the airline cancelled the flight. Otherwise, basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met, and business flights can always be cancelled.\"\n        Example: \"An agent verifies that a flight was cancelled by the airline before executing cancellation to comply with policy rules.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES456\"\n        created_at = (datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_2\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"FL456\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-11\", price=350)],\n            passengers=[Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")],\n            payment_history=[Payment(payment_id=\"PAY2\", amount=350)],\n            created_at=created_at,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusCancelled(status=\"cancelled\")\n        # Should not raise\n        try:\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Cancellation due to airline cancellation should be allowed. Exception: {e}\")\n\n    def test_business_flight_unused(self):\n        \"\"\"\n        Policy: \"Business flights can always be cancelled if unused.\"\n        Example: \"The agent ensures a business flight reservation is entirely unused and then cancels it, complying with policy stipulations.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES789\"\n        created_at = (datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_3\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"FL789\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-12\", price=1000)],\n            passengers=[Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1975-07-07\")],\n            payment_history=[Payment(payment_id=\"PAY3\", amount=1000)],\n            created_at=created_at,\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        # Should not raise\n        try:\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Business flight unused should be cancellable. Exception: {e}\")\n\n    def test_cancel_with_health_insurance(self):\n        \"\"\"\n        Policy: \"Basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met.\"\n        Example: \"An agent confirms health-related travel insurance applies to a reservation due to illness and proceeds to cancel, following policy guidelines.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # Simulate insurance applies due to health\n        reservation_id = \"RES321\"\n        created_at = (datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_4\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"FL321\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-13\", price=400)],\n            passengers=[Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1992-02-02\")],\n            payment_history=[Payment(payment_id=\"PAY4\", amount=400)],\n            created_at=created_at,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"yes\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        # Should not raise\n        try:\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Cancellation with valid health insurance should be allowed. Exception: {e}\")\n\n    def test_partial_cancellation_violation(self):\n        \"\"\"\n        Policy: \"The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed.\"\n        Example: \"The agent proceeds to cancel part of a reservation even when some segments have already been flown, which breaches the rule against partial cancellations.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES654\"\n        created_at = (datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_5\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[\n                ReservationFlight(flight_number=\"FL654A\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-14\", price=350),\n                ReservationFlight(flight_number=\"FL654B\", origin=\"LAX\", destination=\"JFK\", date=\"2024-06-20\", price=350)\n            ],\n            passengers=[Passenger(first_name=\"Eve\", last_name=\"Green\", dob=\"1980-03-03\")],\n            payment_history=[Payment(payment_id=\"PAY5\", amount=700)],\n            created_at=created_at,\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        # First segment flown, second not\n        def get_flight_instance_side_effect(flight_number, date):\n            if flight_number == \"FL654A\":\n                return FlightDateStatusLanded(status=\"landed\", actual_departure_time_est=\"2024-06-14T08:00:00\", actual_arrival_time_est=\"2024-06-14T11:00:00\")\n            else:\n                return FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        api.get_flight_instance.side_effect = get_flight_instance_side_effect\n        with pytest.raises(PolicyViolationException):\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n\n    def test_cancel_without_policy_check_violation(self):\n        \"\"\"\n        Policy: \"Agents must check if reservations meet these conditions: cancelled by the airline, within 24 hours of booking, or if travel insurance applies due to health or weather. Partial cancellations are prohibited.\"\n        Example: \"An agent attempts to cancel a reservation without checking if the airline has cancelled the flight or if it's within the 24-hour booking period, violating policy conditions.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES987\"\n        created_at = (datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_6\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"FL987\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-15\", price=350)],\n            passengers=[Passenger(first_name=\"Sam\", last_name=\"Blue\", dob=\"1995-04-04\")],\n            payment_history=[Payment(payment_id=\"PAY6\", amount=350)],\n            created_at=created_at,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        with pytest.raises(PolicyViolationException):\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n\n    def test_cancel_economy_without_insurance_violation(self):\n        \"\"\"\n        Policy: \"Basic economy or economy flights can be cancelled only if travel insurance is bought and the condition is met.\"\n        Example: \"An agent cancels a reservation for a basic economy flight without verifying if travel insurance applies due to health or weather conditions.\"\n        \"\"\"\n        history = MagicMock()\n        reservation_id = \"RES222\"\n        created_at = (datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\")\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_7\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"FL222\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-16\", price=200)],\n            passengers=[Passenger(first_name=\"Tom\", last_name=\"Yellow\", dob=\"1993-06-06\")],\n            payment_history=[Payment(payment_id=\"PAY7\", amount=200)],\n            created_at=created_at,\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_instance.side_effect = lambda flight_number, date: FlightDateStatusAvailable(status=\"available\", available_seats={\"economy\": 10, \"business\": 5, \"basic_economy\": 2}, prices={\"economy\": 300, \"business\": 800, \"basic_economy\": 200})\n        with pytest.raises(PolicyViolationException):\n            guard_strict_cancellation_rules_enforcement(history, api, reservation_id)\n"
        }
      ]
    },
    "update_reservation_passengers": {
      "tool": {
        "tool_name": "update_reservation_passengers",
        "policy_items": [
          {
            "name": "Ensure User Confirmation",
            "description": "Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.",
              "The agent calls the user, reads out the proposed updates on passenger details, and hears a verbal 'yes' confirming agreement to proceed.",
              "Prior to modification, the agent sends the updated passenger list via chat and waits for the user to type 'yes', confirming the changes.",
              "During a video call, the agent shares the screen showing the new passenger details and verbally confirms with the user by receiving a 'yes'.",
              "The airline agent displays updated passenger information and receives explicit 'yes' confirmation through the user's account portal.",
              "The agent uses a secure messaging platform to send a PDF summary of updates, and upon receiving a recorded voice message with 'yes', proceeds.",
              "During a conference call, the airline agent explains passenger information changes; upon receiving 'yes' in the chat, updates the database.",
              "Before using ToolX, the agent provides changes as downloadable content, waits for an email reply marked with 'yes', then proceeds with the update.",
              "The agent showcases updates through a mobile app notification, allowing the user to press 'Confirm' with 'yes' before executing the update."
            ],
            "violation_examples": [
              "An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.",
              "Without any prior communication or explicit confirmation, an airline agent updates John Doe's reservation details, assuming agreement."
            ]
          },
          {
            "name": "Validate Passenger Number Consistency",
            "description": "When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same. You can change details like name or date of birth, but the total number must not be altered. This rule is critical and an exception cannot be made, even by human agents.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged, adhering to the passenger number consistency policy.",
              "An update is requested for reservation 'ZFA04Y' to correct spelling errors in passengers' names, ensuring the list retains its original size of 2 passengers, thus complying with the policy.",
              "User modifies passenger ages in the reservation with ID 'ZFA04Y', containing 4 passengers, ensuring no passenger is added or removed, thus correctly validating the number consistency as per the policy requirements."
            ],
            "violation_examples": [
              "A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers, violating the rule that the number of passengers must remain unchanged.",
              "A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers, which incorrectly alters the total count of passengers.",
              "User requests an update on reservation 'ZFA04Y' by submitting a list of 5 passengers, while the original reservation only contained 4, thus conflicting with the passenger count policy."
            ]
          },
          {
            "name": "Transfer Requirement for Human Assistance",
            "description": "Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.",
            "references": [
              "<p>You should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions.</p>",
              "<p>Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with.</p>"
            ],
            "compliance_examples": [
              "A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged, and the agent successfully uses 'update_reservation_passengers', complying with the tool's capabilities and policy requirements.",
              "An agent receives a request to alter details such as contact or passport information for passengers, ensuring no change in the passenger count, and efficiently addresses it using 'update_reservation_passengers', maintaining policy compliance."
            ],
            "violation_examples": [
              "While updating a reservation, the agent attempts to change the number of passengers, such as adding an extra passenger or reducing it, without transferring the request to a human agent for assistance, thereby violating the policy.",
              "An agent handles a reservation update request to modify passenger numbers, such as from 3 to 6 or 6 to 8, without initiating a transfer to a human agent, which is required by the Transfer Requirement for Human Assistance policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_passengers",
      "guard_file": {
        "file_name": "airline/update_reservation_passengers/guard_update_reservation_passengers.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\n\n\ndef guard_update_reservation_passengers(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n         \n    \"\"\"\n    \n    guard_ensure_user_confirmation(history, api, reservation_id, passengers)\n    guard_validate_passenger_number_consistency(history, api, reservation_id, passengers)\n    guard_transfer_requirement_for_human_assistance(history, api, reservation_id, passengers)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_passengers/guard_ensure_user_confirmation.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_ensure_user_confirmation(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\n\n    This guard checks that explicit user confirmation ('yes') was obtained before updating passenger information for a reservation.\n    It uses the chat history to verify confirmation and raises PolicyViolationException if confirmation is missing.\n\n    Args:\n        history (ChatHistory): Provides question-answer services over the past chat messages.\n        api (I_Airline): API to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Ask the chat history if the user explicitly confirmed the passenger information update\n    confirmed = history.ask_bool(\n        f\"Did the user explicitly confirm ('yes') the proposed passenger information update for reservation '{reservation_id}'?\")\n    if not confirmed:\n        raise PolicyViolationException(\n            \"Explicit user confirmation ('yes') for passenger information update was not obtained.\")\n"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_validate_passenger_number_consistency.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_validate_passenger_number_consistency(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same. You can change details like name or date of birth, but the total number must not be altered. This rule is critical and an exception cannot be made, even by human agents.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    Raises:\n        PolicyViolationException: If the number of passengers is changed.\n    \"\"\"\n    # Get the original reservation details using the API\n    reservation = api.get_reservation_details(reservation_id)\n    original_count = len(reservation.passengers)\n    new_count = len(passengers)\n    # Check if the number of passengers is changed\n    if new_count != original_count:\n        raise PolicyViolationException(\n            f\"Passenger count changed from {original_count} to {new_count}. This is not allowed by policy.\"\n        )\n"
        },
        {
          "file_name": "airline/update_reservation_passengers/guard_transfer_requirement_for_human_assistance.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_transfer_requirement_for_human_assistance(history: ChatHistory, api: I_Airline, reservation_id: str, passengers: list[Passenger | dict]):\n    \"\"\"\n    Policy to check: Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        passengers: An array of objects containing details about each passenger.\n    \"\"\"\n    # Get the current reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    current_passenger_count = len(reservation.passengers)\n    new_passenger_count = len(passengers)\n\n    # Policy: Any change in passenger count is NOT allowed by update_reservation_passengers\n    if new_passenger_count != current_passenger_count:\n        raise PolicyViolationException(\n            \"Passenger count change detected. Must transfer to human agent as per policy.\"\n        )\n    # Note: If further checks for unsupported modifications are required, add them here.\n    # For now, only passenger count change is explicitly forbidden by the tool and policy.\n"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_passengers/test_guard_ensure_user_confirmation.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_ensure_user_confirmation import guard_ensure_user_confirmation\nfrom airline.airline_types import *\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestEnsureUserConfirmation:\n    def test_email_confirmation_received(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"Before updating the passenger information for reservation 'ZFA04Y', the airline agent sends an email detailing the changes and receives a reply from the user confirming 'yes' before proceeding.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User confirmed 'yes'\n        api = MagicMock(spec=I_Airline)\n        # Mock get_reservation_details to return a valid reservation\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1980-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1990-02-02\")]\n        # Should not raise\n        try:\n            guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected no PolicyViolationException when user confirmation is present. Got: {e.message}\")\n\n    def test_no_confirmation_raises_exception(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"An airline agent updates the passenger information for a reservation without displaying the changes to the user or obtaining explicit confirmation from them, violating the policy that requires a 'yes' confirmation before proceeding.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # User did NOT confirm\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1980-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1990-02-02\")]\n        with pytest.raises(PolicyViolationException):\n            guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n\n    def test_update_without_any_communication(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"Without any prior communication or explicit confirmation, an airline agent updates John Doe's reservation details, assuming agreement.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # No communication, so no confirmation\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1980-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1990-02-02\")]\n        with pytest.raises(PolicyViolationException):\n            guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n\n    def test_chat_confirmation_received(self):\n        \"\"\"\n        Policy: \"Before using ToolX to update passenger information in the booking database, an airline agent must present the details of the changes to the user and obtain explicit confirmation ('yes') from them before proceeding.\"\n        Example: \"Prior to modification, the agent sends the updated passenger list via chat and waits for the user to type 'yes', confirming the changes.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User confirmed 'yes' in chat\n        api = MagicMock(spec=I_Airline)\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-06-01\", price=500)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1980-01-01\")],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == \"ZFA04Y\" else None\n        passengers = [Passenger(first_name=\"Jane\", last_name=\"Doe\", dob=\"1990-02-02\")]\n        try:\n            guard_ensure_user_confirmation(history, api, \"ZFA04Y\", passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected no PolicyViolationException when user confirmation is present in chat. Got: {e.message}\")\n"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_validate_passenger_number_consistency.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException, ChatHistory\nfrom airline.update_reservation_passengers.guard_validate_passenger_number_consistency import guard_validate_passenger_number_consistency\nfrom airline.airline_types import Passenger, Reservation\nfrom airline.i_airline import I_Airline\n\nclass TestValidatePassengerNumberConsistency:\n    def setup_method(self):\n        # Mock chat history\n        self.history = MagicMock(spec=ChatHistory)\n        # Mock API\n        self.api = MagicMock(spec=I_Airline)\n        # Common reservation_id for all tests\n        self.reservation_id = \"ZFA04Y\"\n        # Mock get_reservation_details to return a reservation with a specific number of passengers\n        self.api.get_reservation_details.side_effect = self._mock_get_reservation_details\n\n    def _mock_get_reservation_details(self, reservation_id):\n        # Return a reservation with the correct number of passengers for each test\n        if reservation_id == \"ZFA04Y\":\n            # Used in compliance and violation tests, will be overwritten in each test\n            return self._reservation\n        return None\n\n    def test_update_name_and_dob_same_count(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user updates the reservation 'ZFA04Y', originally for 3 passengers, by changing the name and date of birth of a passenger while maintaining the total number unchanged, adhering to the passenger number consistency policy.\"\n        \"\"\"\n        # Setup original reservation with 3 passengers\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Bob\", last_name=\"Jones\", dob=\"1985-05-05\"),\n                Passenger(first_name=\"Carol\", last_name=\"White\", dob=\"1978-12-12\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        # Update passenger details, but keep count the same\n        updated_passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Bob\", last_name=\"Johnson\", dob=\"1985-05-05\"),  # last name changed\n            Passenger(first_name=\"Carol\", last_name=\"White\", dob=\"1978-12-13\")   # dob changed\n        ]\n        try:\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected no exception when updating passenger details without changing count. Got: {e.message}\")\n\n    def test_correct_spelling_names_same_count(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"An update is requested for reservation 'ZFA04Y' to correct spelling errors in passengers' names, ensuring the list retains its original size of 2 passengers, thus complying with the policy.\"\n        \"\"\"\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_456\",\n            origin=\"SFO\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Jon\", last_name=\"Doe\", dob=\"1992-03-03\"),\n                Passenger(first_name=\"Sara\", last_name=\"Lee\", dob=\"1991-07-07\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"yes\",\n            status=None\n        )\n        updated_passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1992-03-03\"),  # spelling corrected\n            Passenger(first_name=\"Sarah\", last_name=\"Lee\", dob=\"1991-07-07\")   # spelling corrected\n        ]\n        try:\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected no exception when correcting spelling with same passenger count. Got: {e.message}\")\n\n    def test_modify_ages_no_count_change(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"User modifies passenger ages in the reservation with ID 'ZFA04Y', containing 4 passengers, ensuring no passenger is added or removed, thus correctly validating the number consistency as per the policy requirements.\"\n        \"\"\"\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_789\",\n            origin=\"ATL\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Tom\", last_name=\"Brown\", dob=\"2000-01-01\"),\n                Passenger(first_name=\"Jerry\", last_name=\"Black\", dob=\"2001-02-02\"),\n                Passenger(first_name=\"Spike\", last_name=\"Green\", dob=\"2002-03-03\"),\n                Passenger(first_name=\"Tyke\", last_name=\"Blue\", dob=\"2003-04-04\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=3,\n            nonfree_baggages=2,\n            insurance=\"no\",\n            status=None\n        )\n        updated_passengers = [\n            Passenger(first_name=\"Tom\", last_name=\"Brown\", dob=\"2000-01-02\"),  # dob changed\n            Passenger(first_name=\"Jerry\", last_name=\"Black\", dob=\"2001-02-03\"),\n            Passenger(first_name=\"Spike\", last_name=\"Green\", dob=\"2002-03-04\"),\n            Passenger(first_name=\"Tyke\", last_name=\"Blue\", dob=\"2003-04-05\")\n        ]\n        try:\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected no exception when modifying ages with same passenger count. Got: {e.message}\")\n\n    def test_update_to_fewer_passengers_raises(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user attempts to update a reservation with ID 'ZFA04Y', initially having 3 passengers, to an updated list containing only 2 passengers, violating the rule that the number of passengers must remain unchanged.\"\n        \"\"\"\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Bob\", last_name=\"Jones\", dob=\"1985-05-05\"),\n                Passenger(first_name=\"Carol\", last_name=\"White\", dob=\"1978-12-12\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        updated_passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Bob\", last_name=\"Jones\", dob=\"1985-05-05\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n\n    def test_add_extra_passenger_raises(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"A user tries to modify the reservation 'ZFA04Y' by adding a fourth passenger when the reservation originally included 3 passengers, which incorrectly alters the total count of passengers.\"\n        \"\"\"\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_123\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n                Passenger(first_name=\"Bob\", last_name=\"Jones\", dob=\"1985-05-05\"),\n                Passenger(first_name=\"Carol\", last_name=\"White\", dob=\"1978-12-12\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        updated_passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Bob\", last_name=\"Jones\", dob=\"1985-05-05\"),\n            Passenger(first_name=\"Carol\", last_name=\"White\", dob=\"1978-12-12\"),\n            Passenger(first_name=\"Dave\", last_name=\"Green\", dob=\"1992-02-02\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n\n    def test_update_to_five_passengers_raises(self):\n        \"\"\"\n        Policy: \"When modifying passenger details in a reservation using ToolX, ensure the number of passengers remains the same.\"\n        Example: \"User requests an update on reservation 'ZFA04Y' by submitting a list of 5 passengers, while the original reservation only contained 4, thus conflicting with the passenger count policy.\"\n        \"\"\"\n        self._reservation = Reservation(\n            reservation_id=self.reservation_id,\n            user_id=\"user_789\",\n            origin=\"ATL\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[],\n            passengers=[\n                Passenger(first_name=\"Tom\", last_name=\"Brown\", dob=\"2000-01-01\"),\n                Passenger(first_name=\"Jerry\", last_name=\"Black\", dob=\"2001-02-02\"),\n                Passenger(first_name=\"Spike\", last_name=\"Green\", dob=\"2002-03-03\"),\n                Passenger(first_name=\"Tyke\", last_name=\"Blue\", dob=\"2003-04-04\")\n            ],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=3,\n            nonfree_baggages=2,\n            insurance=\"no\",\n            status=None\n        )\n        updated_passengers = [\n            Passenger(first_name=\"Tom\", last_name=\"Brown\", dob=\"2000-01-01\"),\n            Passenger(first_name=\"Jerry\", last_name=\"Black\", dob=\"2001-02-02\"),\n            Passenger(first_name=\"Spike\", last_name=\"Green\", dob=\"2002-03-03\"),\n            Passenger(first_name=\"Tyke\", last_name=\"Blue\", dob=\"2003-04-04\"),\n            Passenger(first_name=\"New\", last_name=\"Person\", dob=\"2004-05-05\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_validate_passenger_number_consistency(self.history, self.api, self.reservation_id, updated_passengers)\n"
        },
        {
          "file_name": "tests/update_reservation_passengers/test_guard_transfer_requirement_for_human_assistance.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_passengers.guard_transfer_requirement_for_human_assistance import guard_transfer_requirement_for_human_assistance\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import Reservation, Passenger\n\nclass TestGuardTransferRequirementForHumanAssistance:\n    def test_update_passenger_info_no_count_change(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\"\n        Example: \"A user requests to update passenger information for a reservation, ensuring the passenger count remains unchanged, and the agent successfully uses 'update_reservation_passengers', complying with the tool's capabilities and policy requirements.\"\n        \"\"\"\n        # Mock chat history\n        history = MagicMock()\n        # Assume all tools have been used, and the issue is not due to passenger count\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n        history.ask_bool.return_value = True\n\n        # Mock API and reservation\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=original_passengers,\n            payment_history=[],\n            created_at=\"2024-06-01T10:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n\n        # New passengers (same count, info updated)\n        new_passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")\n        ]\n        # Should NOT raise\n        try:\n            guard_transfer_requirement_for_human_assistance(history, api, reservation_id, new_passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Should not raise PolicyViolationException when passenger count is unchanged. Error: {e}\")\n\n    def test_update_passenger_details_no_count_change(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\"\n        Example: \"An agent receives a request to alter details such as contact or passport information for passengers, ensuring no change in the passenger count, and efficiently addresses it using 'update_reservation_passengers', maintaining policy compliance.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n        history.ask_bool.return_value = True\n\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1992-03-03\")\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_456\",\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[],\n            passengers=original_passengers,\n            payment_history=[],\n            created_at=\"2024-06-01T10:00:00\",\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n\n        # New passengers (same count, details changed)\n        new_passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1992-03-03\")\n        ]\n        try:\n            guard_transfer_requirement_for_human_assistance(history, api, reservation_id, new_passengers)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Should not raise PolicyViolationException when only passenger details are changed. Error: {e}\")\n\n    def test_violation_change_passenger_count(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\"\n        Example: \"While updating a reservation, the agent attempts to change the number of passengers, such as adding an extra passenger or reducing it, without transferring the request to a human agent for assistance, thereby violating the policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n        history.ask_bool.return_value = True\n\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_789\",\n            origin=\"SEA\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=original_passengers,\n            payment_history=[],\n            created_at=\"2024-06-01T10:00:00\",\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n\n        # New passengers (count changed)\n        new_passengers = [\n            Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"New\", last_name=\"Person\", dob=\"2000-12-12\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_transfer_requirement_for_human_assistance(history, api, reservation_id, new_passengers)\n\n    def test_violation_modify_passenger_number(self):\n        \"\"\"\n        Policy: \"Agents are instructed to transfer users to a human agent when passenger modification requests surpass the capabilities of the 'update_reservation_passengers' tool. This includes any change in passenger count or modifications not supported by the tool. Agents must confirm that all available tools have been used and that the issue cannot be resolved due to passenger number constraints before initiating the transfer.\"\n        Example: \"An agent handles a reservation update request to modify passenger numbers, such as from 3 to 6 or 6 to 8, without initiating a transfer to a human agent, which is required by the Transfer Requirement for Human Assistance policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n        history.ask_bool.return_value = True\n\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_passengers = [\n            Passenger(first_name=\"A\", last_name=\"B\", dob=\"1980-01-01\"),\n            Passenger(first_name=\"C\", last_name=\"D\", dob=\"1981-02-02\"),\n            Passenger(first_name=\"E\", last_name=\"F\", dob=\"1982-03-03\")\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_999\",\n            origin=\"ATL\",\n            destination=\"BOS\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[],\n            passengers=original_passengers,\n            payment_history=[],\n            created_at=\"2024-06-01T10:00:00\",\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n\n        # New passengers (count changed from 3 to 6)\n        new_passengers = [\n            Passenger(first_name=\"A\", last_name=\"B\", dob=\"1980-01-01\"),\n            Passenger(first_name=\"C\", last_name=\"D\", dob=\"1981-02-02\"),\n            Passenger(first_name=\"E\", last_name=\"F\", dob=\"1982-03-03\"),\n            Passenger(first_name=\"G\", last_name=\"H\", dob=\"1990-04-04\"),\n            Passenger(first_name=\"I\", last_name=\"J\", dob=\"1991-05-05\"),\n            Passenger(first_name=\"K\", last_name=\"L\", dob=\"1992-06-06\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_transfer_requirement_for_human_assistance(history, api, reservation_id, new_passengers)\n"
        }
      ]
    },
    "update_reservation_baggages": {
      "tool": {
        "tool_name": "update_reservation_baggages",
        "policy_items": [
          {
            "name": "Explicit Confirmation for Baggage Update",
            "description": "Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "A user asks to update reservation 'ZFA04Y' baggages. The system lists changes: increasing total baggages from 2 to 3, nonfree from 0 to 2, using payment method 'certificate_7815826'. User explicitly confirms 'yes' and the operation proceeds.",
              "Before updating the reservation 'XJ43MS', the agent presents a summary of requested changes: altering total baggages to 5 and nonfree baggages to 3. The user confirms with a 'yes', allowing the update to take place using 'gift_card_987654'.",
              "User intends to change baggage data for reservation 'LMN456'. All update details are neatly listed: decrementing total baggages to 1, charging nonfree baggages as 1 via 'credit_card_394820'. After receiving a clear 'yes' from the user, the tool proceeds.",
              "To update baggage details for reservation ID 'FGH789', system meticulously lists: changing total to 3 baggages, nonfree are zero, paid by 'certificate_112233'. Awaiting explicit confirmation 'yes' from the agent before proceeding ensures rule compliance."
            ],
            "violation_examples": [
              "A user provides a reservation ID 'ZFA04Y' to update baggage details without explicitly confirming the changes. The system proceeds to update the total baggages to 3 and nonfree baggages to 1 using the payment method 'credit_card_7815826' without asking for explicit confirmation.",
              "An agent wishes to update the baggage count by reducing total baggages from 5 to 3 using reservation ID 'T125HG' and payment method 'gift_card_123456', but does not list the changes beforehand or seek affirmation from the user.",
              "User requests to change reservation 'XJ43MS' baggage details and the agent immediately proceeds with modifying nonfree baggages to 2, without listing these adjustments or waiting for a user to say 'yes' for confirmation.",
              "The reservation update tool is utilized to change baggage information on reservation 'ABCD123' from a total of 2 baggages to 4 without outlining all changes and obtaining user approval."
            ]
          },
          {
            "name": "Baggage Addition Policy",
            "description": "When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.",
            "references": [
              "Change baggage and insurance: The user can add but not remove checked bags.",
              "Checked bag allowance: If the booking user is a regular member, 0 free checked bag for each basic economy passenger, 1 free checked bag for each economy passenger, and 2 free checked bags for each business passenger. If the booking user is a silver member, 1 free checked bag for each basic economy passenger, 2 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. If the booking user is a gold member, 2 free checked bag for each basic economy passenger, 3 free checked bag for each economy passenger, and 3 free checked bags for each business passenger. Each extra baggage is 50 dollars.",
              "All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "Increasing checked bags from 2 to 4 on reservation 'ZFA04Y': A gold member in business class adds 2 additional nonfree bags using a stored credit card, correctly applying fees according to policy.",
              "For reservation 'ZFA04Y', updating with a silver member traveling in economy by adding 2 checked bags, correctly adjusting total_baggages to 4 and nonfree_baggages to 2, using a stored gift card for payment as per policy.",
              "Updating reservation 'ZFA04Y' with a regular member in economy class, adding 1 nonfree bag, correctly setting total_baggages to 2 and nonfree_baggages to 1, using a stored payment method, adhering to the free checked bag allowance.",
              "Adding 2 checked bags to existing reservation 'ZFA04Y' for a silver member in business class: Ensuring total_baggages is 4 and nonfree_baggages is 1 due to the free allocation rule, with fees charged to a stored certificate according to policy.",
              "A regular member in business class updates reservation 'ZFA04Y' by adding 2 nonfree bags, ensuring total_baggages is 4 and nonfree_baggages is 2 based on their allowance, processing payment via an existing credit card according to policy.",
              "For reservation 'ZFA04Y', a regular member in business class correctly updates total_baggages to 5 and nonfree_baggages to 3, using a stored payment method and adhering to the policy for recognizing free bags.",
              "A gold member in business class updates reservation 'ZFA04Y' to include 5 total checked bags, correctly increasing nonfree_baggages to 2 with stored gift card payment, adhering to policy requirements.",
              "A silver member in basic economy adds 2 checked bags to reservation 'ZFA04Y', updating total_baggages to 3 and nonfree_baggages to 2, considering 1 free checked bag according to the policy, with fees covered using a stored payment method."
            ],
            "violation_examples": [
              "Updating reservation with ID 'ZFA04Y' to reduce the total checked bags from 3 to 2, violating the policy that prevents removing checked bags.",
              "Attempting to use a new payment method not stored in user profile for baggage fees when updating reservation 'ZFA04Y', violating the policy requiring existing payment methods.",
              "Setting total_baggages to 4 but nonfree_baggages to 1 for a regular member in basic economy, violating the policy as regular members get 0 free checked bags in basic economy, so nonfree_baggages should match total_baggages.",
              "For a silver member in business class, updating the baggage on reservation 'ZFA04Y' with total_baggages set to 5 checked bags but incorrectly setting nonfree_baggages to 1. The policy grants 3 free checked bags; thus, 2 should be non-free.",
              "Adding 3 checked bags to reservation 'ZFA04Y' without calculating and applying a fee for each additional nonfree bag, violating the baggage policy.",
              "Updating reservation ID 'ZFA04Y' by setting total_baggages to 6 while nonfree_baggages are only set to 2 for a gold member in economy class, violating the policy as a gold member in economy has 3 free checked bags, meaning nonfree_baggages should be 3.",
              "A regular member in economy class updates reservation 'ZFA04Y' by setting total_baggages to 3 and nonfree_baggages to 1, violating the policy because regular members in economy receive 1 free bag and thus nonfree_baggages should be 2.",
              "An attempt to update reservation 'ZFA04Y' using a payment method labeled as 'debit_card_123456', not stored in the user's profile, violating the policy requirement for existing payment methods.",
              "For reservation 'ZFA04Y', a gold member in basic economy attempts to set total_baggages at 3 and nonfree_baggages at 0, violating the policy that requires nonfree_baggages to be 1 as gold members receive 2 free bags."
            ]
          },
          {
            "name": "Payment Method Validation for Baggage Update",
            "description": "Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.",
            "references": [
              "Payment: each reservation can use at most one travel certificate, at most one credit card, and at most three gift cards. The remaining amount of a travel certificate is not refundable. All payment methods must already be in user profile for safety reasons."
            ],
            "compliance_examples": [
              "A user successfully updates their reservation baggages using a credit card stored in their profile, ensuring secure payment.",
              "The reservation baggages are updated using gift cards stored within the user's profile, complying with the gift card limit.",
              "A stored travel certificate from the user's profile is utilized to update non-free baggages, aligning with policy requirements.",
              "Updating the baggage information using a combination of payment methods from the user's profile, adhering to policy limits."
            ],
            "violation_examples": [
              "A user attempts to update their reservation baggages using a certificate or credit card that is not stored in their profile, which leads to transaction insecurity.",
              "A user tries to update their reservation baggages using multiple gift cards, exceeding the allowed limit and thus violating payment method constraints.",
              "A user attempts to use a combination of certificates for paying the baggage update, exceeding the allowed limit per reservation."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_baggages",
      "guard_file": {
        "file_name": "airline/update_reservation_baggages/guard_update_reservation_baggages.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_baggages.guard_explicit_confirmation_for_baggage_update import guard_explicit_confirmation_for_baggage_update\nfrom airline.update_reservation_baggages.guard_baggage_addition_policy import guard_baggage_addition_policy\nfrom airline.update_reservation_baggages.guard_payment_method_validation_for_baggage_update import guard_payment_method_validation_for_baggage_update\n\n\ndef guard_update_reservation_baggages(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_explicit_confirmation_for_baggage_update(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_baggage_addition_policy(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n    guard_payment_method_validation_for_baggage_update(history, api, reservation_id, total_baggages, nonfree_baggages, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_baggages/guard_explicit_confirmation_for_baggage_update.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_confirmation_for_baggage_update(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation,\n    ensure you list all changes and receive explicit user confirmation (yes) to proceed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    Raises:\n        PolicyViolationException: If explicit confirmation was not received or changes were not listed.\n    \"\"\"\n    # Get current reservation details\n    try:\n        reservation = api.get_reservation_details(reservation_id)\n    except Exception:\n        # If reservation not found, let the tool itself handle this error\n        return\n\n    # Prepare a summary of changes\n    changes = []\n    if reservation.total_baggages != total_baggages:\n        changes.append(f\"total baggages: {reservation.total_baggages} -> {total_baggages}\")\n    if reservation.nonfree_baggages != nonfree_baggages:\n        changes.append(f\"nonfree baggages: {reservation.nonfree_baggages} -> {nonfree_baggages}\")\n    # Always include payment method\n    changes.append(f\"payment method: {payment_id}\")\n\n    # Check that changes were listed in the chat history\n    if changes:\n        changes_listed = history.ask_bool(\n            f\"Did the agent list the following baggage update changes for reservation '{reservation_id}': {', '.join(changes)}?\"\n        )\n        if not changes_listed:\n            raise PolicyViolationException(\"All changes must be listed before updating baggage information.\")\n\n    # Check for explicit user confirmation\n    confirmed = history.ask_bool(\n        f\"Did the user explicitly confirm (yes) to proceed with updating baggage information for reservation '{reservation_id}'?\"\n    )\n    if not confirmed:\n        raise PolicyViolationException(\"Explicit user confirmation (yes) is required before updating baggage information.\")\n"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_baggage_addition_policy.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_baggage_addition_policy(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: When using the update_reservation_baggages tool, you can add checked bags to an existing reservation but cannot remove them. Ensure that any additional bags are reflected in both the total_baggages and nonfree_baggages fields. Verify that the bags adhere to the baggage allowance based on the user's membership status (regular, silver, gold) and cabin class (basic economy, economy, business). Calculate fees based on additional baggage, if applicable. Always use payment methods already stored in the user's profile for additional baggage fees.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_baggages/guard_payment_method_validation_for_baggage_update.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_validation_for_baggage_update(history: ChatHistory, api: I_Airline, reservation_id: str, total_baggages: int, nonfree_baggages: int, payment_id: str):\n    \"\"\"\n    Policy to check: Ensure the payment method used is stored in the user's profile before using the 'update_reservation_baggages' tool. Verify the payment method's existence first to maintain transaction security, preventing unauthorized use. This step is crucial for baggage updates.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'\n        total_baggages: The updated total number of baggage items included in the reservation.\n        nonfree_baggages: The updated number of non-free baggage items included in the reservation.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_baggages/test_guard_explicit_confirmation_for_baggage_update.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException, ChatHistory\nfrom airline.update_reservation_baggages.guard_explicit_confirmation_for_baggage_update import guard_explicit_confirmation_for_baggage_update\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestExplicitConfirmationForBaggageUpdate:\n    def test_update_baggages_with_explicit_confirmation(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"A user asks to update reservation 'ZFA04Y' baggages. The system lists changes: increasing total baggages from 2 to 3, nonfree from 0 to 2, using payment method 'certificate_7815826'. User explicitly confirms 'yes' and the operation proceeds.\"\n        \"\"\"\n        # Mock chat history to simulate explicit confirmation\n        history = MagicMock(spec=ChatHistory)\n        history.ask_bool.return_value = True  # User confirms 'yes'\n        # Mock dependent tool: get_reservation_details\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_001\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-01\", price=350)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[Payment(payment_id=\"certificate_7815826\", amount=100)],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        # Should not raise exception\n        try:\n            guard_explicit_confirmation_for_baggage_update(\n                history,\n                api,\n                reservation_id=\"ZFA04Y\",\n                total_baggages=3,\n                nonfree_baggages=2,\n                payment_id=\"certificate_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Explicit confirmation test failed: Expected no exception, got {e.message}\")\n\n    def test_update_baggages_without_explicit_confirmation(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"A user provides a reservation ID 'ZFA04Y' to update baggage details without explicitly confirming the changes. The system proceeds to update the total baggages to 3 and nonfree baggages to 1 using the payment method 'credit_card_7815826' without asking for explicit confirmation.\"\n        \"\"\"\n        # Mock chat history to simulate NO explicit confirmation\n        history = MagicMock(spec=ChatHistory)\n        history.ask_bool.return_value = False  # User does NOT confirm\n        # Mock dependent tool: get_reservation_details\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"user_001\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"JFK\", destination=\"LAX\", date=\"2024-06-01\", price=350)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Doe\", dob=\"1990-01-01\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=100)],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        # Should raise PolicyViolationException\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_confirmation_for_baggage_update(\n                history,\n                api,\n                reservation_id=\"ZFA04Y\",\n                total_baggages=3,\n                nonfree_baggages=1,\n                payment_id=\"credit_card_7815826\"\n            )\n\n    def test_update_baggages_without_listing_changes(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"An agent wishes to update the baggage count by reducing total baggages from 5 to 3 using reservation ID 'T125HG' and payment method 'gift_card_123456', but does not list the changes beforehand or seek affirmation from the user.\"\n        \"\"\"\n        history = MagicMock(spec=ChatHistory)\n        history.ask_bool.return_value = False  # No confirmation\n        reservation = Reservation(\n            reservation_id=\"T125HG\",\n            user_id=\"user_002\",\n            origin=\"SFO\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT002\", origin=\"SFO\", destination=\"ORD\", date=\"2024-06-10\", price=700)],\n            passengers=[Passenger(first_name=\"Jane\", last_name=\"Smith\", dob=\"1985-05-05\")],\n            payment_history=[Payment(payment_id=\"gift_card_123456\", amount=200)],\n            created_at=(datetime.now() - timedelta(days=20)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=5,\n            nonfree_baggages=2,\n            insurance=\"yes\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"T125HG\" else None\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_confirmation_for_baggage_update(\n                history,\n                api,\n                reservation_id=\"T125HG\",\n                total_baggages=3,\n                nonfree_baggages=2,\n                payment_id=\"gift_card_123456\"\n            )\n\n    def test_update_baggages_immediate_modification_no_confirmation(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"User requests to change reservation 'XJ43MS' baggage details and the agent immediately proceeds with modifying nonfree baggages to 2, without listing these adjustments or waiting for a user to say 'yes' for confirmation.\"\n        \"\"\"\n        history = MagicMock(spec=ChatHistory)\n        history.ask_bool.return_value = False  # No confirmation\n        reservation = Reservation(\n            reservation_id=\"XJ43MS\",\n            user_id=\"user_003\",\n            origin=\"ATL\",\n            destination=\"SEA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"HAT003\", origin=\"ATL\", destination=\"SEA\", date=\"2024-06-15\", price=250)],\n            passengers=[Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1995-07-07\")],\n            payment_history=[Payment(payment_id=\"gift_card_987654\", amount=150)],\n            created_at=(datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=4,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"XJ43MS\" else None\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_confirmation_for_baggage_update(\n                history,\n                api,\n                reservation_id=\"XJ43MS\",\n                total_baggages=4,\n                nonfree_baggages=2,\n                payment_id=\"gift_card_987654\"\n            )\n\n    def test_update_baggages_no_listing_no_confirmation(self):\n        \"\"\"\n        Policy: \"Before invoking the 'update_reservation_baggages' tool to update baggage information in a reservation, ensure you list all changes and receive explicit user confirmation (yes) to proceed.\"\n        Example: \"The reservation update tool is utilized to change baggage information on reservation 'ABCD123' from a total of 2 baggages to 4 without outlining all changes and obtaining user approval.\"\n        \"\"\"\n        history = MagicMock(spec=ChatHistory)\n        history.ask_bool.return_value = False  # No confirmation\n        reservation = Reservation(\n            reservation_id=\"ABCD123\",\n            user_id=\"user_004\",\n            origin=\"MIA\",\n            destination=\"DEN\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT004\", origin=\"MIA\", destination=\"DEN\", date=\"2024-06-20\", price=400)],\n            passengers=[Passenger(first_name=\"Bob\", last_name=\"White\", dob=\"1980-12-12\")],\n            payment_history=[Payment(payment_id=\"certificate_112233\", amount=120)],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ABCD123\" else None\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_confirmation_for_baggage_update(\n                history,\n                api,\n                reservation_id=\"ABCD123\",\n                total_baggages=4,\n                nonfree_baggages=0,\n                payment_id=\"certificate_112233\"\n            )\n"
        },
        null,
        null
      ]
    },
    "update_reservation_flights": {
      "tool": {
        "tool_name": "update_reservation_flights",
        "policy_items": [
          {
            "name": "Explicit User Confirmation Required",
            "description": "Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.",
            "references": [
              "Before taking any actions that update the booking database (booking, modifying flights, editing baggage, upgrading cabin class, or updating passenger information), you must list the action details and obtain explicit user confirmation (yes) to proceed."
            ],
            "compliance_examples": [
              "The agent presents the updated flight itinerary, cabin class changes, and passenger adjustments in detail and waits for the user to reply 'yes' before proceeding, ensuring compliance with the required user confirmation.",
              "User interaction history reveals explicit verbal confirmation ('yes') after presenting action details via email, allowing the update_reservation_flights tool to proceed in accordance with policy.",
              "Before confirming flight changes, the system shows a summary detailing new flight segments and asks, 'Do you confirm?' The user responds with 'yes', thereby validating the action and meeting the explicit consent requirement.",
              "Flight changes are sent to the user's registered email address with clear action details, and the system waits until the user replies 'yes' before executing any update, ensuring compliance with the policy.",
              "A detailed list of updates, including flight, baggage, and cabin class changes, is shown to the user during a live chat, and the agent proceeds only after a clear 'yes' from the user, validating adherence to the explicit confirmation policy."
            ],
            "violation_examples": [
              "An agent updates the flight details of a reservation without asking the user for confirmation, proceeding with changes based on assumed preferences, which violates the requirement for explicit user consent.",
              "The system automatically applies updates to the reservation based on recent user activity without presenting details or receiving explicit confirmation, failing to adhere to the explicit confirmation policy.",
              "Updates to the cabin class and passenger information are executed without the user explicitly saying 'yes', after merely highlighting them, leading to non-compliance with the explicit consent requirement.",
              "A reservation update is initiated after receiving implicit consent from phrases like 'okay' or 'sounds good', rather than a clear 'yes', which does not meet the policy's explicit confirmation standard.",
              "The system pre-fills all updates regarding flights and baggage but does not prompt the user for confirmation before finalizing, violating the policy's demand for explicit consent."
            ]
          },
          {
            "name": "Cannot Modify Basic Economy Flights",
            "description": "Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified.</p>",
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type.</p>"
            ],
            "compliance_examples": [
              "An agent successfully updates a 'business' reservation by changing the flight times, keeping the same origin 'SFO' and destination 'JFK' without altering the trip type from 'round_trip', ensuring compliance with the policy.",
              "A user with a 'business' class reservation updates the cabin class and flight numbers, ensuring the original origin and destination IATA codes 'ORD' and 'LAX' remain unchanged, thus complying with reservation policies.",
              "A user successfully modifies their 'economy' reservation by adding a special meal preference, while preserving all other flight details including origin and trip type, adhering to policy guidelines.",
              "An agent updates a 'business' class reservation, adding another layover in the flight segments but maintaining the original itinerary's origin 'ATL', destination 'HNL', and 'round_trip' type, in line with the policy.",
              "An agent processes an update for an economy reservation by adding extra baggage allowance, ensuring the flight itinerary remains intact with the original destination 'BOS' and trip type 'round_trip', fulfilling the policy requirements.",
              "A user successfully modifies an economy reservation by adding a preferred seating option, while ensuring the origin, destination, and trip type 'one_way' remain unchanged, complying with the policy."
            ],
            "violation_examples": [
              "A user attempts to change a reservation with basic economy flights by providing a new itinerary with updated origin and destination details, violating the restriction on modifying basic economy flights.",
              "An agent tries to update a basic economy flight reservation by changing the cabin class from 'basic_economy' to 'economy', which violates the policy against altering basic economy reservations.",
              "A user requests modifying a reservation classified as basic economy by supplying an edited flight array containing different departure times, going against the policy of non-modification for basic economy.",
              "A user tries to adjust the basic economy flight itinerary by requesting a new connecting flight option instead of their direct flight, contravening the reservation policy.",
              "An agent attempts to update a reservation classified as 'economy' by changing the trip type from 'round_trip' to 'one_way', which violates the policy of maintaining trip type for non-basic reservations.",
              "A user submits a request to change the flights in a business class reservation by altering the destination from 'SFO' to 'NYC', breaking the rule against changing destinations in non-basic reservations."
            ]
          },
          {
            "name": "Cabin Change Payment Requirement",
            "description": "ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user changes the entire reservation's cabin class from economy to business, ensuring all flight segments are included in the updated reservation request and provides payment details to cover the fare difference, fully complying with the policy.",
              "A user updates all flight segments of their reservation from basic economy to economy class, ensuring the cabin class is uniformly changed across the entire reservation and pays the required fare difference, adhering to policy requirements.",
              "The user modifies their reservation to change all flight segments from economy to first class and provides necessary payment methods to cover the new cabin class fare difference, ensuring full compliance.",
              "A user updates all flight segments from first class to business class, providing their credit card details that have sufficient funds to cover the fare reduction difference for all segments in their reservation.",
              "A user requests a cabin change for their reservation, ensuring all flight segments are updated from premium economy to economy class and provides a payment method with a sufficient balance to cover the reduced fare difference, meeting policy standards."
            ],
            "violation_examples": [
              "A user attempts to change only one segment of their reservation from economy to business class without updating the cabin class for the entire reservation, violating the required uniform cabin change.",
              "A user updates their reservation to have mixed cabin classes, changing one flight to economy and another to business class within the same reservation, which breaks the policy mandating uniform cabin class across all flights.",
              "A user changes their entire reservation from basic economy to business class but only provides payment that covers the difference for a single flight segment, not fulfilling the policy requirement for covering the fare difference for the entire reservation.",
              "A user attempts to change their reservation's cabin class from economy to premium economy for all flights but incorrectly inputs payment that covers a partial fare difference, resulting in insufficient payment for the full reservation change.",
              "A user tries to change the cabin class for certain flight segments without updating all flights in the reservation, resulting in an inconsistent cabin class within the reservation.",
              "A user tries to change the entire reservation to business class but their payment method is actually a gift card with a balance insufficient to cover the necessary fare difference, violating payment requirement policies.",
              "A user updates their reservation's cabin class across multiple flights but improperly inputs payment details, leading to a request that lacks coverage for every part of the cabin fare change."
            ]
          },
          {
            "name": "Cabin Uniformity Requirement",
            "description": "Cabin class must be the same across all flights in a reservation.",
            "references": [
              "Change cabin: all reservations, including basic economy, can change cabin without changing the flights. Cabin changes require the user to pay for the difference between their current cabin and the new cabin class. Cabin class must be the same across all the flights in the same reservation; changing cabin for just one flight segment is not possible."
            ],
            "compliance_examples": [
              "A user updates a reservation so all flights are reassigned to economy class, ensuring uniform cabin class and complying with the policy.",
              "The reservation is modified to have all flights in business class, maintaining a consistent cabin class across the entire reservation as per the policy.",
              "Both flight segments in a round-trip reservation are changed to the same cabin class, such as economy, meeting the Cabin Uniformity Requirement."
            ],
            "violation_examples": [
              "A reservation is updated with mixed cabin classes, such as economy and business, across different flights within the same reservation. This violates the policy requiring uniform cabin class.",
              "A user changes one flight to economy and another to basic economy within a reservation, failing the Cabin Uniformity Requirement that mandates the same cabin class for all flights."
            ]
          },
          {
            "name": "Payment Method Requirement for Flight Changes",
            "description": "Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.",
            "references": [
              "<p>Payment: If the flights are changed, the user needs to provide one gift card or credit card for payment or refund method. The agent should ask for the payment or refund method instead.</p>"
            ],
            "compliance_examples": [
              "The user requests a flight change and provides a valid credit card from their profile, satisfying the policy requirement for payment method.",
              "Flight changes are applied after the user selects a valid gift card from their profile for payment, in line with the policy.",
              "Users update their flight details and use a valid credit card linked to their profile for payment, fully complying with the policy guidelines."
            ],
            "violation_examples": [
              "A user attempts to change flights in a reservation without providing any valid payment information such as a gift card or credit card linked to their profile, which contravenes the policy.",
              "A flight update process begins with the user providing only a certificate as payment, despite the requirement for a gift card or credit card.",
              "Whilst trying to modify their flight itinerary, the user neglects to choose any valid payment method from their profile, which violates the mandatory payment method requirement.",
              "A user insists on using a payment method not linked to their profile, such as a friend's credit card, defying the policy's requirement for payment methods to be from the user's profile."
            ]
          },
          {
            "name": "Flight Modification API Limitation Check",
            "description": "Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.",
            "references": [
              "Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!"
            ],
            "compliance_examples": [
              "An agent updates a reservation by changing the flight times while preserving the original cabin class, origin, destination, and trip type, complying with the policy requirements.",
              "Update reservation flights with the same 'origin' and 'destination', ensuring no changes in basic structure, and manually verify segment prices, complying with the policy.",
              "The agent modifies a reservation by adding additional flight segments while original flight details, including trip type and destination, remain unchanged, adhering to the policy.",
              "Keeping the flight segments unchanged and manually verifying that the prices remain the same while modifying flights in a business cabin reservation complies with the policy.",
              "The agent updates a reservation to change seat preference while ensuring the origin, destination, and trip type are consistent with the initial booking, meeting policy criteria."
            ],
            "violation_examples": [
              "An agent attempts to use the Flight Modification API to change the cabin class of a reservation booked under 'basic_economy'. This violates the policy since 'basic_economy' flights are unmodifiable.",
              "The agent changes the origin from 'SFO' to 'LAX' in a reservation update, violating the policy as the origin must remain unchanged.",
              "Changing the destination from 'JFK' to 'BOS' during a reservation update violates the policy because the destination must remain unchanged.",
              "An agent updates a flight reservation from a 'round_trip' to a 'one_way' trip, violating the policy since the trip type cannot be altered.",
              "An agent uses the API to modify a flight reservation without manually verifying the prices of retained flight segments, violating the policy that requires agents to confirm original rates manually."
            ]
          },
          {
            "name": "Consistency Across Flight Segments",
            "description": "When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.",
            "references": [
              "<p>Change flights: Basic economy flights cannot be modified. Other reservations can be modified without changing the origin, destination, and trip type. Some flight segments can be kept, but their prices will not be updated based on the current price. The API does not check these for the agent, so the agent must make sure the rules apply before calling the API!</p>"
            ],
            "compliance_examples": [
              "A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.",
              "When modifying an itinerary, the agent ensures the flights array contains every flight segment from the original reservation, even those that were not changed, complying fully with the policy.",
              "A reservation update for altering the cabin class is processed correctly with all segments kept in the flights array to maintain consistency as per policy rules."
            ],
            "violation_examples": [
              "A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.",
              "An agent updates the reservation for a flight change but mistakenly excludes connecting segments that were part of the same trip, leading to an incomplete submission.",
              "During a reservation update involving a cabin class upgrade, the flights array only lists flights under the new cabin class, excluding previously booked ancillary services segments, violating the policy."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_update_reservation_flights",
      "guard_file": {
        "file_name": "airline/update_reservation_flights/guard_update_reservation_flights.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.update_reservation_flights.guard_explicit_user_confirmation_required import guard_explicit_user_confirmation_required\nfrom airline.update_reservation_flights.guard_cannot_modify_basic_economy_flights import guard_cannot_modify_basic_economy_flights\nfrom airline.update_reservation_flights.guard_cabin_change_payment_requirement import guard_cabin_change_payment_requirement\nfrom airline.update_reservation_flights.guard_cabin_uniformity_requirement import guard_cabin_uniformity_requirement\nfrom airline.update_reservation_flights.guard_payment_method_requirement_for_flight_changes import guard_payment_method_requirement_for_flight_changes\nfrom airline.update_reservation_flights.guard_flight_modification_api_limitation_check import guard_flight_modification_api_limitation_check\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\n\n\ndef guard_update_reservation_flights(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n         \n    \"\"\"\n    \n    guard_explicit_user_confirmation_required(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cannot_modify_basic_economy_flights(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_change_payment_requirement(history, api, reservation_id, cabin, flights, payment_id)\n    guard_cabin_uniformity_requirement(history, api, reservation_id, cabin, flights, payment_id)\n    guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n    guard_flight_modification_api_limitation_check(history, api, reservation_id, cabin, flights, payment_id)\n    guard_consistency_across_flight_segments(history, api, reservation_id, cabin, flights, payment_id)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/update_reservation_flights/guard_explicit_user_confirmation_required.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_explicit_user_confirmation_required(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed. Compliance cannot be pre-validated by ToolX; it requires interaction history to confirm user consent.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    \n    Returns:\n        None. Raises PolicyViolationException if explicit user confirmation is not found in history.\n    \"\"\"\n    # Ask the history if explicit confirmation ('yes') was given by the user after presenting all action details\n    # This is required by policy and cannot be pre-validated by ToolX\n    # Only explicit 'yes' is accepted, not implicit consent\n    confirmed = history.ask_bool(\n        \"Did the user explicitly say 'yes' to confirm the presented reservation update details (including flights, baggage, cabin class, or passenger information)? Only explicit 'yes' is valid.\"\n    )\n    if not confirmed:\n        raise PolicyViolationException(\n            \"Explicit user confirmation ('yes') is required before updating reservation details. No valid confirmation found in chat history.\"\n        )\n"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cannot_modify_basic_economy_flights.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cannot_modify_basic_economy_flights(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Basic economy flights in a reservation cannot be modified at all. For reservations that are not classified as basic economy, modifications are allowed but must not change the origin, destination, or trip type. It is critical for agents to verify this before invoking the update_reservation_flights tool.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_change_payment_requirement.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_change_payment_requirement(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: ToolX can be used to modify a reservation's cabin class. Ensure a uniform cabin class change across all flights within the reservation. Make sure the user pays the fare difference between the current cabin class and the new cabin class for the entire reservation as partial changes are disallowed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_cabin_uniformity_requirement.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_cabin_uniformity_requirement(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Cabin class must be the same across all flights in a reservation.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_payment_method_requirement_for_flight_changes.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_payment_method_requirement_for_flight_changes(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    Raises:\n        PolicyViolationException: If the payment method is not a valid gift card or credit card from the user's profile.\n    \"\"\"\n    # Get user_id from reservation\n    reservation = api.get_reservation_details(reservation_id)\n    user_id = reservation.user_id\n    user = api.get_user_details(user_id)\n    payment_methods = user.payment_methods\n\n    # Check if payment_id is in user's payment_methods\n    if payment_id not in payment_methods:\n        raise PolicyViolationException(\"Payment method must be from user's profile.\")\n    method = payment_methods[payment_id]\n    # Only allow gift card or credit card\n    if getattr(method, 'source', None) not in ['gift_card', 'credit_card']:\n        raise PolicyViolationException(\"Payment method must be a valid gift card or credit card from user's profile.\")\n    # If payment_id is valid and of correct type, pass\n    # Otherwise, PolicyViolationException is raised above\n"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_flight_modification_api_limitation_check.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_modification_api_limitation_check(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: Agents must verify the following before using the Flight Modification API: Basic economy flights are unmodifiable. For other flight reservations, ensure that origin, destination, and trip type remain unchanged from the initial booking. Prices for flight segments retained stay at original rates, not updated by the API. Manual validation of segment prices is required.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if the a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/update_reservation_flights/guard_consistency_across_flight_segments.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_consistency_across_flight_segments(history: ChatHistory, api: I_Airline, reservation_id: str, cabin: Literal['business', 'economy', 'basic_economy'], flights: list[FlightInfo | dict], payment_id: str):\n    \"\"\"\n    Policy to check: When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        reservation_id: The reservation ID, such as 'ZFA04Y'.\n        cabin: The cabin class of the reservation\n        flights: An array of objects containing details about each piece of flight in the ENTIRE new reservation. Even if a flight segment is not changed, it should still be included in the array.\n        payment_id: The payment id stored in user profile, such as 'credit_card_7815826', 'gift_card_7815826', 'certificate_7815826'.\n    Raises:\n        PolicyViolationException: If not all original flight segments are included in the flights argument.\n    \"\"\"\n    # Get the original reservation details\n    reservation = api.get_reservation_details(reservation_id)\n    original_segments = reservation.flights\n    # Build a set of (flight_number, date) for original segments\n    original_set = set((seg.flight_number, seg.date) for seg in original_segments)\n    # Build a set of (flight_number, date) for provided flights\n    provided_set = set()\n    for f in flights:\n        if isinstance(f, dict):\n            flight_number = f.get('flight_number')\n            date = f.get('date')\n        else:\n            flight_number = f.flight_number\n            date = f.date\n        provided_set.add((flight_number, date))\n    # Check that all original segments are present in the provided flights\n    if not original_set.issubset(provided_set):\n        raise PolicyViolationException(\"All original flight segments must be included in the flights array, even if unchanged.\")\n"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/update_reservation_flights/test_guard_explicit_user_confirmation_required.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_explicit_user_confirmation_required import guard_explicit_user_confirmation_required\nfrom airline.airline_types import *\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestExplicitUserConfirmationRequired:\n    def test_compliance_user_says_yes_after_details(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"The agent presents the updated flight itinerary, cabin class changes, and passenger adjustments in detail and waits for the user to reply 'yes' before proceeding, ensuring compliance with the required user confirmation.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User explicitly said 'yes'\n        api = MagicMock(spec=I_Airline)\n        # Mock get_reservation_details\n        reservation = Reservation(\n            reservation_id=\"ZFA04Y\",\n            user_id=\"sara_doe_496\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-05-01\", price=500)],\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=500)],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda reservation_id: reservation if reservation_id == \"ZFA04Y\" else None\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-05-01\")]\n        # Should NOT raise\n        try:\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"ZFA04Y\",\n                cabin=\"business\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_compliance_confirmation_after_email(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"User interaction history reveals explicit verbal confirmation ('yes') after presenting action details via email, allowing the update_reservation_flights tool to proceed in accordance with policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User replied 'yes' via email\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"LAX\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT002\", origin=\"LAX\", destination=\"JFK\", date=\"2024-06-01\", price=300)],\n            passengers=[Passenger(first_name=\"John\", last_name=\"Smith\", dob=\"1985-02-10\")],\n            payment_history=[Payment(payment_id=\"gift_card_7815826\", amount=300)],\n            created_at=(datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT002\", date=\"2024-06-01\")]\n        try:\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"8JX2WO\",\n                cabin=\"economy\",\n                flights=flights,\n                payment_id=\"gift_card_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_compliance_summary_and_yes(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"Before confirming flight changes, the system shows a summary detailing new flight segments and asks, 'Do you confirm?' The user responds with 'yes', thereby validating the action and meeting the explicit consent requirement.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User said 'yes' after summary\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_456\",\n            origin=\"ORD\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"HAT003\", origin=\"ORD\", destination=\"MIA\", date=\"2024-07-01\", price=200)],\n            passengers=[Passenger(first_name=\"Alice\", last_name=\"Brown\", dob=\"1992-11-23\")],\n            payment_history=[Payment(payment_id=\"certificate_7815826\", amount=200)],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT003\", date=\"2024-07-01\")]\n        try:\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"ORDMIA1\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                payment_id=\"certificate_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_compliance_email_waits_for_yes(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"Flight changes are sent to the user's registered email address with clear action details, and the system waits until the user replies 'yes' before executing any update, ensuring compliance with the policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User replied 'yes' via email\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_789\",\n            origin=\"SEA\",\n            destination=\"ATL\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT004\", origin=\"SEA\", destination=\"ATL\", date=\"2024-08-01\", price=400)],\n            passengers=[Passenger(first_name=\"Bob\", last_name=\"Lee\", dob=\"1978-09-12\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=400)],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT004\", date=\"2024-08-01\")]\n        try:\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"SEAATL2\",\n                cabin=\"economy\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_compliance_live_chat_yes(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"A detailed list of updates, including flight, baggage, and cabin class changes, is shown to the user during a live chat, and the agent proceeds only after a clear 'yes' from the user, validating adherence to the explicit confirmation policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User said 'yes' in live chat\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_321\",\n            origin=\"BOS\",\n            destination=\"DEN\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT005\", origin=\"BOS\", destination=\"DEN\", date=\"2024-09-01\", price=600)],\n            passengers=[Passenger(first_name=\"Carol\", last_name=\"King\", dob=\"1980-03-15\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=600)],\n            created_at=(datetime.now() - timedelta(hours=12)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=2,\n            insurance=\"yes\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT005\", date=\"2024-09-01\")]\n        try:\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"BOSDEN3\",\n                cabin=\"business\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e.message}\")\n\n    def test_violation_no_confirmation(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"An agent updates the flight details of a reservation without asking the user for confirmation, proceeding with changes based on assumed preferences, which violates the requirement for explicit user consent.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # User did NOT say 'yes'\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_111\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT006\", origin=\"SFO\", destination=\"JFK\", date=\"2024-10-01\", price=700)],\n            passengers=[Passenger(first_name=\"Eve\", last_name=\"White\", dob=\"1995-07-07\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=700)],\n            created_at=(datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=1,\n            insurance=\"no\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT006\", date=\"2024-10-01\")]\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"SFOJFK4\",\n                cabin=\"business\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n\n    def test_violation_auto_update_no_details(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"The system automatically applies updates to the reservation based on recent user activity without presenting details or receiving explicit confirmation, failing to adhere to the explicit confirmation policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # No explicit confirmation\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_222\",\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT007\", origin=\"LAX\", destination=\"ORD\", date=\"2024-11-01\", price=350)],\n            passengers=[Passenger(first_name=\"Frank\", last_name=\"Green\", dob=\"1988-12-30\")],\n            payment_history=[Payment(payment_id=\"gift_card_7815826\", amount=350)],\n            created_at=(datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=0,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT007\", date=\"2024-11-01\")]\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"LAXORD5\",\n                cabin=\"economy\",\n                flights=flights,\n                payment_id=\"gift_card_7815826\"\n            )\n\n    def test_violation_no_explicit_yes(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"Updates to the cabin class and passenger information are executed without the user explicitly saying 'yes', after merely highlighting them, leading to non-compliance with the explicit consent requirement.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # User did not say 'yes'\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_333\",\n            origin=\"ATL\",\n            destination=\"SEA\",\n            flight_type=\"round_trip\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=\"HAT008\", origin=\"ATL\", destination=\"SEA\", date=\"2024-12-01\", price=250)],\n            passengers=[Passenger(first_name=\"Grace\", last_name=\"Black\", dob=\"1993-05-21\")],\n            payment_history=[Payment(payment_id=\"certificate_7815826\", amount=250)],\n            created_at=(datetime.now() - timedelta(days=15)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT008\", date=\"2024-12-01\")]\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"ATLSEA6\",\n                cabin=\"basic_economy\",\n                flights=flights,\n                payment_id=\"certificate_7815826\"\n            )\n\n    def test_violation_implicit_consent(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"A reservation update is initiated after receiving implicit consent from phrases like 'okay' or 'sounds good', rather than a clear 'yes', which does not meet the policy's explicit confirmation standard.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # Only implicit consent, not 'yes'\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_444\",\n            origin=\"DEN\",\n            destination=\"BOS\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=\"HAT009\", origin=\"DEN\", destination=\"BOS\", date=\"2025-01-01\", price=450)],\n            passengers=[Passenger(first_name=\"Henry\", last_name=\"Stone\", dob=\"1982-08-19\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=450)],\n            created_at=(datetime.now() - timedelta(days=20)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT009\", date=\"2025-01-01\")]\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"DENBOS7\",\n                cabin=\"economy\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n\n    def test_violation_no_prompt_before_finalize(self):\n        \"\"\"\n        Policy: \"Before using ToolX for reservation updates including flights, baggage, cabin class, or passenger information, ensure you present all action details to the user in a clear manner and receive their explicit confirmation (yes) to proceed.\"\n        Example: \"The system pre-fills all updates regarding flights and baggage but does not prompt the user for confirmation before finalizing, violating the policy's demand for explicit consent.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # No prompt for confirmation\n        api = MagicMock(spec=I_Airline)\n        api.get_reservation_details.side_effect = lambda reservation_id: Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_555\",\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"round_trip\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=\"HAT010\", origin=\"JFK\", destination=\"LAX\", date=\"2025-02-01\", price=800)],\n            passengers=[Passenger(first_name=\"Ivy\", last_name=\"Gold\", dob=\"1975-04-30\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=800)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=3,\n            nonfree_baggages=2,\n            insurance=\"yes\",\n            status=None\n        )\n        flights = [FlightInfo(flight_number=\"HAT010\", date=\"2025-02-01\")]\n        with pytest.raises(PolicyViolationException):\n            guard_explicit_user_confirmation_required(\n                history,\n                api,\n                reservation_id=\"JFKLAX8\",\n                cabin=\"business\",\n                flights=flights,\n                payment_id=\"credit_card_7815826\"\n            )\n"
        },
        null,
        null,
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_payment_method_requirement_for_flight_changes.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_payment_method_requirement_for_flight_changes import guard_payment_method_requirement_for_flight_changes\nfrom airline.i_airline import I_Airline\nfrom airline.airline_types import *\n\nclass TestGuardPaymentMethodRequirementForFlightChanges:\n    # --- Compliance Examples ---\n\n    def test_valid_credit_card_provided(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"The user requests a flight change and provides a valid credit card from their profile, satisfying the policy requirement for payment method.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_123\"\n        payment_id = \"credit_card_7815826\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\")]\n        # Mock user with valid credit card\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"John\", last_name=\"Doe\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"NYC\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n            email=\"john.doe@example.com\",\n            dob=\"1990-01-01\",\n            payment_methods={\n                payment_id: CreditCard(source=\"credit_card\", id=payment_id, brand=\"visa\", last_four=\"1234\")\n            },\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT001\", origin=\"JFK\", destination=\"LAX\", date=\"2024-07-01\", price=300)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        # Should not raise\n        try:\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e}\")\n\n    def test_valid_gift_card_provided(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"Flight changes are applied after the user selects a valid gift card from their profile for payment, in line with the policy.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_456\"\n        payment_id = \"gift_card_123456\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT002\", date=\"2024-08-01\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Jane\", last_name=\"Smith\"),\n            address=Address(address1=\"456 Elm St\", address2=None, city=\"LA\", country=\"USA\", state=\"CA\", zip=\"90001\"),\n            email=\"jane.smith@example.com\",\n            dob=\"1985-05-05\",\n            payment_methods={\n                payment_id: GiftCard(source=\"gift_card\", id=payment_id, amount=200.0)\n            },\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"LAX\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT002\", origin=\"LAX\", destination=\"JFK\", date=\"2024-08-01\", price=500)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        try:\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e}\")\n\n    def test_valid_credit_card_linked_to_profile(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"Users update their flight details and use a valid credit card linked to their profile for payment, fully complying with the policy guidelines.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_789\"\n        payment_id = \"credit_card_999999\"\n        cabin = \"basic_economy\"\n        flights = [FlightInfo(flight_number=\"HAT003\", date=\"2024-09-01\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Alice\", last_name=\"Brown\"),\n            address=Address(address1=\"789 Oak St\", address2=None, city=\"Chicago\", country=\"USA\", state=\"IL\", zip=\"60601\"),\n            email=\"alice.brown@example.com\",\n            dob=\"1995-09-09\",\n            payment_methods={\n                payment_id: CreditCard(source=\"credit_card\", id=payment_id, brand=\"mastercard\", last_four=\"5678\")\n            },\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"ORD\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT003\", origin=\"ORD\", destination=\"MIA\", date=\"2024-09-01\", price=400)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        try:\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: Expected compliance, but got PolicyViolationException: {e}\")\n\n    # --- Violation Examples ---\n\n    def test_no_valid_payment_method_provided(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"A user attempts to change flights in a reservation without providing any valid payment information such as a gift card or credit card linked to their profile, which contravenes the policy.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_321\"\n        payment_id = \"\"\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT004\", date=\"2024-10-01\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Bob\", last_name=\"Green\"),\n            address=Address(address1=\"321 Pine St\", address2=None, city=\"Boston\", country=\"USA\", state=\"MA\", zip=\"02101\"),\n            email=\"bob.green@example.com\",\n            dob=\"1980-12-12\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"BOS\",\n            destination=\"SEA\",\n            flight_type=\"one_way\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT004\", origin=\"BOS\", destination=\"SEA\", date=\"2024-10-01\", price=350)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n\n    def test_certificate_only_as_payment(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"A flight update process begins with the user providing only a certificate as payment, despite the requirement for a gift card or credit card.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_654\"\n        payment_id = \"certificate_654321\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT005\", date=\"2024-11-01\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Carol\", last_name=\"White\"),\n            address=Address(address1=\"654 Maple St\", address2=None, city=\"Houston\", country=\"USA\", state=\"TX\", zip=\"77001\"),\n            email=\"carol.white@example.com\",\n            dob=\"1975-03-03\",\n            payment_methods={\n                payment_id: Certificate(source=\"certificate\", id=payment_id, amount=100.0)\n            },\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"IAH\",\n            destination=\"ATL\",\n            flight_type=\"round_trip\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT005\", origin=\"IAH\", destination=\"ATL\", date=\"2024-11-01\", price=600)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n\n    def test_no_payment_method_selected(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"Whilst trying to modify their flight itinerary, the user neglects to choose any valid payment method from their profile, which violates the mandatory payment method requirement.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_987\"\n        payment_id = None\n        cabin = \"economy\"\n        flights = [FlightInfo(flight_number=\"HAT006\", date=\"2024-12-01\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"David\", last_name=\"Black\"),\n            address=Address(address1=\"987 Cedar St\", address2=None, city=\"Miami\", country=\"USA\", state=\"FL\", zip=\"33101\"),\n            email=\"david.black@example.com\",\n            dob=\"1992-07-07\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"MIA\",\n            destination=\"ORD\",\n            flight_type=\"one_way\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT006\", origin=\"MIA\", destination=\"ORD\", date=\"2024-12-01\", price=450)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=4)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n\n    def test_payment_method_not_linked_to_profile(self):\n        \"\"\"\n        Policy: \"Whenever flights in a reservation are changed, ensure the user provides one valid gift card or credit card from their profile as the payment or refund method. Without this, flight changes cannot be processed.\"\n        Example: \"A user insists on using a payment method not linked to their profile, such as a friend's credit card, defying the policy's requirement for payment methods to be from the user's profile.\"\n        \"\"\"\n        history = MagicMock()\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        user_id = \"user_111\"\n        payment_id = \"credit_card_000000\"\n        cabin = \"business\"\n        flights = [FlightInfo(flight_number=\"HAT007\", date=\"2025-01-01\")]\n        # User has no payment methods matching payment_id\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Eve\", last_name=\"Gray\"),\n            address=Address(address1=\"111 Spruce St\", address2=None, city=\"San Francisco\", country=\"USA\", state=\"CA\", zip=\"94101\"),\n            email=\"eve.gray@example.com\",\n            dob=\"1988-11-11\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"SFO\",\n            destination=\"LAS\",\n            flight_type=\"one_way\",\n            cabin=cabin,\n            flights=[ReservationFlight(flight_number=\"HAT007\", origin=\"SFO\", destination=\"LAS\", date=\"2025-01-01\", price=250)],\n            passengers=[],\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        with pytest.raises(PolicyViolationException):\n            guard_payment_method_requirement_for_flight_changes(history, api, reservation_id, cabin, flights, payment_id)\n"
        },
        null,
        {
          "file_name": "tests/update_reservation_flights/test_guard_consistency_across_flight_segments.py",
          "content": "from unittest.mock import MagicMock, patch\nimport pytest\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.update_reservation_flights.guard_consistency_across_flight_segments import guard_consistency_across_flight_segments\nfrom airline.airline_types import *\nfrom airline.i_airline import *\nfrom datetime import datetime, timedelta\n\nclass TestConsistencyAcrossFlightSegments:\n    def test_update_with_all_segments_included(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user's round-trip reservation is successfully updated with all flights listed, including the unchanged return flight segment, adhering to the policy requirement.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        # Mock get_reservation_details to return a reservation with two segments\n        reservation_id = \"ZFA04Y\"\n        original_flights = [\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-07-01\", price=300),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-07-10\", price=320)\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=original_flights,\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=620)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        flights_update = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\"),\n            FlightInfo(flight_number=\"HAT002\", date=\"2024-07-10\")\n        ]\n        # Should not raise\n        try:\n            guard_consistency_across_flight_segments(history, api, reservation_id, \"economy\", flights_update, \"credit_card_7815826\")\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: expected no PolicyViolationException, but got: {e.message}\")\n\n    def test_update_with_only_altered_segment(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A user attempts to update their reservation but only includes the altered flight segment in the flights array, omitting the unchanged flight segments.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_flights = [\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-07-01\", price=300),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-07-10\", price=320)\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=original_flights,\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=620)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        # Only altered segment included\n        flights_update = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(history, api, reservation_id, \"economy\", flights_update, \"credit_card_7815826\")\n\n    def test_update_excludes_connecting_segments(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"An agent updates the reservation for a flight change but mistakenly excludes connecting segments that were part of the same trip, leading to an incomplete submission.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_flights = [\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"ORD\", date=\"2024-07-01\", price=200),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"ORD\", destination=\"JFK\", date=\"2024-07-01\", price=150),\n            ReservationFlight(flight_number=\"HAT003\", origin=\"JFK\", destination=\"SFO\", date=\"2024-07-10\", price=320)\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=original_flights,\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=670)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        # Exclude connecting segment\n        flights_update = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\"),\n            FlightInfo(flight_number=\"HAT003\", date=\"2024-07-10\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(history, api, reservation_id, \"economy\", flights_update, \"credit_card_7815826\")\n\n    def test_update_only_new_cabin_segments(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"During a reservation update involving a cabin class upgrade, the flights array only lists flights under the new cabin class, excluding previously booked ancillary services segments, violating the policy.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_flights = [\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-07-01\", price=300),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-07-10\", price=320)\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=original_flights,\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=620)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        # Only flights under new cabin class included, ancillary segments excluded\n        flights_update = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\")\n        ]\n        with pytest.raises(PolicyViolationException):\n            guard_consistency_across_flight_segments(history, api, reservation_id, \"business\", flights_update, \"credit_card_7815826\")\n\n    def test_update_all_segments_for_cabin_change(self):\n        \"\"\"\n        Policy: \"When updating a reservation, all flight segments must be included in the list of flights provided, regardless of whether they have been altered or not.\"\n        Example: \"A reservation update for altering the cabin class is processed correctly with all segments kept in the flights array to maintain consistency as per policy rules.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        api = MagicMock(spec=I_Airline)\n        reservation_id = \"ZFA04Y\"\n        original_flights = [\n            ReservationFlight(flight_number=\"HAT001\", origin=\"SFO\", destination=\"JFK\", date=\"2024-07-01\", price=300),\n            ReservationFlight(flight_number=\"HAT002\", origin=\"JFK\", destination=\"SFO\", date=\"2024-07-10\", price=320)\n        ]\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=\"user_123\",\n            origin=\"SFO\",\n            destination=\"JFK\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=original_flights,\n            passengers=[Passenger(first_name=\"Sara\", last_name=\"Doe\", dob=\"1990-04-05\")],\n            payment_history=[Payment(payment_id=\"credit_card_7815826\", amount=620)],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        flights_update = [\n            FlightInfo(flight_number=\"HAT001\", date=\"2024-07-01\"),\n            FlightInfo(flight_number=\"HAT002\", date=\"2024-07-10\")\n        ]\n        # Should not raise\n        try:\n            guard_consistency_across_flight_segments(history, api, reservation_id, \"business\", flights_update, \"credit_card_7815826\")\n        except PolicyViolationException as e:\n            pytest.fail(f\"Test failed: expected no PolicyViolationException, but got: {e.message}\")\n"
        }
      ]
    }
  },
  "moved":{
    "~send_certificate": {
      "tool": {
        "tool_name": "send_certificate",
        "policy_items": [
          {
            "name": "Compensation for cancelled or delayed flights",
            "description": "Agents can issue compensation certificates using the `send_certificate` tool, but only for users who meet specific eligibility criteria: they must be silver/gold members, have travel insurance, or travel in business class. Compensation amounts are $100 per passenger for cancellations, and $50 per passenger for delays if the reservation is altered as requested by the user. Before sending compensation, the agent must ensure eligibility by verifying the user's membership, whether they have purchased travel insurance, the class they are flying, and the status of the flight.",
            "references": [
              "If the user is silver/gold member or has travel insurance or flies business, and complains about cancelled flights in a reservation, the agent can offer a certificate as a gesture after confirming the facts, with the amount being $100 times the number of passengers.",
              "If the user is silver/gold member or has travel insurance or flies business, and complains about delayed flights in a reservation and wants to change or cancel the reservation, the agent can offer a certificate as a gesture after confirming the facts and changing or cancelling the reservation, with the amount being $50 times the number of passengers.",
              "Do not proactively offer these unless the user complains about the situation and explicitly asks for some compensation. Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy."
            ],
            "compliance_examples": [
              "After a silver member complains about their flight being canceled, the agent verifies membership and sends a certificate of $100 per passenger to the two passengers in the reservation.",
              "The agent checks the user profile and confirms the user is a gold member with travel insurance who has just experienced a flight delay, and has requested a reservation change, thus issuing a certificate of $50 per passenger for the three passengers.",
              "A user, traveling in business class, complains about a flight cancellation. The agent verifies this and issues a $100 certificate per passenger after confirming the cancellation, following the policy's eligibility criteria.",
              "The agent issues a $50 certificate per passenger following a user's complaint about delayed flights and altered reservations. The user is confirmed to have travel insurance, complying with the policy.",
              "For a business class traveler who complained about flight cancellations, the agent sends $100 compensation per passenger after verifying all eligibility conditions and the affectation to the reservation.",
              "After verifying the user's status as a gold member with travel insurance, who has reported a flight delay, the agent confirms the reservation alteration and issues a $50 certificate per passenger, meeting policy requirements.",
              "A complaint from a user traveling in business class triggers the agent to check the flight status and verify eligibility criteria before issuing a $100 certificate for a canceled flight."
            ],
            "violation_examples": [
              "An agent tries to send a $100 compensation certificate for a canceled flight to a regular member who does not have travel insurance and is traveling in basic economy class, violating the eligibility criteria.",
              "An agent issues a compensation certificate of $50 for flight delay without confirming the user is traveling in business class, has travel insurance, or membership status and fails to verify if a reservation change was requested.",
              "A certificate is sent to a user without verifying their eligibility. The user is neither a silver/gold member nor has travel insurance, traveling in economy, and did not complain about the canceled flight, which is a breach of policy requirements.",
              "The agent sends compensation for a delay without ensuring the reservation is altered as per user request and fails to verify the user's membership status, travel insurance, or business class booking.",
              "An agent sends a compensation certificate for a canceled flight without verifications: whether the user is traveling in business class, has travel insurance, or membership status.",
              "A certificate is issued for a delayed flight without confirming if the user had actually complained, requested a reservation change, or met eligibility criteria such as silver/gold membership or insurance holding."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_send_certificate",
      "guard_file": {
        "file_name": "airline/send_certificate/guard_send_certificate.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.send_certificate.guard_compensation_for_cancelled_or_delayed_flights import guard_compensation_for_cancelled_or_delayed_flights\n\n\ndef guard_send_certificate(history: ChatHistory, api: I_Airline, user_id: str, amount: int):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n         \n    \"\"\"\n    \n    guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/send_certificate/guard_compensation_for_cancelled_or_delayed_flights.py",
          "content": "from typing import *\nfrom rt_toolguard.data_types import ChatHistory, PolicyViolationException\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_compensation_for_cancelled_or_delayed_flights(history: ChatHistory, api: I_Airline, user_id: str, amount: int):\n    \"\"\"\n    Policy to check: Agents can issue compensation certificates using the `send_certificate` tool, but only for users who meet specific eligibility criteria: they must be silver/gold members, have travel insurance, or travel in business class. Compensation amounts are $100 per passenger for cancellations, and $50 per passenger for delays if the reservation is altered as requested by the user. Before sending compensation, the agent must ensure eligibility by verifying the user's membership, whether they have purchased travel insurance, the class they are flying, and the status of the flight.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        user_id: The ID of the user to book the reservation, such as 'sara_doe_496'.\n        amount: The amount of the certificate to send.\n    \"\"\"\n    # Step 1: Confirm user explicitly complained and requested compensation\n    if not history.ask_bool(\"Did the user explicitly complain about a cancelled or delayed flight and request compensation?\"):\n        raise PolicyViolationException(\"User did not complain or request compensation.\")\n\n    # Step 2: Get user details\n    user = api.get_user_details(user_id)\n    membership = user.membership\n    reservation_ids = user.reservations\n\n    # Step 3: Find the most recent affected reservation (assume last one)\n    if not reservation_ids:\n        raise PolicyViolationException(\"No reservations found for user.\")\n    reservation = api.get_reservation_details(reservation_ids[-1])\n\n    # Step 4: Check eligibility\n    # Policy: Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy.\n    eligible = False\n    if membership in ('gold', 'silver'):\n        eligible = True\n    if reservation.insurance == 'yes':\n        eligible = True\n    if reservation.cabin == 'business':\n        eligible = True\n    # If user is regular, no insurance, and not business class, not eligible\n    if not eligible:\n        raise PolicyViolationException(\"User is not eligible for compensation: must be silver/gold member, have insurance, or travel in business class.\")\n\n    # Step 5: Check flight status and compensation amount\n    num_passengers = len(reservation.passengers)\n    flights = reservation.flights\n    cancelled = False\n    delayed = False\n    for flight in flights:\n        status = api.get_flight_status(flight.flight_number, flight.date)\n        if status == 'cancelled':\n            cancelled = True\n        if status == 'delayed':\n            delayed = True\n    # Step 6: Validate compensation amount and reservation alteration for delays\n    if cancelled:\n        expected_amount = 100 * num_passengers\n        if amount != expected_amount:\n            raise PolicyViolationException(f\"Compensation for cancelled flights must be $100 per passenger. Expected: {expected_amount}, got: {amount}.\")\n    elif delayed:\n        # Must confirm reservation was altered as requested by user\n        if not history.ask_bool(\"Did the user request a reservation change or cancellation due to the delay, and was the reservation altered as requested?\"):\n            raise PolicyViolationException(\"Compensation for delayed flights requires reservation to be altered as requested by the user.\")\n        expected_amount = 50 * num_passengers\n        if amount != expected_amount:\n            raise PolicyViolationException(f\"Compensation for delayed flights must be $50 per passenger. Expected: {expected_amount}, got: {amount}.\")\n    else:\n        raise PolicyViolationException(\"No cancelled or delayed flights found in reservation.\")\n\n    # All checks passed\n    return\n"
        }
      ],
      "test_files": [
        {
          "file_name": "tests/send_certificate/test_guard_compensation_for_cancelled_or_delayed_flights.py",
          "content": "from unittest.mock import MagicMock\nimport pytest\nfrom datetime import datetime, timedelta\nfrom rt_toolguard.data_types import PolicyViolationException\nfrom airline.send_certificate.guard_compensation_for_cancelled_or_delayed_flights import guard_compensation_for_cancelled_or_delayed_flights\nfrom airline.airline_types import *\nfrom airline.i_airline import *\n\nclass TestCompensationForCancelledOrDelayedFlights:\n    # --- COMPLIANCE EXAMPLES ---\n    def test_silver_member_cancelled_flight_100_per_passenger(self):\n        \"\"\"\n        Policy: \"Agents can issue compensation certificates using the `send_certificate` tool, but only for users who meet specific eligibility criteria: they must be silver/gold members, have travel insurance, or travel in business class. Compensation amounts are $100 per passenger for cancellations.\"\n        Example: \"After a silver member complains about their flight being canceled, the agent verifies membership and sends a certificate of $100 per passenger to the two passengers in the reservation.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User complained and requested compensation\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n\n        user_id = \"silver_user_001\"\n        reservation_id = \"RES12345\"\n        flight_number = \"FL1001\"\n        flight_date = (datetime.now() - timedelta(days=1)).strftime(\"%Y-%m-%d\")\n        passengers = [\n            Passenger(first_name=\"Alice\", last_name=\"Smith\", dob=\"1990-01-01\"),\n            Passenger(first_name=\"Bob\", last_name=\"Smith\", dob=\"1992-02-02\")\n        ]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Alice\", last_name=\"Smith\"),\n            address=Address(address1=\"123 Main St\", address2=None, city=\"NYC\", country=\"USA\", state=\"NY\", zip=\"10001\"),\n            email=\"alice@example.com\",\n            dob=\"1990-01-01\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"silver\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"JFK\",\n            destination=\"LAX\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"JFK\", destination=\"LAX\", date=flight_date, price=300)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=10)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=2,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n        flight_status = \"cancelled\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 100 * len(passengers)\n        # Should NOT raise\n        guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n\n    def test_gold_member_with_insurance_delayed_flight_50_per_passenger(self):\n        \"\"\"\n        Policy: \"Compensation amounts are $50 per passenger for delays if the reservation is altered as requested by the user.\"\n        Example: \"The agent checks the user profile and confirms the user is a gold member with travel insurance who has just experienced a flight delay, and has requested a reservation change, thus issuing a certificate of $50 per passenger for the three passengers.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True  # User complained and requested compensation\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n\n        user_id = \"gold_user_002\"\n        reservation_id = \"RES67890\"\n        flight_number = \"FL2002\"\n        flight_date = (datetime.now() - timedelta(days=2)).strftime(\"%Y-%m-%d\")\n        passengers = [\n            Passenger(first_name=\"Carol\", last_name=\"Jones\", dob=\"1985-03-03\"),\n            Passenger(first_name=\"Dave\", last_name=\"Jones\", dob=\"1987-04-04\"),\n            Passenger(first_name=\"Eve\", last_name=\"Jones\", dob=\"1990-05-05\")\n        ]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Carol\", last_name=\"Jones\"),\n            address=Address(address1=\"456 Elm St\", address2=None, city=\"LA\", country=\"USA\", state=\"CA\", zip=\"90001\"),\n            email=\"carol@example.com\",\n            dob=\"1985-03-03\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"gold\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"LAX\",\n            destination=\"ORD\",\n            flight_type=\"round_trip\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"LAX\", destination=\"ORD\", date=flight_date, price=400)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=20)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=3,\n            nonfree_baggages=1,\n            insurance=\"yes\",\n            status=None\n        )\n        flight_status = \"delayed\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 50 * len(passengers)\n        # Should NOT raise\n        guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n\n    def test_business_class_cancellation_100_per_passenger(self):\n        \"\"\"\n        Policy: \"Agents can issue compensation certificates using the `send_certificate` tool, but only for users who meet specific eligibility criteria: they must be silver/gold members, have travel insurance, or travel in business class. Compensation amounts are $100 per passenger for cancellations.\"\n        Example: \"A user, traveling in business class, complains about a flight cancellation. The agent verifies this and issues a $100 certificate per passenger after confirming the cancellation, following the policy's eligibility criteria.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n\n        user_id = \"biz_user_003\"\n        reservation_id = \"RES24680\"\n        flight_number = \"FL3003\"\n        flight_date = (datetime.now() - timedelta(days=3)).strftime(\"%Y-%m-%d\")\n        passengers = [Passenger(first_name=\"Frank\", last_name=\"Miller\", dob=\"1975-06-06\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Frank\", last_name=\"Miller\"),\n            address=Address(address1=\"789 Oak St\", address2=None, city=\"Chicago\", country=\"USA\", state=\"IL\", zip=\"60601\"),\n            email=\"frank@example.com\",\n            dob=\"1975-06-06\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"ORD\",\n            destination=\"JFK\",\n            flight_type=\"one_way\",\n            cabin=\"business\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"ORD\", destination=\"JFK\", date=flight_date, price=500)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n        flight_status = \"cancelled\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 100 * len(passengers)\n        guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n\n    # --- VIOLATION EXAMPLES ---\n    def test_regular_member_no_insurance_economy_cancellation_should_raise(self):\n        \"\"\"\n        Policy: \"Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy.\"\n        Example: \"An agent tries to send a $100 compensation certificate for a canceled flight to a regular member who does not have travel insurance and is traveling in basic economy class, violating the eligibility criteria.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n\n        user_id = \"reg_user_004\"\n        reservation_id = \"RES13579\"\n        flight_number = \"FL4004\"\n        flight_date = (datetime.now() - timedelta(days=4)).strftime(\"%Y-%m-%d\")\n        passengers = [Passenger(first_name=\"Grace\", last_name=\"Lee\", dob=\"1980-07-07\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Grace\", last_name=\"Lee\"),\n            address=Address(address1=\"321 Pine St\", address2=None, city=\"Boston\", country=\"USA\", state=\"MA\", zip=\"02101\"),\n            email=\"grace@example.com\",\n            dob=\"1980-07-07\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"BOS\",\n            destination=\"MIA\",\n            flight_type=\"one_way\",\n            cabin=\"basic_economy\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"BOS\", destination=\"MIA\", date=flight_date, price=200)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=40)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n        flight_status = \"cancelled\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 100 * len(passengers)\n        with pytest.raises(PolicyViolationException, match=\"User is not eligible for compensation: must be silver/gold member, have insurance, or travel in business class\"):\n            guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n\n    def test_compensation_for_delay_without_eligibility_should_raise(self):\n        \"\"\"\n        Policy: \"Do not compensate if the user is regular member and has no travel insurance and flies (basic) economy.\"\n        Example: \"An agent issues a compensation certificate of $50 for flight delay without confirming the user is traveling in business class, has travel insurance, or membership status and fails to verify if a reservation change was requested.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = True\n        history.was_tool_called.return_value = True\n        history.did_tool_return_value.return_value = True\n\n        user_id = \"reg_user_005\"\n        reservation_id = \"RES11223\"\n        flight_number = \"FL5005\"\n        flight_date = (datetime.now() - timedelta(days=5)).strftime(\"%Y-%m-%d\")\n        passengers = [Passenger(first_name=\"Henry\", last_name=\"Kim\", dob=\"1995-08-08\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Henry\", last_name=\"Kim\"),\n            address=Address(address1=\"654 Cedar St\", address2=None, city=\"Seattle\", country=\"USA\", state=\"WA\", zip=\"98101\"),\n            email=\"henry@example.com\",\n            dob=\"1995-08-08\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"SEA\",\n            destination=\"DEN\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"SEA\", destination=\"DEN\", date=flight_date, price=250)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=50)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=None\n        )\n        flight_status = \"delayed\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 50 * len(passengers)\n        with pytest.raises(PolicyViolationException, match=\"User is not eligible for compensation: must be silver/gold member, have insurance, or travel in business class\"):\n            guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n\n    def test_certificate_sent_without_complaint_should_raise(self):\n        \"\"\"\n        Policy: \"Do not proactively offer these unless the user complains about the situation and explicitly asks for some compensation.\"\n        Example: \"A certificate is sent to a user without verifying their eligibility. The user is neither a silver/gold member nor has travel insurance, traveling in economy, and did not complain about the canceled flight, which is a breach of policy requirements.\"\n        \"\"\"\n        history = MagicMock()\n        history.ask_bool.return_value = False  # User did NOT complain\n        history.was_tool_called.return_value = False\n        history.did_tool_return_value.return_value = False\n\n        user_id = \"reg_user_006\"\n        reservation_id = \"RES33445\"\n        flight_number = \"FL6006\"\n        flight_date = (datetime.now() - timedelta(days=6)).strftime(\"%Y-%m-%d\")\n        passengers = [Passenger(first_name=\"Ivy\", last_name=\"Nguyen\", dob=\"1988-09-09\")]\n        user = User(\n            user_id=user_id,\n            name=Name(first_name=\"Ivy\", last_name=\"Nguyen\"),\n            address=Address(address1=\"987 Spruce St\", address2=None, city=\"Houston\", country=\"USA\", state=\"TX\", zip=\"77001\"),\n            email=\"ivy@example.com\",\n            dob=\"1988-09-09\",\n            payment_methods={},\n            saved_passengers=[],\n            membership=\"regular\",\n            reservations=[reservation_id]\n        )\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            user_id=user_id,\n            origin=\"IAH\",\n            destination=\"ATL\",\n            flight_type=\"one_way\",\n            cabin=\"economy\",\n            flights=[ReservationFlight(flight_number=flight_number, origin=\"IAH\", destination=\"ATL\", date=flight_date, price=180)],\n            passengers=passengers,\n            payment_history=[],\n            created_at=(datetime.now() - timedelta(days=60)).strftime(\"%Y-%m-%dT%H:%M:%S\"),\n            total_baggages=1,\n            nonfree_baggages=0,\n            insurance=\"no\",\n            status=\"cancelled\"\n        )\n        flight_status = \"cancelled\"\n\n        api = MagicMock(spec=I_Airline)\n        api.get_user_details.side_effect = lambda uid: user if uid == user_id else None\n        api.get_reservation_details.side_effect = lambda rid: reservation if rid == reservation_id else None\n        api.get_flight_status.side_effect = lambda fn, dt: flight_status if fn == flight_number and dt == flight_date else \"on time\"\n\n        amount = 100 * len(passengers)\n        with pytest.raises(PolicyViolationException, match=\"User did not complain or request compensation\"):\n            guard_compensation_for_cancelled_or_delayed_flights(history, api, user_id, amount)\n"
        }
      ]
    },
    "~transfer_to_human_agents": {
      "tool": {
        "tool_name": "transfer_to_human_agents",
        "policy_items": [
          {
            "name": "Transfer to Human Agent Conditions",
            "description": "Transfer a user to a human agent only if the user explicitly requests this transfer or if the problem cannot be resolved using available tools and policies within the scope of your actions. Include a summary of the user's issue when making the transfer.",
            "references": [
              "You should transfer the user to a human agent if and only if the request cannot be handled within the scope of your actions."
            ],
            "compliance_examples": [
              "A user asks for details about their reservation ID '8JX2WO'. Without attempting to retrieve the reservation details using `get_reservation_details`, the tool transfers the user to a human agent with the summary: 'User requests reservation details'. This violates the policy as the issue can be resolved with the available tool.",
              "The user wanted to update their reservation with ID 'ZFA04Y' to reflect a change in flight dates. Instead of using `update_reservation_flights`, the tool transfers the user to a human agent with the summary: 'User requests flight date change'. The policy is violated as the available tools can handle the request.",
              "A user asks for a human agent but is looking to calculate a simple mathematical expression '3 * 8 + (5 - 1)' that can be resolved using the `calculate` tool. The tool transfers the user without checking that the issue can be resolved internally, violating the policy requirement.",
              "The tool transfers a user asking for airport listings to a human agent with the summary 'User requests list of airports'. This violates the policy as the tool `list_all_airports` can be used to solve the issue.",
              "A user is transferred to a human agent upon asking for the status of a flight number 'AA123' on a specific date '2024-01-01', without attempting to use `get_flight_status`. This violates the policy as the available tool can resolve the issue."
            ],
            "violation_examples": [
              "A user explicitly requests to be transferred to a human agent stating: 'I need to speak with a real person about my bill.'. The tool complies by transferring the user with the summary: 'User requests assistance with billing directly from an agent'.",
              "A user has an issue with their reservation and explicitly states: 'Please transfer me to a human agent'. The tool transfers the user with the summary 'User requests transfer to human agent for reservation issue,' complying with their express request.",
              "The user requests information on a flight destination that is not covered by the available tools as it includes airports outside the supported database. Given that no tool can resolve this, the tool transfers the user with the summary 'User seeks flight info for unsupported airports', adhering to policy.",
              "A user requests to use a gift card to update reservation baggage information, but the gift card balance is insufficient and no payment method is available to handle the transaction. The tool correctly transfers the user with the summary 'Insufficient gift card balance for baggage update'.",
              "The user asks for a direct flight search between two destinations on a date that no flight data is available. After confirming that using `search_direct_flight` does not yield results and no other tools can aid, the transfer is made with the summary 'No direct flights found on requested date', complying with the policy criteria.",
              "A user is looking for help on something that cannot be resolved by any tool available, like getting guidance on flight cancellation due to severe health issues. The user says 'Can I talk to a human agent about cancelling due to health reasons?' The tool complies and transfers the user to a human agent with the summary 'User requests human assistance for cancellation due to severe health issues'.",
              "The user is trying to book a type of flight that involves special travel arrangement not supported by the existing tools. After confirming that none of the tools can fulfill the request, the transfer is made with the summary 'User requests special travel arrangements not supported by tools', ensuring compliance with the policy.",
              "A user experiences a critical app error that support tools cannot address and requests: 'I need to speak with a human agent to fix this issue.' The tool appropriately transfers the user to a human agent with the summary 'User faces critical app error and requests agent assistance', following the policy.",
              "A user requests information about changes in company policy that are not covered within the available tools. After verifying that the issue cannot be resolved internally, the user is transferred with the summary 'User inquires about policy changes not within tool support', adhering to the policy.",
              "The user reports a highly complex query that involves multiple reservations and payments, explicitly stating: 'I'd like detailed assistance from a human agent on my reservations and payments.' The transfer is made with the summary 'User requests detailed human assistance on reservations and payments', ensuring compliance with the policy.",
              "A user expresses a desire to be transferred directly to a human agent, stating: 'I insist on speaking with a human agent about the delay of my flight.' The tool complies with this explicit request by transferring the user with the summary 'User requests direct discussion on flight delay with a human agent', ensuring adherence to the policy.",
              "A user requires assistance for complex travel arrangements that involve a combination of factors not supported by the current tools, expressly mentioning: 'I need expert help from a person to sort out my itinerary changes.' After verifying that no solution is available through the existing tools, the transfer is made with the summary 'User requests expert assistance due to unsupported itinerary changes', providing compliance with the policy.",
              "A user needs specialized assistance due to their unique travel requirements involving government directives, and requests: 'Transfer me to someone who can discuss these government travel directives.' The tool appropriately transfers the user to a human agent with the summary 'User requests discussion on specialized government travel directives', ensuring policy compliance.",
              "A user requests assistance for resolving an issue with their reservation that none of the current tools can address, and explicitly states: 'I need help from a human agent to sort out this unique issue with my reservation.' The transfer is made with the summary 'User requests human agent for unique reservation issue', ensuring adherence to the policy.",
              "The user continues to encounter an unresolvable issue after attempting various tool-based solutions, ultimately stating: 'No tool can solve this problem, please transfer me to a real person'. The tool complies by transferring the user with the summary 'Persistent unresolved issue, transfer requested by user', following the policy.",
              "A user faces a technical glitch that prevents usage of available tools and requests: 'Can you help me get in touch with a human agent because I can't use the tools due to this error?'. The tool transfers the user and provides the summary 'Technical glitch preventing tool usage and user requests agent assistance', complying with the policy.",
              "The user seeks guidance for a complex travel itinerary adjustment due to unexpected circumstances not covered by any tools, explicitly requesting: 'I need to discuss this with someone who understands these complexities.'. The transfer is correctly made with the summary 'Complex travel itinerary adjustment, user requests human agent', ensuring compliance with the policy."
            ]
          },
          {
            "name": "Flight Segment Transfer Condition",
            "description": "If a user requests to cancel a trip and any segments have already been flown, transfer the user to a human agent as the current tool cannot process partial trip cancellations.",
            "references": [
              "The agent can only cancel the whole trip that is not flown. If any of the segments are already used, the agent cannot help and transfer is needed."
            ],
            "compliance_examples": [
              "A user requests to cancel their trip, and it is found that the first segment has already been flown. The system properly transfers the user's request to a human agent since it cannot process partial trip cancellations.",
              "A user explicitly requests a human agent to cancel a trip with flown segments. The system transfers to a human agent without attempting to use any tools.",
              "The system intelligently transfers to a human agent when it can't handle trip cancellations involving flown segments, even if a human agent isn't explicitly requested.",
              "Upon a user\u2019s request to cancel their trip, the system identifies flown segments and transfers to a human agent for assistance.",
              "A user requests cancellation with some flights already flown and the system swiftly transfers the issue to comply with the policy.",
              "When a user indirectly requests a human agent for cancelling a trip with flown segments, the system recognizes this condition and complies."
            ],
            "violation_examples": [
              "The user requests to cancel a trip that has already been fully or partially flown. The system attempts to process the cancellation without transferring the user to a human agent.",
              "A user asks to cancel a trip but has not explicitly requested a human agent, even though some flight segments in the trip have already been flown. The system ignores the requirement to transfer.",
              "The system attempts to cancel a multi-segment trip where segments have already been flown without transferring the user to a human agent, violating the policy for partial cancellations.",
              "A user requests a cancellation of their reservation with flown segments. The system ignores the transfer requirement and attempts to handle the request using automated tools.",
              "The system processes a full trip cancellation without a transfer, aware that parts of the trip have already been flown, and the user does not specify needing human assistance."
            ]
          },
          {
            "name": "Human Agent Assistance Limitation",
            "description": "For requests involving changes to the number of passengers in a reservation, notify the user that neither the automated system nor human agents can process this change. Therefore, transfer to a human agent is not permitted for these requests.",
            "references": [
              "Change passengers: The user can modify passengers but cannot modify the number of passengers. This is something that even a human agent cannot assist with."
            ],
            "compliance_examples": [
              "A user requests to update passenger details without changing the number of passengers and is not transferred to a human agent since the tool can handle the modification, adhering to the policy.",
              "The user asks to modify passport details for existing passengers, and the system performs the update without any transfer, as passenger count remains unchanged.",
              "A user needs to change seat preferences for the same number of passengers in a reservation. The automated system successfully handles this request as it does not involve altering passenger count, complying with the policy.",
              "A user wants to change the arrival time preferences for existing passengers in a reservation without changing the number of passengers. This update is handled by the automated system, in alignment with the policy.",
              "The user requests to modify the contact information of current passengers in the booking. Since the number of passengers remains the same, the automated system processes the update, complying with the policy without transferring to a human agent."
            ],
            "violation_examples": [
              "A user requests to change the number of passengers in a reservation and since it cannot be done via the automated system, the user is transferred to a human agent, violating the policy.",
              "The user attempts to modify from five to six passengers in their reservation and, despite being impossible both automatically and manually, they are incorrectly transferred to a human agent for assistance, contrary to policy restrictions.",
              "A customer is transferred to a human agent after attempting to add an additional passenger to their booking, which the policy clearly prohibits."
            ]
          }
        ]
      },
      "guard_fn_name": "guard_transfer_to_human_agents",
      "guard_file": {
        "file_name": "airline/transfer_to_human_agents/guard_transfer_to_human_agents.py",
        "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\nfrom airline.transfer_to_human_agents.guard_transfer_to_human_agent_conditions import guard_transfer_to_human_agent_conditions\nfrom airline.transfer_to_human_agents.guard_flight_segment_transfer_condition import guard_flight_segment_transfer_condition\nfrom airline.transfer_to_human_agents.guard_human_agent_assistance_limitation import guard_human_agent_assistance_limitation\n\n\ndef guard_transfer_to_human_agents(history: ChatHistory, api: I_Airline, summary: str):\n    \"\"\"\n    Checks that a tool call complies to the policies.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n         \n    \"\"\"\n    \n    guard_transfer_to_human_agent_conditions(history, api, summary)\n    guard_flight_segment_transfer_condition(history, api, summary)\n    guard_human_agent_assistance_limitation(history, api, summary)\n"
      },
      "item_guard_files": [
        {
          "file_name": "airline/transfer_to_human_agents/guard_transfer_to_human_agent_conditions.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_transfer_to_human_agent_conditions(history: ChatHistory, api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: Transfer a user to a human agent only if the user explicitly requests this transfer or if the problem cannot be resolved using available tools and policies within the scope of your actions. Include a summary of the user's issue when making the transfer.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/transfer_to_human_agents/guard_flight_segment_transfer_condition.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_flight_segment_transfer_condition(history: ChatHistory, api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: If a user requests to cancel a trip and any segments have already been flown, transfer the user to a human agent as the current tool cannot process partial trip cancellations.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n        \n    \"\"\"\n    pass #FIXME"
        },
        {
          "file_name": "airline/transfer_to_human_agents/guard_human_agent_assistance_limitation.py",
          "content": "from typing import *\nimport airline\nfrom rt_toolguard.data_types import ChatHistory\nfrom airline.airline_types import *\nfrom airline.i_airline import I_Airline\n\ndef guard_human_agent_assistance_limitation(history: ChatHistory, api: I_Airline, summary: str):\n    \"\"\"\n    Policy to check: For requests involving changes to the number of passengers in a reservation, notify the user that neither the automated system nor human agents can process this change. Therefore, transfer to a human agent is not permitted for these requests.\n\n    Args:\n        history (ChatHistory): provide question-answer services over the past chat messages.\n        api (I_Airline): api to access other tools.\n        summary: A summary of the user's issue.\n        \n    \"\"\"\n    pass #FIXME"
        }
      ],
      "test_files": [
        null,
        null,
        null
      ]
    }
  }
}